/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((module) => {

module.exports = require("@nestjs/core");

/***/ }),
/* 2 */
/***/ ((module) => {

module.exports = require("@nestjs/common");

/***/ }),
/* 3 */
/***/ ((module) => {

module.exports = require("@nestjs/swagger");

/***/ }),
/* 4 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AppModule = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(6);
const schedule_1 = __webpack_require__(7);
const auth_module_1 = __webpack_require__(8);
const users_module_1 = __webpack_require__(24);
const charter_deals_module_1 = __webpack_require__(49);
const passengers_module_1 = __webpack_require__(66);
const bookings_module_1 = __webpack_require__(72);
const payments_module_1 = __webpack_require__(99);
const wallet_module_1 = __webpack_require__(97);
const trips_module_1 = __webpack_require__(126);
const locations_module_1 = __webpack_require__(130);
const aircraft_availability_module_1 = __webpack_require__(135);
const direct_charter_module_1 = __webpack_require__(141);
const booking_inquiries_module_1 = __webpack_require__(146);
const google_earth_engine_module_1 = __webpack_require__(63);
const amenities_module_1 = __webpack_require__(56);
const commission_module_1 = __webpack_require__(122);
const experiences_module_1 = __webpack_require__(154);
const sms_module_1 = __webpack_require__(158);
const email_module_1 = __webpack_require__(125);
const health_controller_1 = __webpack_require__(162);
const user_entity_1 = __webpack_require__(14);
const charter_deal_entity_1 = __webpack_require__(30);
const charters_company_entity_1 = __webpack_require__(31);
const aircraft_entity_1 = __webpack_require__(35);
const aircraft_booking_entity_1 = __webpack_require__(163);
const company_entity_1 = __webpack_require__(139);
const passenger_entity_1 = __webpack_require__(41);
const booking_entity_1 = __webpack_require__(29);
const payment_entity_1 = __webpack_require__(76);
const wallet_transaction_entity_1 = __webpack_require__(28);
const user_profile_entity_1 = __webpack_require__(27);
const user_trips_entity_1 = __webpack_require__(77);
const user_files_entity_1 = __webpack_require__(164);
const user_events_entity_1 = __webpack_require__(165);
const booking_timeline_entity_1 = __webpack_require__(74);
const location_entity_1 = __webpack_require__(133);
const aircraft_availability_entity_1 = __webpack_require__(166);
const aircraft_image_entity_1 = __webpack_require__(36);
const aircraft_calendar_entity_1 = __webpack_require__(138);
const booking_inquiry_entity_1 = __webpack_require__(149);
const inquiry_stop_entity_1 = __webpack_require__(150);
const amenity_entity_1 = __webpack_require__(38);
const aircraft_amenity_entity_1 = __webpack_require__(37);
const charter_deal_amenity_entity_1 = __webpack_require__(39);
const aircraft_type_image_placeholder_entity_1 = __webpack_require__(40);
const platform_commission_entity_1 = __webpack_require__(112);
const commission_tier_entity_1 = __webpack_require__(113);
const company_commission_entity_1 = __webpack_require__(114);
const commission_history_entity_1 = __webpack_require__(115);
const company_payment_account_entity_1 = __webpack_require__(91);
const transaction_ledger_entity_1 = __webpack_require__(90);
const experience_template_entity_1 = __webpack_require__(32);
const experience_image_entity_1 = __webpack_require__(33);
const experience_schedule_entity_1 = __webpack_require__(34);
let AppModule = class AppModule {
};
exports.AppModule = AppModule;
exports.AppModule = AppModule = __decorate([
    (0, common_1.Module)({
        imports: [
            config_1.ConfigModule.forRoot({
                isGlobal: true,
                envFilePath: '.env',
            }),
            schedule_1.ScheduleModule.forRoot(),
            typeorm_1.TypeOrmModule.forRootAsync({
                imports: [config_1.ConfigModule],
                useFactory: (configService) => ({
                    type: 'mysql',
                    host: configService.get('DB_HOST'),
                    port: configService.get('DB_PORT'),
                    username: configService.get('DB_USERNAME'),
                    password: configService.get('DB_PASSWORD'),
                    database: configService.get('DB_DATABASE'),
                    entities: [
                        user_entity_1.User,
                        charter_deal_entity_1.CharterDeal,
                        charters_company_entity_1.ChartersCompany,
                        aircraft_entity_1.Aircraft,
                        aircraft_booking_entity_1.Aircraft,
                        company_entity_1.Company,
                        passenger_entity_1.Passenger,
                        booking_entity_1.Booking,
                        payment_entity_1.Payment,
                        wallet_transaction_entity_1.WalletTransaction,
                        user_profile_entity_1.UserProfile,
                        user_trips_entity_1.UserTrip,
                        user_files_entity_1.UserFile,
                        user_events_entity_1.UserEvent,
                        booking_timeline_entity_1.BookingTimeline,
                        location_entity_1.Location,
                        aircraft_availability_entity_1.AircraftAvailability,
                        aircraft_image_entity_1.AircraftImage,
                        aircraft_calendar_entity_1.AircraftCalendar,
                        booking_inquiry_entity_1.BookingInquiry,
                        inquiry_stop_entity_1.InquiryStop,
                        amenity_entity_1.Amenity,
                        aircraft_amenity_entity_1.AircraftAmenity,
                        charter_deal_amenity_entity_1.CharterDealAmenity,
                        aircraft_type_image_placeholder_entity_1.AircraftTypeImagePlaceholder,
                        platform_commission_entity_1.PlatformCommission,
                        commission_tier_entity_1.CommissionTier,
                        company_commission_entity_1.CompanyCommission,
                        commission_history_entity_1.CommissionHistory,
                        company_payment_account_entity_1.CompanyPaymentAccount,
                        transaction_ledger_entity_1.TransactionLedger,
                        experience_template_entity_1.ExperienceTemplate,
                        experience_image_entity_1.ExperienceImage,
                        experience_schedule_entity_1.ExperienceSchedule,
                    ],
                    synchronize: false,
                    logging: false,
                    extra: {
                        connectionLimit: 20,
                        acquireTimeout: 60000,
                        timeout: 60000,
                        charset: 'utf8mb4_unicode_ci',
                        multipleStatements: false,
                        dateStrings: true,
                        supportBigNumbers: true,
                        bigNumberStrings: true,
                        enableKeepAlive: true,
                        keepAliveInitialDelay: 10000,
                        lockWaitTimeout: 30000,
                        innodbLockWaitTimeout: 30,
                    },
                    maxQueryExecutionTime: 30000,
                    cache: {
                        duration: 30000,
                    },
                }),
                inject: [config_1.ConfigService],
            }),
            auth_module_1.AuthModule,
            users_module_1.UsersModule,
            charter_deals_module_1.CharterDealsModule,
            passengers_module_1.PassengersModule,
            bookings_module_1.BookingsModule,
            payments_module_1.PaymentsModule,
            wallet_module_1.WalletModule,
            trips_module_1.TripsModule,
            locations_module_1.LocationsModule,
            aircraft_availability_module_1.AircraftAvailabilityModule,
            direct_charter_module_1.DirectCharterModule,
            booking_inquiries_module_1.BookingInquiriesModule,
            google_earth_engine_module_1.GoogleEarthEngineModule,
            amenities_module_1.AmenitiesModule,
            commission_module_1.CommissionModule,
            experiences_module_1.ExperiencesModule,
            sms_module_1.SmsModule,
            email_module_1.EmailModule,
        ],
        controllers: [health_controller_1.HealthController],
    })
], AppModule);


/***/ }),
/* 5 */
/***/ ((module) => {

module.exports = require("@nestjs/config");

/***/ }),
/* 6 */
/***/ ((module) => {

module.exports = require("@nestjs/typeorm");

/***/ }),
/* 7 */
/***/ ((module) => {

module.exports = require("@nestjs/schedule");

/***/ }),
/* 8 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthModule = void 0;
const common_1 = __webpack_require__(2);
const jwt_1 = __webpack_require__(9);
const passport_1 = __webpack_require__(10);
const typeorm_1 = __webpack_require__(6);
const config_1 = __webpack_require__(5);
const auth_controller_1 = __webpack_require__(11);
const auth_service_1 = __webpack_require__(12);
const jwt_strategy_1 = __webpack_require__(22);
const user_entity_1 = __webpack_require__(14);
let AuthModule = class AuthModule {
};
exports.AuthModule = AuthModule;
exports.AuthModule = AuthModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([user_entity_1.User]),
            passport_1.PassportModule.register({ defaultStrategy: 'jwt' }),
            jwt_1.JwtModule.registerAsync({
                imports: [config_1.ConfigModule],
                useFactory: async (configService) => ({
                    secret: configService.get('JWT_SECRET', 'your-secret-key'),
                    signOptions: {
                        expiresIn: configService.get('JWT_EXPIRES_IN', '1h'),
                    },
                }),
                inject: [config_1.ConfigService],
            }),
        ],
        controllers: [auth_controller_1.AuthController],
        providers: [
            auth_service_1.AuthService,
            jwt_strategy_1.JwtStrategy,
        ],
        exports: [auth_service_1.AuthService, jwt_strategy_1.JwtStrategy],
    })
], AuthModule);


/***/ }),
/* 9 */
/***/ ((module) => {

module.exports = require("@nestjs/jwt");

/***/ }),
/* 10 */
/***/ ((module) => {

module.exports = require("@nestjs/passport");

/***/ }),
/* 11 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const auth_service_1 = __webpack_require__(12);
const jwt_auth_guard_1 = __webpack_require__(16);
const dto_1 = __webpack_require__(17);
const rate_limit_decorator_1 = __webpack_require__(21);
let AuthController = class AuthController {
    constructor(authService) {
        this.authService = authService;
    }
    async register(registerDto) {
        return await this.authService.register(registerDto);
    }
    async login(loginDto) {
        return await this.authService.loginWithEmail(loginDto.email, loginDto.password);
    }
    async refreshToken(refreshTokenDto) {
        return await this.authService.refreshToken(refreshTokenDto.refreshToken);
    }
    async getProfile(req) {
        const user = await this.authService.getUserById(req.user.sub);
        if (!user) {
            throw new Error('User not found');
        }
        return {
            id: user.id,
            email: user.email,
            phoneNumber: user.phone_number,
            firstName: user.first_name,
            lastName: user.last_name,
            countryCode: user.country_code,
            loyaltyPoints: user.loyalty_points,
            walletBalance: user.wallet_balance,
            isActive: user.is_active,
            emailVerified: user.email_verified,
            phoneVerified: user.phone_verified,
            createdAt: user.created_at,
            updatedAt: user.updated_at,
        };
    }
    async updateProfile(req, updateProfileDto) {
        return {
            message: 'Profile update endpoint - implementation needed',
            userId: req.user.sub,
            updateData: updateProfileDto,
        };
    }
    async logout(req) {
        return {
            message: 'Logout successful',
            userId: req.user.sub,
        };
    }
};
exports.AuthController = AuthController;
__decorate([
    (0, common_1.Post)('register'),
    (0, common_1.HttpCode)(common_1.HttpStatus.CREATED),
    (0, rate_limit_decorator_1.RateLimit)(rate_limit_decorator_1.RateLimitConfigs.AUTH),
    (0, swagger_1.ApiOperation)({ summary: 'Register new user' }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'User registered successfully',
        schema: {
            type: 'object',
            properties: {
                accessToken: { type: 'string' },
                refreshToken: { type: 'string' },
                tokenType: { type: 'string' },
                expiresIn: { type: 'number' },
                user: {
                    type: 'object',
                    properties: {
                        id: { type: 'string' },
                        email: { type: 'string' },
                        phoneNumber: { type: 'string' },
                        firstName: { type: 'string' },
                        lastName: { type: 'string' },
                        countryCode: { type: 'string' },
                        loyaltyPoints: { type: 'number' },
                        walletBalance: { type: 'number' },
                        isActive: { type: 'boolean' },
                        emailVerified: { type: 'boolean' },
                        phoneVerified: { type: 'boolean' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid registration data' }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'User already exists' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "register", null);
__decorate([
    (0, common_1.Post)('login'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, rate_limit_decorator_1.RateLimit)(rate_limit_decorator_1.RateLimitConfigs.AUTH),
    (0, swagger_1.ApiOperation)({ summary: 'Login with email and password' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Login successful',
        schema: {
            type: 'object',
            properties: {
                accessToken: { type: 'string' },
                refreshToken: { type: 'string' },
                tokenType: { type: 'string' },
                expiresIn: { type: 'number' },
                user: {
                    type: 'object',
                    properties: {
                        id: { type: 'string' },
                        email: { type: 'string' },
                        phoneNumber: { type: 'string' },
                        firstName: { type: 'string' },
                        lastName: { type: 'string' },
                        countryCode: { type: 'string' },
                        loyaltyPoints: { type: 'number' },
                        walletBalance: { type: 'number' },
                        isActive: { type: 'boolean' },
                        emailVerified: { type: 'boolean' },
                        phoneVerified: { type: 'boolean' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Invalid credentials' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "login", null);
__decorate([
    (0, common_1.Post)('refresh'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Refresh access token' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Token refreshed successfully',
        schema: {
            type: 'object',
            properties: {
                accessToken: { type: 'string' },
                refreshToken: { type: 'string' },
                tokenType: { type: 'string' },
                expiresIn: { type: 'number' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Invalid refresh token' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof dto_1.RefreshTokenDto !== "undefined" && dto_1.RefreshTokenDto) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "refreshToken", null);
__decorate([
    (0, common_1.Get)('profile'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get current user profile' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'User profile retrieved successfully',
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "getProfile", null);
__decorate([
    (0, common_1.Put)('profile'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update user profile' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Profile updated successfully',
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_c = typeof dto_1.UpdateProfileDto !== "undefined" && dto_1.UpdateProfileDto) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "updateProfile", null);
__decorate([
    (0, common_1.Post)('logout'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Logout user' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Logout successful',
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "logout", null);
exports.AuthController = AuthController = __decorate([
    (0, swagger_1.ApiTags)('Authentication'),
    (0, common_1.Controller)('auth'),
    __metadata("design:paramtypes", [typeof (_a = typeof auth_service_1.AuthService !== "undefined" && auth_service_1.AuthService) === "function" ? _a : Object])
], AuthController);


/***/ }),
/* 12 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthService = void 0;
const common_1 = __webpack_require__(2);
const jwt_1 = __webpack_require__(9);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const user_entity_1 = __webpack_require__(14);
const bcrypt = __webpack_require__(15);
let AuthService = class AuthService {
    constructor(jwtService, userRepository) {
        this.jwtService = jwtService;
        this.userRepository = userRepository;
    }
    async register(registerDto) {
        try {
            const { email, password, firstName, lastName, authProvider } = registerDto;
            if (!email || !password || !firstName || !lastName) {
                throw new common_1.BadRequestException('Missing required fields: email, password, firstName, lastName');
            }
            const existingUser = await this.userRepository.findOne({
                where: [
                    { email },
                    { phone_number: email }
                ]
            });
            if (existingUser) {
                throw new common_1.ConflictException('User with this email already exists');
            }
            const saltRounds = 10;
            const hashedPassword = await bcrypt.hash(password, saltRounds);
            const userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const user = this.userRepository.create({
                id: userId,
                email,
                password: hashedPassword,
                first_name: firstName,
                last_name: lastName,
                phone_number: null,
                country_code: null,
                loyalty_points: 0,
                wallet_balance: 0,
                is_active: true,
                email_verified: false,
                phone_verified: false,
            });
            const savedUser = await this.userRepository.save(user);
            console.log('ðŸ”¥ User saved to database:', savedUser.id);
            console.log('ðŸ”¥ Password hashed and stored for backend authentication');
            const payload = {
                sub: savedUser.id,
                email: savedUser.email,
                phone: savedUser.phone_number,
                type: 'backend',
            };
            const accessToken = this.jwtService.sign(payload, { expiresIn: '1h' });
            const refreshToken = this.jwtService.sign(payload, { expiresIn: '7d' });
            return {
                accessToken,
                refreshToken,
                tokenType: 'Bearer',
                expiresIn: 3600,
                user: {
                    id: savedUser.id,
                    email: savedUser.email,
                    phoneNumber: savedUser.phone_number,
                    firstName: savedUser.first_name,
                    lastName: savedUser.last_name,
                    countryCode: savedUser.country_code,
                    loyaltyPoints: savedUser.loyalty_points,
                    walletBalance: savedUser.wallet_balance,
                    isActive: savedUser.is_active,
                    emailVerified: savedUser.email_verified,
                    phoneVerified: savedUser.phone_verified,
                    createdAt: savedUser.created_at,
                    updatedAt: savedUser.updated_at,
                },
            };
        }
        catch (error) {
            console.error('ðŸ”¥ Registration error:', error);
            if (error instanceof common_1.BadRequestException || error instanceof common_1.ConflictException) {
                throw error;
            }
            throw new common_1.BadRequestException('Registration failed: ' + error.message);
        }
    }
    async loginWithEmail(email, password) {
        try {
            console.log('ðŸ”¥ Backend login attempt for:', email);
            const user = await this.userRepository.findOne({
                where: { email }
            });
            if (!user) {
                throw new common_1.UnauthorizedException('Invalid email or password');
            }
            const isPasswordValid = await bcrypt.compare(password, user.password);
            if (!isPasswordValid) {
                throw new common_1.UnauthorizedException('Invalid email or password');
            }
            console.log('ðŸ”¥ Backend login successful for user:', user.id);
            const payload = {
                sub: user.id,
                email: user.email,
                phone: user.phone_number,
                type: 'backend',
            };
            const accessToken = this.jwtService.sign(payload, { expiresIn: '1h' });
            const refreshToken = this.jwtService.sign(payload, { expiresIn: '7d' });
            return {
                accessToken,
                refreshToken,
                tokenType: 'Bearer',
                expiresIn: 3600,
                user: {
                    id: user.id,
                    email: user.email,
                    phoneNumber: user.phone_number,
                    firstName: user.first_name,
                    lastName: user.last_name,
                    countryCode: user.country_code,
                    loyaltyPoints: user.loyalty_points,
                    walletBalance: user.wallet_balance,
                    isActive: user.is_active,
                    emailVerified: user.email_verified,
                    phoneVerified: user.phone_verified,
                    createdAt: user.created_at,
                    updatedAt: user.updated_at,
                },
            };
        }
        catch (error) {
            console.error('ðŸ”¥ Backend login error:', error);
            if (error instanceof common_1.UnauthorizedException) {
                throw error;
            }
            throw new common_1.UnauthorizedException('Login failed: ' + error.message);
        }
    }
    async refreshToken(refreshToken) {
        try {
            const payload = this.jwtService.verify(refreshToken);
            const newPayload = {
                sub: payload.sub,
                email: payload.email,
                phone: payload.phone,
            };
            const accessToken = this.jwtService.sign(newPayload);
            const newRefreshToken = this.jwtService.sign(newPayload, { expiresIn: '7d' });
            return {
                accessToken,
                refreshToken: newRefreshToken,
                tokenType: 'Bearer',
                expiresIn: 3600,
            };
        }
        catch (error) {
            throw new common_1.UnauthorizedException('Invalid refresh token');
        }
    }
    async validateToken(token) {
        try {
            const payload = this.jwtService.verify(token);
            return payload;
        }
        catch (error) {
            return null;
        }
    }
    async getUserById(userId) {
        return await this.userRepository.findOne({
            where: { id: userId }
        });
    }
};
exports.AuthService = AuthService;
exports.AuthService = AuthService = __decorate([
    (0, common_1.Injectable)(),
    __param(1, (0, typeorm_1.InjectRepository)(user_entity_1.User)),
    __metadata("design:paramtypes", [typeof (_a = typeof jwt_1.JwtService !== "undefined" && jwt_1.JwtService) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object])
], AuthService);


/***/ }),
/* 13 */
/***/ ((module) => {

module.exports = require("typeorm");

/***/ }),
/* 14 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.User = exports.Theme = exports.LoyaltyTier = void 0;
const typeorm_1 = __webpack_require__(13);
var LoyaltyTier;
(function (LoyaltyTier) {
    LoyaltyTier["BRONZE"] = "bronze";
    LoyaltyTier["SILVER"] = "silver";
    LoyaltyTier["GOLD"] = "gold";
    LoyaltyTier["PLATINUM"] = "platinum";
})(LoyaltyTier || (exports.LoyaltyTier = LoyaltyTier = {}));
var Theme;
(function (Theme) {
    Theme["LIGHT"] = "light";
    Theme["DARK"] = "dark";
    Theme["AUTO"] = "auto";
})(Theme || (exports.Theme = Theme = {}));
let User = class User {
    get fullName() {
        return `${this.first_name || ''} ${this.last_name || ''}`.trim();
    }
    get displayName() {
        return this.fullName || this.email || this.phone_number || 'Unknown User';
    }
};
exports.User = User;
__decorate([
    (0, typeorm_1.PrimaryColumn)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], User.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255, nullable: true, unique: true }),
    __metadata("design:type", String)
], User.prototype, "email", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], User.prototype, "password", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 20, nullable: true, unique: true }),
    (0, typeorm_1.Index)(),
    __metadata("design:type", String)
], User.prototype, "phone_number", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], User.prototype, "first_name", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], User.prototype, "last_name", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 5, nullable: true }),
    __metadata("design:type", String)
], User.prototype, "country_code", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'date_of_birth', type: 'date', nullable: true }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], User.prototype, "date_of_birth", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], User.prototype, "nationality", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 50, default: 'en' }),
    __metadata("design:type", String)
], User.prototype, "language", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 20, default: 'USD' }),
    __metadata("design:type", String)
], User.prototype, "currency", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 50, default: 'UTC' }),
    __metadata("design:type", String)
], User.prototype, "timezone", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: Theme, default: Theme.AUTO }),
    __metadata("design:type", String)
], User.prototype, "theme", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], User.prototype, "profile_image_url", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], User.prototype, "profile_image_public_id", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', default: 0 }),
    __metadata("design:type", Number)
], User.prototype, "loyalty_points", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'loyalty_tier', type: 'enum', enum: LoyaltyTier, default: LoyaltyTier.BRONZE }),
    __metadata("design:type", String)
], User.prototype, "loyalty_tier", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'decimal', precision: 10, scale: 2, default: 0.0 }),
    __metadata("design:type", Number)
], User.prototype, "wallet_balance", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'boolean', default: true }),
    __metadata("design:type", Boolean)
], User.prototype, "is_active", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], User.prototype, "email_verified", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], User.prototype, "phone_verified", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)(),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], User.prototype, "created_at", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)(),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], User.prototype, "updated_at", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'deleted_at', type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], User.prototype, "deleted_at", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'deletion_reason', type: 'text', nullable: true }),
    __metadata("design:type", String)
], User.prototype, "deletion_reason", void 0);
exports.User = User = __decorate([
    (0, typeorm_1.Entity)('users')
], User);


/***/ }),
/* 15 */
/***/ ((module) => {

module.exports = require("bcrypt");

/***/ }),
/* 16 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JwtAuthGuard = void 0;
const common_1 = __webpack_require__(2);
const passport_1 = __webpack_require__(10);
let JwtAuthGuard = class JwtAuthGuard extends (0, passport_1.AuthGuard)('jwt') {
    canActivate(context) {
        return super.canActivate(context);
    }
    handleRequest(err, user, info) {
        if (err || !user) {
            throw err || new common_1.UnauthorizedException('Invalid or expired token');
        }
        return user;
    }
};
exports.JwtAuthGuard = JwtAuthGuard;
exports.JwtAuthGuard = JwtAuthGuard = __decorate([
    (0, common_1.Injectable)()
], JwtAuthGuard);


/***/ }),
/* 17 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(18), exports);
__exportStar(__webpack_require__(20), exports);


/***/ }),
/* 18 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RefreshTokenDto = void 0;
const swagger_1 = __webpack_require__(3);
const class_validator_1 = __webpack_require__(19);
class RefreshTokenDto {
}
exports.RefreshTokenDto = RefreshTokenDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Refresh token for getting new access token',
        example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], RefreshTokenDto.prototype, "refreshToken", void 0);


/***/ }),
/* 19 */
/***/ ((module) => {

module.exports = require("class-validator");

/***/ }),
/* 20 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateProfileDto = void 0;
const swagger_1 = __webpack_require__(3);
const class_validator_1 = __webpack_require__(19);
class UpdateProfileDto {
}
exports.UpdateProfileDto = UpdateProfileDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User first name',
        required: false,
        example: 'John',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateProfileDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User last name',
        required: false,
        example: 'Doe',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateProfileDto.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User phone number',
        required: false,
        example: '+1234567890',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateProfileDto.prototype, "phoneNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User country code',
        required: false,
        example: '+1',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateProfileDto.prototype, "countryCode", void 0);


/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RateLimitConfigs = exports.RateLimit = exports.RATE_LIMIT_KEY = void 0;
const common_1 = __webpack_require__(2);
exports.RATE_LIMIT_KEY = 'rateLimit';
const RateLimit = (config) => (0, common_1.SetMetadata)(exports.RATE_LIMIT_KEY, config);
exports.RateLimit = RateLimit;
exports.RateLimitConfigs = {
    AUTH: {
        windowMs: 15 * 60 * 1000,
        maxRequests: 5,
        message: 'Too many authentication attempts. Please try again later.',
    },
    BOOKING: {
        windowMs: 60 * 1000,
        maxRequests: 10,
        message: 'Too many booking requests. Please slow down.',
    },
    GENERAL: {
        windowMs: 60 * 1000,
        maxRequests: 60,
        message: 'Too many requests. Please slow down.',
    },
    PAYMENT: {
        windowMs: 60 * 1000,
        maxRequests: 3,
        message: 'Too many payment attempts. Please try again later.',
    },
    SEARCH: {
        windowMs: 60 * 1000,
        maxRequests: 30,
        message: 'Too many search requests. Please slow down.',
    },
};


/***/ }),
/* 22 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JwtStrategy = void 0;
const common_1 = __webpack_require__(2);
const passport_1 = __webpack_require__(10);
const passport_jwt_1 = __webpack_require__(23);
const config_1 = __webpack_require__(5);
let JwtStrategy = class JwtStrategy extends (0, passport_1.PassportStrategy)(passport_jwt_1.Strategy) {
    constructor(configService) {
        super({
            jwtFromRequest: passport_jwt_1.ExtractJwt.fromAuthHeaderAsBearerToken(),
            ignoreExpiration: false,
            secretOrKey: configService.get('JWT_SECRET', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9'),
        });
        this.configService = configService;
    }
    async validate(payload) {
        if (!payload.sub) {
            throw new common_1.UnauthorizedException('Invalid token payload');
        }
        return {
            sub: payload.sub,
            id: payload.sub,
            email: payload.email,
            phone: payload.phone,
            type: payload.type,
        };
    }
};
exports.JwtStrategy = JwtStrategy;
exports.JwtStrategy = JwtStrategy = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], JwtStrategy);


/***/ }),
/* 23 */
/***/ ((module) => {

module.exports = require("passport-jwt");

/***/ }),
/* 24 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const users_controller_1 = __webpack_require__(25);
const users_service_1 = __webpack_require__(26);
const user_entity_1 = __webpack_require__(14);
const user_profile_entity_1 = __webpack_require__(27);
const wallet_transaction_entity_1 = __webpack_require__(28);
const user_profile_service_1 = __webpack_require__(42);
let UsersModule = class UsersModule {
};
exports.UsersModule = UsersModule;
exports.UsersModule = UsersModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([user_entity_1.User, user_profile_entity_1.UserProfile, wallet_transaction_entity_1.WalletTransaction]),
        ],
        controllers: [users_controller_1.UsersController],
        providers: [users_service_1.UsersService, user_profile_service_1.UserProfileService],
        exports: [users_service_1.UsersService],
    })
], UsersModule);


/***/ }),
/* 25 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const jwt_auth_guard_1 = __webpack_require__(16);
const users_service_1 = __webpack_require__(26);
const dto_1 = __webpack_require__(43);
let UsersController = class UsersController {
    constructor(usersService) {
        this.usersService = usersService;
    }
    async getProfile(req) {
        const userId = req.user.sub;
        const user = await this.usersService.getUserById(userId);
        if (!user) {
            throw new common_1.NotFoundException('User not found');
        }
        const preferences = await this.usersService.getUserPreferences(userId);
        return {
            id: user.id,
            email: user.email,
            phoneNumber: user.phone_number,
            firstName: user.first_name,
            lastName: user.last_name,
            countryCode: user.country_code,
            profileImageUrl: user.profile_image_url,
            loyaltyPoints: user.loyalty_points,
            walletBalance: user.wallet_balance,
            isActive: user.is_active,
            emailVerified: user.email_verified,
            phoneVerified: user.phone_verified,
            createdAt: user.created_at,
            updatedAt: user.updated_at,
            preferences,
        };
    }
    async updateProfile(req, updateProfileDto) {
        const userId = req.user.sub;
        try {
            const updatedUser = await this.usersService.updateUserProfile(userId, updateProfileDto);
            return {
                message: 'Profile updated successfully',
                user: {
                    id: updatedUser.id,
                    email: updatedUser.email,
                    phoneNumber: updatedUser.phone_number,
                    firstName: updatedUser.first_name,
                    lastName: updatedUser.last_name,
                    countryCode: updatedUser.country_code,
                    profileImageUrl: updatedUser.profile_image_url,
                    loyaltyPoints: updatedUser.loyalty_points,
                    walletBalance: updatedUser.wallet_balance,
                    isActive: updatedUser.is_active,
                    emailVerified: updatedUser.email_verified,
                    phoneVerified: updatedUser.phone_verified,
                    createdAt: updatedUser.created_at,
                    updatedAt: updatedUser.updated_at,
                },
            };
        }
        catch (error) {
            throw new common_1.BadRequestException(`Failed to update profile: ${error.message}`);
        }
    }
    async updatePreferences(req, updatePreferencesDto) {
        const userId = req.user.sub;
        try {
            const updatedPreferences = await this.usersService.updateUserPreferences(userId, updatePreferencesDto);
            return {
                message: 'Preferences updated successfully',
                preferences: updatedPreferences,
            };
        }
        catch (error) {
            throw new common_1.BadRequestException(`Failed to update preferences: ${error.message}`);
        }
    }
    async getWalletInfo(req) {
        const userId = req.user.sub;
        const user = await this.usersService.getUserById(userId);
        if (!user) {
            throw new common_1.NotFoundException('User not found');
        }
        return {
            balance: user.wallet_balance,
            loyaltyPoints: user.loyalty_points,
            currency: 'USD',
            lastTransaction: user.updated_at,
        };
    }
    async changePassword(req, changePasswordDto) {
        const userId = req.user.sub;
        try {
            await this.usersService.changePassword(userId, changePasswordDto);
            return {
                message: 'Password changed successfully',
            };
        }
        catch (error) {
            if (error.message === 'Invalid current password') {
                throw new common_1.UnauthorizedException('Invalid current password');
            }
            throw new common_1.BadRequestException(`Failed to change password: ${error.message}`);
        }
    }
    async deleteAccount(req, deleteAccountDto) {
        const userId = req.user.sub;
        try {
            await this.usersService.deleteAccount(userId, deleteAccountDto);
            return {
                message: 'Account deleted successfully',
            };
        }
        catch (error) {
            if (error.message === 'Invalid password') {
                throw new common_1.UnauthorizedException('Invalid password');
            }
            throw new common_1.BadRequestException(`Failed to delete account: ${error.message}`);
        }
    }
    async exportUserData(req) {
        const userId = req.user.sub;
        try {
            const userData = await this.usersService.exportUserData(userId);
            return {
                userData,
            };
        }
        catch (error) {
            throw new common_1.BadRequestException(`Failed to export user data: ${error.message}`);
        }
    }
    async updatePrivacySettings(req, privacySettingsDto) {
        const userId = req.user.sub;
        try {
            const updatedSettings = await this.usersService.updatePrivacySettings(userId, privacySettingsDto);
            return {
                message: 'Privacy settings updated successfully',
                privacySettings: updatedSettings,
            };
        }
        catch (error) {
            throw new common_1.BadRequestException(`Failed to update privacy settings: ${error.message}`);
        }
    }
    async getPrivacySettings(req) {
        const userId = req.user.sub;
        try {
            const privacySettings = await this.usersService.getPrivacySettings(userId);
            return {
                privacySettings,
            };
        }
        catch (error) {
            throw new common_1.BadRequestException(`Failed to get privacy settings: ${error.message}`);
        }
    }
};
exports.UsersController = UsersController;
__decorate([
    (0, common_1.Get)('profile'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get current user profile' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'User profile retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                id: { type: 'string' },
                email: { type: 'string' },
                phoneNumber: { type: 'string' },
                firstName: { type: 'string' },
                lastName: { type: 'string' },
                countryCode: { type: 'string' },
                profileImageUrl: { type: 'string' },
                loyaltyPoints: { type: 'number' },
                walletBalance: { type: 'number' },
                isActive: { type: 'boolean' },
                emailVerified: { type: 'boolean' },
                phoneVerified: { type: 'boolean' },
                createdAt: { type: 'string', format: 'date-time' },
                updatedAt: { type: 'string', format: 'date-time' },
                preferences: {
                    type: 'object',
                    properties: {
                        language: { type: 'string' },
                        currency: { type: 'string' },
                        notifications: { type: 'boolean' },
                        dateOfBirth: { type: 'string', format: 'date' },
                        nationality: { type: 'string' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "getProfile", null);
__decorate([
    (0, common_1.Put)('profile'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Update user profile' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Profile updated successfully',
        schema: {
            type: 'object',
            properties: {
                message: { type: 'string' },
                user: {
                    type: 'object',
                    properties: {
                        id: { type: 'string' },
                        email: { type: 'string' },
                        phoneNumber: { type: 'string' },
                        firstName: { type: 'string' },
                        lastName: { type: 'string' },
                        countryCode: { type: 'string' },
                        profileImageUrl: { type: 'string' },
                        loyaltyPoints: { type: 'number' },
                        walletBalance: { type: 'number' },
                        isActive: { type: 'boolean' },
                        emailVerified: { type: 'boolean' },
                        phoneVerified: { type: 'boolean' },
                        createdAt: { type: 'string', format: 'date-time' },
                        updatedAt: { type: 'string', format: 'date-time' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid profile data' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_b = typeof dto_1.UpdateUserProfileDto !== "undefined" && dto_1.UpdateUserProfileDto) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "updateProfile", null);
__decorate([
    (0, common_1.Put)('preferences'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Update user preferences' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Preferences updated successfully',
        schema: {
            type: 'object',
            properties: {
                message: { type: 'string' },
                preferences: {
                    type: 'object',
                    properties: {
                        language: { type: 'string' },
                        currency: { type: 'string' },
                        notifications: { type: 'boolean' },
                        dateOfBirth: { type: 'string', format: 'date' },
                        nationality: { type: 'string' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid preferences data' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_c = typeof dto_1.UpdateUserPreferencesDto !== "undefined" && dto_1.UpdateUserPreferencesDto) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "updatePreferences", null);
__decorate([
    (0, common_1.Get)('wallet'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get user wallet information' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Wallet information retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                balance: { type: 'number' },
                loyaltyPoints: { type: 'number' },
                currency: { type: 'string' },
                lastTransaction: { type: 'string', format: 'date-time' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "getWalletInfo", null);
__decorate([
    (0, common_1.Put)('password'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Change user password' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Password changed successfully',
        schema: {
            type: 'object',
            properties: {
                message: { type: 'string' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid password data' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized or invalid current password' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_d = typeof dto_1.ChangePasswordDto !== "undefined" && dto_1.ChangePasswordDto) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "changePassword", null);
__decorate([
    (0, common_1.Delete)('account'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Delete user account' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Account deleted successfully',
        schema: {
            type: 'object',
            properties: {
                message: { type: 'string' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid request data' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized or invalid password' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_e = typeof dto_1.DeleteAccountDto !== "undefined" && dto_1.DeleteAccountDto) === "function" ? _e : Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "deleteAccount", null);
__decorate([
    (0, common_1.Get)('export'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Export user data' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'User data exported successfully',
        schema: {
            type: 'object',
            properties: {
                userData: {
                    type: 'object',
                    properties: {
                        profile: { type: 'object' },
                        preferences: { type: 'object' },
                        bookings: { type: 'array' },
                        transactions: { type: 'array' },
                        exportDate: { type: 'string', format: 'date-time' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "exportUserData", null);
__decorate([
    (0, common_1.Put)('privacy'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Update privacy settings' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Privacy settings updated successfully',
        schema: {
            type: 'object',
            properties: {
                message: { type: 'string' },
                privacySettings: {
                    type: 'object',
                    properties: {
                        dataSharing: { type: 'boolean' },
                        marketingEmails: { type: 'boolean' },
                        smsNotifications: { type: 'boolean' },
                        pushNotifications: { type: 'boolean' },
                        profileVisible: { type: 'boolean' },
                        locationTracking: { type: 'boolean' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid privacy settings data' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_f = typeof dto_1.PrivacySettingsDto !== "undefined" && dto_1.PrivacySettingsDto) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "updatePrivacySettings", null);
__decorate([
    (0, common_1.Get)('privacy'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get privacy settings' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Privacy settings retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                privacySettings: {
                    type: 'object',
                    properties: {
                        dataSharing: { type: 'boolean' },
                        marketingEmails: { type: 'boolean' },
                        smsNotifications: { type: 'boolean' },
                        pushNotifications: { type: 'boolean' },
                        profileVisible: { type: 'boolean' },
                        locationTracking: { type: 'boolean' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "getPrivacySettings", null);
exports.UsersController = UsersController = __decorate([
    (0, swagger_1.ApiTags)('Users'),
    (0, common_1.Controller)('users'),
    __metadata("design:paramtypes", [typeof (_a = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _a : Object])
], UsersController);


/***/ }),
/* 26 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const user_entity_1 = __webpack_require__(14);
const user_profile_entity_1 = __webpack_require__(27);
const wallet_transaction_entity_1 = __webpack_require__(28);
const user_profile_service_1 = __webpack_require__(42);
const bcrypt = __webpack_require__(15);
let UsersService = class UsersService {
    constructor(userRepository, userProfileRepository, walletTransactionRepository, userProfileService) {
        this.userRepository = userRepository;
        this.userProfileRepository = userProfileRepository;
        this.walletTransactionRepository = walletTransactionRepository;
        this.userProfileService = userProfileService;
    }
    async getUserById(userId) {
        return this.userProfileService.getUserById(userId);
    }
    async updateUserProfile(userId, updateProfileDto) {
        return this.userProfileService.updateUserProfile(userId, updateProfileDto);
    }
    async getUserPreferences(userId) {
        return this.userProfileService.getUserPreferences(userId);
    }
    async updateUserPreferences(userId, updatePreferencesDto) {
        return this.userProfileService.updateUserPreferences(userId, updatePreferencesDto);
    }
    async getUserWalletInfo(userId) {
        const user = await this.getUserById(userId);
        if (!user) {
            throw new common_1.NotFoundException('User not found');
        }
        const recentTransactions = await this.walletTransactionRepository.find({
            where: { userId: userId },
            order: { createdAt: 'DESC' },
            take: 5,
        });
        return {
            balance: user.wallet_balance,
            loyaltyPoints: user.loyalty_points,
            loyaltyTier: user.loyalty_tier,
            currency: user.currency || 'USD',
            lastTransaction: user.updated_at,
            recentTransactions: recentTransactions.map(tx => ({
                id: tx.id,
                type: tx.transactionType,
                amount: tx.amount,
                pointsAmount: tx.pointsAmount,
                description: tx.description,
                status: tx.status,
                createdAt: tx.createdAt,
            })),
        };
    }
    async createWalletTransaction(userId, transactionType, amount, pointsAmount, description, bookingId, metadata) {
        const user = await this.getUserById(userId);
        if (!user) {
            throw new common_1.NotFoundException('User not found');
        }
        const transaction = this.walletTransactionRepository.create({
            id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            userId,
            bookingId,
            transactionType,
            amount,
            pointsAmount,
            description,
            balanceBefore: user.wallet_balance,
            balanceAfter: user.wallet_balance + amount,
            pointsBefore: user.loyalty_points,
            pointsAfter: user.loyalty_points + pointsAmount,
            status: wallet_transaction_entity_1.WalletTransactionStatus.COMPLETED,
            metadata,
            completedAt: new Date(),
        });
        user.wallet_balance = transaction.balanceAfter;
        user.loyalty_points = transaction.pointsAfter;
        await this.userRepository.save(user);
        return await this.walletTransactionRepository.save(transaction);
    }
    async changePassword(userId, changePasswordDto) {
        const user = await this.getUserById(userId);
        if (!user) {
            throw new common_1.NotFoundException('User not found');
        }
        const isCurrentPasswordValid = await bcrypt.compare(changePasswordDto.currentPassword, user.password);
        if (!isCurrentPasswordValid) {
            throw new common_1.UnauthorizedException('Invalid current password');
        }
        const saltRounds = 10;
        const hashedNewPassword = await bcrypt.hash(changePasswordDto.newPassword, saltRounds);
        user.password = hashedNewPassword;
        await this.userRepository.save(user);
    }
    async deleteAccount(userId, deleteAccountDto) {
        const user = await this.getUserById(userId);
        if (!user) {
            throw new common_1.NotFoundException('User not found');
        }
        const isPasswordValid = await bcrypt.compare(deleteAccountDto.password, user.password);
        if (!isPasswordValid) {
            throw new common_1.UnauthorizedException('Invalid password');
        }
        user.is_active = false;
        user.deleted_at = new Date();
        user.deletion_reason = deleteAccountDto.reason || 'User requested deletion';
        await this.userRepository.save(user);
    }
    async exportUserData(userId) {
        const user = await this.getUserById(userId);
        if (!user) {
            throw new common_1.NotFoundException('User not found');
        }
        const preferences = await this.getUserPreferences(userId);
        const bookings = [];
        const transactions = await this.walletTransactionRepository.find({
            where: { userId: userId },
            order: { createdAt: 'DESC' },
        });
        return {
            profile: {
                id: user.id,
                email: user.email,
                phoneNumber: user.phone_number,
                firstName: user.first_name,
                lastName: user.last_name,
                countryCode: user.country_code,
                profileImageUrl: user.profile_image_url,
                loyaltyPoints: user.loyalty_points,
                walletBalance: user.wallet_balance,
                isActive: user.is_active,
                emailVerified: user.email_verified,
                phoneVerified: user.phone_verified,
                createdAt: user.created_at,
                updatedAt: user.updated_at,
            },
            preferences,
            bookings,
            transactions: transactions.map(tx => ({
                id: tx.id,
                type: tx.transactionType,
                amount: tx.amount,
                pointsAmount: tx.pointsAmount,
                description: tx.description,
                status: tx.status,
                createdAt: tx.createdAt,
                completedAt: tx.completedAt,
            })),
            exportDate: new Date().toISOString(),
        };
    }
    async updatePrivacySettings(userId, privacySettingsDto) {
        let profile = await this.userProfileRepository.findOne({
            where: { userId: userId },
        });
        if (!profile) {
            profile = this.userProfileRepository.create({
                userId: userId,
                seatPreference: user_profile_entity_1.SeatPreference.ANY,
                emailNotifications: true,
                smsNotifications: true,
                pushNotifications: true,
                marketingEmails: true,
                profileVisible: false,
            });
        }
        if (privacySettingsDto.dataSharing !== undefined) {
            profile.dataSharing = privacySettingsDto.dataSharing;
        }
        if (privacySettingsDto.marketingEmails !== undefined) {
            profile.marketingEmails = privacySettingsDto.marketingEmails;
        }
        if (privacySettingsDto.smsNotifications !== undefined) {
            profile.smsNotifications = privacySettingsDto.smsNotifications;
        }
        if (privacySettingsDto.pushNotifications !== undefined) {
            profile.pushNotifications = privacySettingsDto.pushNotifications;
        }
        if (privacySettingsDto.profileVisible !== undefined) {
            profile.profileVisible = privacySettingsDto.profileVisible;
        }
        if (privacySettingsDto.locationTracking !== undefined) {
            profile.locationTracking = privacySettingsDto.locationTracking;
        }
        const savedProfile = await this.userProfileRepository.save(profile);
        return {
            dataSharing: savedProfile.dataSharing,
            marketingEmails: savedProfile.marketingEmails,
            smsNotifications: savedProfile.smsNotifications,
            pushNotifications: savedProfile.pushNotifications,
            profileVisible: savedProfile.profileVisible,
            locationTracking: savedProfile.locationTracking,
        };
    }
    async getPrivacySettings(userId) {
        const profile = await this.userProfileRepository.findOne({
            where: { userId: userId },
        });
        if (!profile) {
            return {
                dataSharing: false,
                marketingEmails: true,
                smsNotifications: true,
                pushNotifications: true,
                profileVisible: false,
                locationTracking: true,
            };
        }
        return {
            dataSharing: profile.dataSharing,
            marketingEmails: profile.marketingEmails,
            smsNotifications: profile.smsNotifications,
            pushNotifications: profile.pushNotifications,
            profileVisible: profile.profileVisible,
            locationTracking: profile.locationTracking,
        };
    }
};
exports.UsersService = UsersService;
exports.UsersService = UsersService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(user_entity_1.User)),
    __param(1, (0, typeorm_1.InjectRepository)(user_profile_entity_1.UserProfile)),
    __param(2, (0, typeorm_1.InjectRepository)(wallet_transaction_entity_1.WalletTransaction)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object, typeof (_d = typeof user_profile_service_1.UserProfileService !== "undefined" && user_profile_service_1.UserProfileService) === "function" ? _d : Object])
], UsersService);


/***/ }),
/* 27 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserProfile = exports.SeatPreference = void 0;
const typeorm_1 = __webpack_require__(13);
const user_entity_1 = __webpack_require__(14);
var SeatPreference;
(function (SeatPreference) {
    SeatPreference["WINDOW"] = "window";
    SeatPreference["AISLE"] = "aisle";
    SeatPreference["ANY"] = "any";
})(SeatPreference || (exports.SeatPreference = SeatPreference = {}));
let UserProfile = class UserProfile {
};
exports.UserProfile = UserProfile;
__decorate([
    (0, typeorm_1.PrimaryColumn)({ name: 'user_id', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], UserProfile.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'seat_preference', type: 'enum', enum: SeatPreference, default: SeatPreference.ANY }),
    __metadata("design:type", String)
], UserProfile.prototype, "seatPreference", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'meal_preference', type: 'text', nullable: true }),
    __metadata("design:type", String)
], UserProfile.prototype, "mealPreference", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'special_assistance', type: 'text', nullable: true }),
    __metadata("design:type", String)
], UserProfile.prototype, "specialAssistance", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'email_notifications', type: 'boolean', default: true }),
    __metadata("design:type", Boolean)
], UserProfile.prototype, "emailNotifications", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'sms_notifications', type: 'boolean', default: true }),
    __metadata("design:type", Boolean)
], UserProfile.prototype, "smsNotifications", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'push_notifications', type: 'boolean', default: true }),
    __metadata("design:type", Boolean)
], UserProfile.prototype, "pushNotifications", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'marketing_emails', type: 'boolean', default: true }),
    __metadata("design:type", Boolean)
], UserProfile.prototype, "marketingEmails", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'profile_visible', type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], UserProfile.prototype, "profileVisible", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'data_sharing', type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], UserProfile.prototype, "dataSharing", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'location_tracking', type: 'boolean', default: true }),
    __metadata("design:type", Boolean)
], UserProfile.prototype, "locationTracking", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'created_at' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], UserProfile.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updated_at' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], UserProfile.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, user => user.id),
    (0, typeorm_1.JoinColumn)({ name: 'user_id' }),
    __metadata("design:type", typeof (_c = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _c : Object)
], UserProfile.prototype, "user", void 0);
exports.UserProfile = UserProfile = __decorate([
    (0, typeorm_1.Entity)('user_profile')
], UserProfile);


/***/ }),
/* 28 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WalletTransaction = exports.WalletTransactionStatus = exports.WalletTransactionType = void 0;
const typeorm_1 = __webpack_require__(13);
const user_entity_1 = __webpack_require__(14);
const booking_entity_1 = __webpack_require__(29);
var WalletTransactionType;
(function (WalletTransactionType) {
    WalletTransactionType["DEPOSIT"] = "deposit";
    WalletTransactionType["WITHDRAWAL"] = "withdrawal";
    WalletTransactionType["PAYMENT"] = "payment";
    WalletTransactionType["REFUND"] = "refund";
    WalletTransactionType["BONUS"] = "bonus";
    WalletTransactionType["FEE"] = "fee";
    WalletTransactionType["LOYALTY_EARNED"] = "loyalty_earned";
    WalletTransactionType["LOYALTY_REDEEMED"] = "loyalty_redeemed";
    WalletTransactionType["LOYALTY_EXPIRED"] = "loyalty_expired";
    WalletTransactionType["LOYALTY_ADJUSTMENT"] = "loyalty_adjustment";
})(WalletTransactionType || (exports.WalletTransactionType = WalletTransactionType = {}));
var WalletTransactionStatus;
(function (WalletTransactionStatus) {
    WalletTransactionStatus["PENDING"] = "pending";
    WalletTransactionStatus["COMPLETED"] = "completed";
    WalletTransactionStatus["FAILED"] = "failed";
    WalletTransactionStatus["CANCELLED"] = "cancelled";
})(WalletTransactionStatus || (exports.WalletTransactionStatus = WalletTransactionStatus = {}));
let WalletTransaction = class WalletTransaction {
};
exports.WalletTransaction = WalletTransaction;
__decorate([
    (0, typeorm_1.PrimaryColumn)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], WalletTransaction.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'user_id', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], WalletTransaction.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'booking_id', nullable: true }),
    __metadata("design:type", String)
], WalletTransaction.prototype, "bookingId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'transaction_type', type: 'enum', enum: WalletTransactionType }),
    __metadata("design:type", String)
], WalletTransaction.prototype, "transactionType", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'decimal', precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], WalletTransaction.prototype, "amount", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'points_amount', type: 'int', default: 0 }),
    __metadata("design:type", Number)
], WalletTransaction.prototype, "pointsAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 3, default: 'USD', nullable: true }),
    __metadata("design:type", String)
], WalletTransaction.prototype, "currency", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], WalletTransaction.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], WalletTransaction.prototype, "reference", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'balance_before', type: 'decimal', precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], WalletTransaction.prototype, "balanceBefore", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'balance_after', type: 'decimal', precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], WalletTransaction.prototype, "balanceAfter", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'points_before', type: 'int', default: 0 }),
    __metadata("design:type", Number)
], WalletTransaction.prototype, "pointsBefore", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'points_after', type: 'int', default: 0 }),
    __metadata("design:type", Number)
], WalletTransaction.prototype, "pointsAfter", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'payment_method', type: 'enum', enum: ['card', 'mpesa', 'wallet', 'loyalty_points'], nullable: true }),
    __metadata("design:type", String)
], WalletTransaction.prototype, "paymentMethod", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'payment_reference', type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], WalletTransaction.prototype, "paymentReference", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: WalletTransactionStatus, default: WalletTransactionStatus.PENDING }),
    __metadata("design:type", String)
], WalletTransaction.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'json', nullable: true }),
    __metadata("design:type", Object)
], WalletTransaction.prototype, "metadata", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'expires_at', type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], WalletTransaction.prototype, "expiresAt", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'created_at' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], WalletTransaction.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'completed_at', type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], WalletTransaction.prototype, "completedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, user => user.id),
    (0, typeorm_1.JoinColumn)({ name: 'user_id' }),
    __metadata("design:type", typeof (_d = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _d : Object)
], WalletTransaction.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => booking_entity_1.Booking, booking => booking.id, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'booking_id' }),
    __metadata("design:type", typeof (_e = typeof booking_entity_1.Booking !== "undefined" && booking_entity_1.Booking) === "function" ? _e : Object)
], WalletTransaction.prototype, "booking", void 0);
exports.WalletTransaction = WalletTransaction = __decorate([
    (0, typeorm_1.Entity)('wallet_transactions')
], WalletTransaction);


/***/ }),
/* 29 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g, _h;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Booking = exports.BookingType = exports.PaymentStatus = exports.BookingStatus = void 0;
const typeorm_1 = __webpack_require__(13);
const user_entity_1 = __webpack_require__(14);
const charter_deal_entity_1 = __webpack_require__(30);
const charters_company_entity_1 = __webpack_require__(31);
const passenger_entity_1 = __webpack_require__(41);
const aircraft_entity_1 = __webpack_require__(35);
var BookingStatus;
(function (BookingStatus) {
    BookingStatus["PENDING"] = "pending";
    BookingStatus["PRICED"] = "priced";
    BookingStatus["CONFIRMED"] = "confirmed";
    BookingStatus["CANCELLED"] = "cancelled";
    BookingStatus["COMPLETED"] = "completed";
})(BookingStatus || (exports.BookingStatus = BookingStatus = {}));
var PaymentStatus;
(function (PaymentStatus) {
    PaymentStatus["PENDING"] = "pending";
    PaymentStatus["PAID"] = "paid";
    PaymentStatus["FAILED"] = "failed";
    PaymentStatus["REFUNDED"] = "refunded";
})(PaymentStatus || (exports.PaymentStatus = PaymentStatus = {}));
var BookingType;
(function (BookingType) {
    BookingType["DIRECT"] = "direct";
    BookingType["DEAL"] = "deal";
    BookingType["EXPERIENCE"] = "experience";
})(BookingType || (exports.BookingType = BookingType = {}));
let Booking = class Booking {
    get formattedPrice() {
        return this.totalPrice ? `$${this.totalPrice.toFixed(2)}` : 'N/A';
    }
    get isConfirmed() {
        return this.bookingStatus === BookingStatus.CONFIRMED ||
            this.bookingStatus === BookingStatus.COMPLETED;
    }
    get isPaid() {
        return this.paymentStatus === PaymentStatus.PAID;
    }
    get canBeCancelled() {
        return this.bookingStatus === BookingStatus.PENDING ||
            this.bookingStatus === BookingStatus.PRICED ||
            this.bookingStatus === BookingStatus.CONFIRMED;
    }
    get isPending() {
        return this.bookingStatus === BookingStatus.PENDING ||
            this.bookingStatus === BookingStatus.PRICED;
    }
};
exports.Booking = Booking;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], Booking.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'userId', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], Booking.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'companyId', type: 'int' }),
    __metadata("design:type", Number)
], Booking.prototype, "companyId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'aircraftId', type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Booking.prototype, "aircraftId", void 0);
__decorate([
    (0, typeorm_1.Column)({
        name: 'bookingType',
        type: 'enum',
        enum: BookingType
    }),
    __metadata("design:type", String)
], Booking.prototype, "bookingType", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'dealId', type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Booking.prototype, "dealId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'experienceScheduleId', type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Booking.prototype, "experienceScheduleId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'totalPrice', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], Booking.prototype, "totalPrice", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'taxType', type: 'varchar', length: 50, nullable: true }),
    __metadata("design:type", String)
], Booking.prototype, "taxType", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'taxAmount', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], Booking.prototype, "taxAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'subtotal', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], Booking.prototype, "subtotal", void 0);
__decorate([
    (0, typeorm_1.Column)({
        name: 'bookingStatus',
        type: 'enum',
        enum: BookingStatus,
        default: BookingStatus.PENDING
    }),
    __metadata("design:type", String)
], Booking.prototype, "bookingStatus", void 0);
__decorate([
    (0, typeorm_1.Column)({
        name: 'paymentStatus',
        type: 'enum',
        enum: PaymentStatus,
        default: PaymentStatus.PENDING
    }),
    __metadata("design:type", String)
], Booking.prototype, "paymentStatus", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'referenceNumber', type: 'varchar', length: 50 }),
    __metadata("design:type", String)
], Booking.prototype, "referenceNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'specialRequirements', type: 'text', nullable: true }),
    __metadata("design:type", String)
], Booking.prototype, "specialRequirements", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'adminNotes', type: 'text', nullable: true }),
    __metadata("design:type", String)
], Booking.prototype, "adminNotes", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'originName', type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], Booking.prototype, "originName", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'originLatitude', type: 'decimal', precision: 10, scale: 7, nullable: true }),
    __metadata("design:type", Number)
], Booking.prototype, "originLatitude", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'originLongitude', type: 'decimal', precision: 10, scale: 7, nullable: true }),
    __metadata("design:type", Number)
], Booking.prototype, "originLongitude", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'destinationName', type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], Booking.prototype, "destinationName", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'destinationLatitude', type: 'decimal', precision: 10, scale: 7, nullable: true }),
    __metadata("design:type", Number)
], Booking.prototype, "destinationLatitude", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'destinationLongitude', type: 'decimal', precision: 10, scale: 7, nullable: true }),
    __metadata("design:type", Number)
], Booking.prototype, "destinationLongitude", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'departureDateTime', type: 'datetime', nullable: true }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Booking.prototype, "departureDateTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'estimatedFlightHours', type: 'decimal', precision: 5, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], Booking.prototype, "estimatedFlightHours", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'distanceNm', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], Booking.prototype, "distanceNm", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'estimatedArrivalTime', type: 'datetime', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Booking.prototype, "estimatedArrivalTime", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], Booking.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'totalAdults', type: 'int', default: 0 }),
    __metadata("design:type", Number)
], Booking.prototype, "totalAdults", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'totalChildren', type: 'int', default: 0 }),
    __metadata("design:type", Number)
], Booking.prototype, "totalChildren", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'onboardDining', type: 'tinyint', default: 0 }),
    __metadata("design:type", Boolean)
], Booking.prototype, "onboardDining", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], Booking.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_e = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _e : Object)
], Booking.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => charter_deal_entity_1.CharterDeal, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'dealId' }),
    __metadata("design:type", typeof (_f = typeof charter_deal_entity_1.CharterDeal !== "undefined" && charter_deal_entity_1.CharterDeal) === "function" ? _f : Object)
], Booking.prototype, "deal", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => charters_company_entity_1.ChartersCompany),
    (0, typeorm_1.JoinColumn)({ name: 'companyId' }),
    __metadata("design:type", typeof (_g = typeof charters_company_entity_1.ChartersCompany !== "undefined" && charters_company_entity_1.ChartersCompany) === "function" ? _g : Object)
], Booking.prototype, "company", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => aircraft_entity_1.Aircraft, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'aircraftId' }),
    __metadata("design:type", typeof (_h = typeof aircraft_entity_1.Aircraft !== "undefined" && aircraft_entity_1.Aircraft) === "function" ? _h : Object)
], Booking.prototype, "aircraft", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => passenger_entity_1.Passenger, passenger => passenger.booking),
    __metadata("design:type", Array)
], Booking.prototype, "passengers", void 0);
exports.Booking = Booking = __decorate([
    (0, typeorm_1.Entity)('charter_bookings')
], Booking);


/***/ }),
/* 30 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CharterDeal = void 0;
const typeorm_1 = __webpack_require__(13);
const charters_company_entity_1 = __webpack_require__(31);
const aircraft_entity_1 = __webpack_require__(35);
const charter_deal_amenity_entity_1 = __webpack_require__(39);
let CharterDeal = class CharterDeal {
};
exports.CharterDeal = CharterDeal;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], CharterDeal.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'companyId', type: 'int' }),
    __metadata("design:type", Number)
], CharterDeal.prototype, "companyId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'aircraftId', type: 'int' }),
    __metadata("design:type", Number)
], CharterDeal.prototype, "aircraftId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'originName', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], CharterDeal.prototype, "originName", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'originLatitude', type: 'decimal', precision: 10, scale: 8, nullable: true }),
    __metadata("design:type", Number)
], CharterDeal.prototype, "originLatitude", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'originLongitude', type: 'decimal', precision: 11, scale: 8, nullable: true }),
    __metadata("design:type", Number)
], CharterDeal.prototype, "originLongitude", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'destinationName', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], CharterDeal.prototype, "destinationName", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'destinationLatitude', type: 'decimal', precision: 10, scale: 8, nullable: true }),
    __metadata("design:type", Number)
], CharterDeal.prototype, "destinationLatitude", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'destinationLongitude', type: 'decimal', precision: 11, scale: 8, nullable: true }),
    __metadata("design:type", Number)
], CharterDeal.prototype, "destinationLongitude", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], CharterDeal.prototype, "date", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time' }),
    __metadata("design:type", String)
], CharterDeal.prototype, "time", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], CharterDeal.prototype, "pricePerSeat", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', default: 0 }),
    __metadata("design:type", Number)
], CharterDeal.prototype, "discountPerSeat", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int' }),
    __metadata("design:type", Number)
], CharterDeal.prototype, "availableSeats", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'pilotId', type: 'int', nullable: true }),
    __metadata("design:type", Number)
], CharterDeal.prototype, "pilotId", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], CharterDeal.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], CharterDeal.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => charters_company_entity_1.ChartersCompany, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'companyId' }),
    __metadata("design:type", typeof (_d = typeof charters_company_entity_1.ChartersCompany !== "undefined" && charters_company_entity_1.ChartersCompany) === "function" ? _d : Object)
], CharterDeal.prototype, "company", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => aircraft_entity_1.Aircraft, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'aircraftId' }),
    __metadata("design:type", typeof (_e = typeof aircraft_entity_1.Aircraft !== "undefined" && aircraft_entity_1.Aircraft) === "function" ? _e : Object)
], CharterDeal.prototype, "aircraft", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => charter_deal_amenity_entity_1.CharterDealAmenity, charterDealAmenity => charterDealAmenity.charterDeal),
    __metadata("design:type", Array)
], CharterDeal.prototype, "charterDealAmenities", void 0);
exports.CharterDeal = CharterDeal = __decorate([
    (0, typeorm_1.Entity)('charter_deals')
], CharterDeal);


/***/ }),
/* 31 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartersCompany = void 0;
const typeorm_1 = __webpack_require__(13);
const charter_deal_entity_1 = __webpack_require__(30);
const experience_template_entity_1 = __webpack_require__(32);
let ChartersCompany = class ChartersCompany {
};
exports.ChartersCompany = ChartersCompany;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], ChartersCompany.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'companyName', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "companyName", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "email", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'contactPersonFirstName', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "contactPersonFirstName", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'contactPersonLastName', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "contactPersonLastName", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'mobileNumber', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "mobileNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "logo", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "country", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'licenseNumber', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "licenseNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "license", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'licensePublicId', type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "licensePublicId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'logoPublicId', type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "logoPublicId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'onboardedBy', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "onboardedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'adminId', type: 'int' }),
    __metadata("design:type", Number)
], ChartersCompany.prototype, "adminId", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: ['pendingReview', 'active', 'inactive', 'rejected', 'draft'],
        default: 'draft'
    }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'agreementForm', type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "agreementForm", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'agreementFormPublicId', type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "agreementFormPublicId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'approvedBy', type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "approvedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'approvedAt', type: 'datetime', nullable: true }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], ChartersCompany.prototype, "approvedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'reviewRemarks', type: 'text', nullable: true }),
    __metadata("design:type", String)
], ChartersCompany.prototype, "reviewRemarks", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], ChartersCompany.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], ChartersCompany.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => charter_deal_entity_1.CharterDeal, deal => deal.company),
    __metadata("design:type", Array)
], ChartersCompany.prototype, "deals", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => experience_template_entity_1.ExperienceTemplate, experience => experience.company),
    __metadata("design:type", Array)
], ChartersCompany.prototype, "experienceTemplates", void 0);
exports.ChartersCompany = ChartersCompany = __decorate([
    (0, typeorm_1.Entity)('charters_companies')
], ChartersCompany);


/***/ }),
/* 32 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExperienceTemplate = void 0;
const typeorm_1 = __webpack_require__(13);
const experience_image_entity_1 = __webpack_require__(33);
const experience_schedule_entity_1 = __webpack_require__(34);
const charters_company_entity_1 = __webpack_require__(31);
let ExperienceTemplate = class ExperienceTemplate {
};
exports.ExperienceTemplate = ExperienceTemplate;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], ExperienceTemplate.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'companyId', type: 'int' }),
    __metadata("design:type", Number)
], ExperienceTemplate.prototype, "companyId", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100 }),
    __metadata("design:type", String)
], ExperienceTemplate.prototype, "title", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text' }),
    __metadata("design:type", String)
], ExperienceTemplate.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100 }),
    __metadata("design:type", String)
], ExperienceTemplate.prototype, "country", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100 }),
    __metadata("design:type", String)
], ExperienceTemplate.prototype, "city", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'locationName', type: 'varchar', length: 150, nullable: true }),
    __metadata("design:type", String)
], ExperienceTemplate.prototype, "locationName", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'isActive', type: 'tinyint', default: 1 }),
    __metadata("design:type", Boolean)
], ExperienceTemplate.prototype, "isActive", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'termsConditions', type: 'text', nullable: true }),
    __metadata("design:type", String)
], ExperienceTemplate.prototype, "termsConditions", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], ExperienceTemplate.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], ExperienceTemplate.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => charters_company_entity_1.ChartersCompany, company => company.experienceTemplates),
    (0, typeorm_1.JoinColumn)({ name: 'companyId' }),
    __metadata("design:type", typeof (_c = typeof charters_company_entity_1.ChartersCompany !== "undefined" && charters_company_entity_1.ChartersCompany) === "function" ? _c : Object)
], ExperienceTemplate.prototype, "company", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => experience_image_entity_1.ExperienceImage, image => image.experience),
    __metadata("design:type", Array)
], ExperienceTemplate.prototype, "images", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => experience_schedule_entity_1.ExperienceSchedule, schedule => schedule.experience),
    __metadata("design:type", Array)
], ExperienceTemplate.prototype, "schedules", void 0);
exports.ExperienceTemplate = ExperienceTemplate = __decorate([
    (0, typeorm_1.Entity)('experience_templates')
], ExperienceTemplate);


/***/ }),
/* 33 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExperienceImage = void 0;
const typeorm_1 = __webpack_require__(13);
const experience_template_entity_1 = __webpack_require__(32);
let ExperienceImage = class ExperienceImage {
};
exports.ExperienceImage = ExperienceImage;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], ExperienceImage.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'experienceId', type: 'int' }),
    __metadata("design:type", Number)
], ExperienceImage.prototype, "experienceId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'imageSlot', type: 'varchar', length: 50 }),
    __metadata("design:type", String)
], ExperienceImage.prototype, "imageSlot", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text' }),
    __metadata("design:type", String)
], ExperienceImage.prototype, "url", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'publicId', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], ExperienceImage.prototype, "publicId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'sortOrder', type: 'int', default: 0 }),
    __metadata("design:type", Number)
], ExperienceImage.prototype, "sortOrder", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], ExperienceImage.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], ExperienceImage.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => experience_template_entity_1.ExperienceTemplate, experience => experience.images),
    (0, typeorm_1.JoinColumn)({ name: 'experienceId' }),
    __metadata("design:type", typeof (_c = typeof experience_template_entity_1.ExperienceTemplate !== "undefined" && experience_template_entity_1.ExperienceTemplate) === "function" ? _c : Object)
], ExperienceImage.prototype, "experience", void 0);
exports.ExperienceImage = ExperienceImage = __decorate([
    (0, typeorm_1.Entity)('experience_images')
], ExperienceImage);


/***/ }),
/* 34 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExperienceSchedule = exports.ScheduleStatus = exports.PriceUnit = void 0;
const typeorm_1 = __webpack_require__(13);
const experience_template_entity_1 = __webpack_require__(32);
const charters_company_entity_1 = __webpack_require__(31);
const aircraft_entity_1 = __webpack_require__(35);
var PriceUnit;
(function (PriceUnit) {
    PriceUnit["PER_PERSON"] = "per_person";
    PriceUnit["PER_GROUP"] = "per_group";
    PriceUnit["PER_HOUR"] = "per_hour";
    PriceUnit["PER_FLIGHT"] = "per_flight";
})(PriceUnit || (exports.PriceUnit = PriceUnit = {}));
var ScheduleStatus;
(function (ScheduleStatus) {
    ScheduleStatus["SCHEDULED"] = "scheduled";
    ScheduleStatus["CANCELLED"] = "cancelled";
    ScheduleStatus["COMPLETED"] = "completed";
})(ScheduleStatus || (exports.ScheduleStatus = ScheduleStatus = {}));
let ExperienceSchedule = class ExperienceSchedule {
};
exports.ExperienceSchedule = ExperienceSchedule;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], ExperienceSchedule.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'experienceId', type: 'int' }),
    __metadata("design:type", Number)
], ExperienceSchedule.prototype, "experienceId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'companyId', type: 'int' }),
    __metadata("design:type", Number)
], ExperienceSchedule.prototype, "companyId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'aircraftId', type: 'int', nullable: true }),
    __metadata("design:type", Number)
], ExperienceSchedule.prototype, "aircraftId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'startTime', type: 'datetime' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], ExperienceSchedule.prototype, "startTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'endTime', type: 'datetime', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], ExperienceSchedule.prototype, "endTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'priceUnit', type: 'enum', enum: PriceUnit, default: PriceUnit.PER_PERSON }),
    __metadata("design:type", String)
], ExperienceSchedule.prototype, "priceUnit", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'durationMinutes', type: 'int' }),
    __metadata("design:type", Number)
], ExperienceSchedule.prototype, "durationMinutes", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'seatsAvailable', type: 'int' }),
    __metadata("design:type", Number)
], ExperienceSchedule.prototype, "seatsAvailable", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: ScheduleStatus, default: ScheduleStatus.SCHEDULED }),
    __metadata("design:type", String)
], ExperienceSchedule.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], ExperienceSchedule.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], ExperienceSchedule.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'taxType', type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], ExperienceSchedule.prototype, "taxType", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'subTotal', type: 'decimal', precision: 10, scale: 2 }),
    __metadata("design:type", Number)
], ExperienceSchedule.prototype, "subTotal", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'total', type: 'decimal', precision: 10, scale: 2 }),
    __metadata("design:type", Number)
], ExperienceSchedule.prototype, "total", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'taxAmount', type: 'decimal', precision: 10, scale: 2, default: 0.00 }),
    __metadata("design:type", Number)
], ExperienceSchedule.prototype, "taxAmount", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => experience_template_entity_1.ExperienceTemplate, experience => experience.schedules),
    (0, typeorm_1.JoinColumn)({ name: 'experienceId' }),
    __metadata("design:type", typeof (_e = typeof experience_template_entity_1.ExperienceTemplate !== "undefined" && experience_template_entity_1.ExperienceTemplate) === "function" ? _e : Object)
], ExperienceSchedule.prototype, "experience", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => charters_company_entity_1.ChartersCompany),
    (0, typeorm_1.JoinColumn)({ name: 'companyId' }),
    __metadata("design:type", typeof (_f = typeof charters_company_entity_1.ChartersCompany !== "undefined" && charters_company_entity_1.ChartersCompany) === "function" ? _f : Object)
], ExperienceSchedule.prototype, "company", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => aircraft_entity_1.Aircraft),
    (0, typeorm_1.JoinColumn)({ name: 'aircraftId' }),
    __metadata("design:type", typeof (_g = typeof aircraft_entity_1.Aircraft !== "undefined" && aircraft_entity_1.Aircraft) === "function" ? _g : Object)
], ExperienceSchedule.prototype, "aircraft", void 0);
exports.ExperienceSchedule = ExperienceSchedule = __decorate([
    (0, typeorm_1.Entity)('experience_schedules')
], ExperienceSchedule);


/***/ }),
/* 35 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Aircraft = void 0;
const typeorm_1 = __webpack_require__(13);
const charter_deal_entity_1 = __webpack_require__(30);
const charters_company_entity_1 = __webpack_require__(31);
const aircraft_image_entity_1 = __webpack_require__(36);
const aircraft_amenity_entity_1 = __webpack_require__(37);
const aircraft_type_image_placeholder_entity_1 = __webpack_require__(40);
let Aircraft = class Aircraft {
};
exports.Aircraft = Aircraft;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], Aircraft.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'companyId', type: 'int' }),
    __metadata("design:type", Number)
], Aircraft.prototype, "companyId", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100 }),
    __metadata("design:type", String)
], Aircraft.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'registrationNumber', type: 'varchar', length: 20, unique: true }),
    __metadata("design:type", String)
], Aircraft.prototype, "registrationNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: ['helicopter', 'fixedWing', 'jet', 'glider', 'seaplane', 'ultralight', 'balloon', 'tiltrotor', 'gyroplane', 'airship']
    }),
    __metadata("design:type", String)
], Aircraft.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], Aircraft.prototype, "model", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], Aircraft.prototype, "manufacturer", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'yearManufactured', type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Aircraft.prototype, "yearManufactured", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int' }),
    __metadata("design:type", Number)
], Aircraft.prototype, "capacity", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'pricePerHour', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], Aircraft.prototype, "pricePerHour", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'cruiseSpeedKnots', type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Aircraft.prototype, "cruiseSpeedKnots", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'isAvailable', type: 'boolean', default: true }),
    __metadata("design:type", Boolean)
], Aircraft.prototype, "isAvailable", void 0);
__decorate([
    (0, typeorm_1.Column)({
        name: 'maintenanceStatus',
        type: 'enum',
        enum: ['operational', 'maintenance', 'out_of_service'],
        default: 'operational'
    }),
    __metadata("design:type", String)
], Aircraft.prototype, "maintenanceStatus", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'baseAirport', type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], Aircraft.prototype, "baseAirport", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'baseCity', type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], Aircraft.prototype, "baseCity", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'aircraftTypeImagePlaceholderId', type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Aircraft.prototype, "aircraftTypeImagePlaceholderId", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Aircraft.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Aircraft.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => charters_company_entity_1.ChartersCompany, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'companyId' }),
    __metadata("design:type", typeof (_c = typeof charters_company_entity_1.ChartersCompany !== "undefined" && charters_company_entity_1.ChartersCompany) === "function" ? _c : Object)
], Aircraft.prototype, "company", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => charter_deal_entity_1.CharterDeal, deal => deal.aircraft),
    __metadata("design:type", Array)
], Aircraft.prototype, "deals", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => aircraft_image_entity_1.AircraftImage, image => image.aircraft),
    __metadata("design:type", Array)
], Aircraft.prototype, "images", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => aircraft_amenity_entity_1.AircraftAmenity, aircraftAmenity => aircraftAmenity.aircraft),
    __metadata("design:type", Array)
], Aircraft.prototype, "aircraftAmenities", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => aircraft_type_image_placeholder_entity_1.AircraftTypeImagePlaceholder, { onDelete: 'SET NULL' }),
    (0, typeorm_1.JoinColumn)({ name: 'aircraftTypeImagePlaceholderId' }),
    __metadata("design:type", typeof (_d = typeof aircraft_type_image_placeholder_entity_1.AircraftTypeImagePlaceholder !== "undefined" && aircraft_type_image_placeholder_entity_1.AircraftTypeImagePlaceholder) === "function" ? _d : Object)
], Aircraft.prototype, "aircraftTypeImagePlaceholder", void 0);
exports.Aircraft = Aircraft = __decorate([
    (0, typeorm_1.Entity)('aircrafts')
], Aircraft);


/***/ }),
/* 36 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AircraftImage = void 0;
const typeorm_1 = __webpack_require__(13);
const aircraft_entity_1 = __webpack_require__(35);
let AircraftImage = class AircraftImage {
};
exports.AircraftImage = AircraftImage;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], AircraftImage.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'aircraftId', type: 'int' }),
    __metadata("design:type", Number)
], AircraftImage.prototype, "aircraftId", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 50 }),
    __metadata("design:type", String)
], AircraftImage.prototype, "category", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text' }),
    __metadata("design:type", String)
], AircraftImage.prototype, "url", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'publicId', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], AircraftImage.prototype, "publicId", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], AircraftImage.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], AircraftImage.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => aircraft_entity_1.Aircraft, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'aircraftId' }),
    __metadata("design:type", typeof (_c = typeof aircraft_entity_1.Aircraft !== "undefined" && aircraft_entity_1.Aircraft) === "function" ? _c : Object)
], AircraftImage.prototype, "aircraft", void 0);
exports.AircraftImage = AircraftImage = __decorate([
    (0, typeorm_1.Entity)('aircraft_images')
], AircraftImage);


/***/ }),
/* 37 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AircraftAmenity = void 0;
const typeorm_1 = __webpack_require__(13);
const aircraft_entity_1 = __webpack_require__(35);
const amenity_entity_1 = __webpack_require__(38);
let AircraftAmenity = class AircraftAmenity {
};
exports.AircraftAmenity = AircraftAmenity;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], AircraftAmenity.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'aircraftId', type: 'int' }),
    __metadata("design:type", Number)
], AircraftAmenity.prototype, "aircraftId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'amenityId', type: 'int' }),
    __metadata("design:type", Number)
], AircraftAmenity.prototype, "amenityId", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => aircraft_entity_1.Aircraft, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'aircraftId' }),
    __metadata("design:type", typeof (_a = typeof aircraft_entity_1.Aircraft !== "undefined" && aircraft_entity_1.Aircraft) === "function" ? _a : Object)
], AircraftAmenity.prototype, "aircraft", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => amenity_entity_1.Amenity, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'amenityId' }),
    __metadata("design:type", typeof (_b = typeof amenity_entity_1.Amenity !== "undefined" && amenity_entity_1.Amenity) === "function" ? _b : Object)
], AircraftAmenity.prototype, "amenity", void 0);
exports.AircraftAmenity = AircraftAmenity = __decorate([
    (0, typeorm_1.Entity)('aircraft_amenities')
], AircraftAmenity);


/***/ }),
/* 38 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Amenity = void 0;
const typeorm_1 = __webpack_require__(13);
const aircraft_amenity_entity_1 = __webpack_require__(37);
const charter_deal_amenity_entity_1 = __webpack_require__(39);
let Amenity = class Amenity {
};
exports.Amenity = Amenity;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], Amenity.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], Amenity.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => aircraft_amenity_entity_1.AircraftAmenity, aircraftAmenity => aircraftAmenity.amenity),
    __metadata("design:type", Array)
], Amenity.prototype, "aircraftAmenities", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => charter_deal_amenity_entity_1.CharterDealAmenity, charterDealAmenity => charterDealAmenity.amenity),
    __metadata("design:type", Array)
], Amenity.prototype, "charterDealAmenities", void 0);
exports.Amenity = Amenity = __decorate([
    (0, typeorm_1.Entity)('amenities')
], Amenity);


/***/ }),
/* 39 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CharterDealAmenity = void 0;
const typeorm_1 = __webpack_require__(13);
const charter_deal_entity_1 = __webpack_require__(30);
const amenity_entity_1 = __webpack_require__(38);
let CharterDealAmenity = class CharterDealAmenity {
};
exports.CharterDealAmenity = CharterDealAmenity;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], CharterDealAmenity.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'dealId', type: 'int' }),
    __metadata("design:type", Number)
], CharterDealAmenity.prototype, "dealId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'amenityId', type: 'int' }),
    __metadata("design:type", Number)
], CharterDealAmenity.prototype, "amenityId", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => charter_deal_entity_1.CharterDeal, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'dealId' }),
    __metadata("design:type", typeof (_a = typeof charter_deal_entity_1.CharterDeal !== "undefined" && charter_deal_entity_1.CharterDeal) === "function" ? _a : Object)
], CharterDealAmenity.prototype, "charterDeal", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => amenity_entity_1.Amenity, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'amenityId' }),
    __metadata("design:type", typeof (_b = typeof amenity_entity_1.Amenity !== "undefined" && amenity_entity_1.Amenity) === "function" ? _b : Object)
], CharterDealAmenity.prototype, "amenity", void 0);
exports.CharterDealAmenity = CharterDealAmenity = __decorate([
    (0, typeorm_1.Entity)('charter_deal_amenities')
], CharterDealAmenity);


/***/ }),
/* 40 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AircraftTypeImagePlaceholder = void 0;
const typeorm_1 = __webpack_require__(13);
const aircraft_entity_1 = __webpack_require__(35);
let AircraftTypeImagePlaceholder = class AircraftTypeImagePlaceholder {
};
exports.AircraftTypeImagePlaceholder = AircraftTypeImagePlaceholder;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], AircraftTypeImagePlaceholder.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: ['helicopter', 'fixedWing', 'jet', 'glider', 'seaplane', 'ultralight', 'balloon', 'tiltrotor', 'gyroplane', 'airship']
    }),
    __metadata("design:type", String)
], AircraftTypeImagePlaceholder.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'placeholderImageUrl', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], AircraftTypeImagePlaceholder.prototype, "placeholderImageUrl", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'placeholderImagePublicId', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], AircraftTypeImagePlaceholder.prototype, "placeholderImagePublicId", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], AircraftTypeImagePlaceholder.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], AircraftTypeImagePlaceholder.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => aircraft_entity_1.Aircraft, aircraft => aircraft.aircraftTypeImagePlaceholder),
    __metadata("design:type", Array)
], AircraftTypeImagePlaceholder.prototype, "aircraft", void 0);
exports.AircraftTypeImagePlaceholder = AircraftTypeImagePlaceholder = __decorate([
    (0, typeorm_1.Entity)('aircraft_type_image_placeholders')
], AircraftTypeImagePlaceholder);


/***/ }),
/* 41 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Passenger = void 0;
const typeorm_1 = __webpack_require__(13);
const booking_entity_1 = __webpack_require__(29);
let Passenger = class Passenger {
    get fullName() {
        return `${this.first_name} ${this.last_name}`.trim();
    }
    get displayName() {
        return this.fullName || 'Unnamed Passenger';
    }
};
exports.Passenger = Passenger;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], Passenger.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'booking_id', type: 'int' }),
    (0, typeorm_1.Index)(),
    __metadata("design:type", Number)
], Passenger.prototype, "booking_id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'first_name', type: 'varchar', length: 100 }),
    __metadata("design:type", String)
], Passenger.prototype, "first_name", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'last_name', type: 'varchar', length: 100 }),
    __metadata("design:type", String)
], Passenger.prototype, "last_name", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Passenger.prototype, "age", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], Passenger.prototype, "nationality", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'id_passport_number', type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], Passenger.prototype, "id_passport_number", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'is_user', type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], Passenger.prototype, "is_user", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'created_at' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Passenger.prototype, "created_at", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => booking_entity_1.Booking, booking => booking.passengers),
    (0, typeorm_1.JoinColumn)({ name: 'booking_id' }),
    __metadata("design:type", typeof (_b = typeof booking_entity_1.Booking !== "undefined" && booking_entity_1.Booking) === "function" ? _b : Object)
], Passenger.prototype, "booking", void 0);
exports.Passenger = Passenger = __decorate([
    (0, typeorm_1.Entity)('charter_passengers')
], Passenger);


/***/ }),
/* 42 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserProfileService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const user_entity_1 = __webpack_require__(14);
const user_profile_entity_1 = __webpack_require__(27);
let UserProfileService = class UserProfileService {
    constructor(userRepository, userProfileRepository) {
        this.userRepository = userRepository;
        this.userProfileRepository = userProfileRepository;
    }
    async getUserById(userId) {
        return await this.userRepository.findOne({
            where: { id: userId },
        });
    }
    async updateUserProfile(userId, updateProfileDto) {
        const user = await this.getUserById(userId);
        if (!user) {
            throw new common_1.NotFoundException('User not found');
        }
        if (updateProfileDto.firstName !== undefined) {
            user.first_name = updateProfileDto.firstName;
        }
        if (updateProfileDto.lastName !== undefined) {
            user.last_name = updateProfileDto.lastName;
        }
        if (updateProfileDto.email !== undefined) {
            user.email = updateProfileDto.email;
        }
        if (updateProfileDto.phoneNumber !== undefined) {
            user.phone_number = updateProfileDto.phoneNumber;
        }
        if (updateProfileDto.countryCode !== undefined) {
            user.country_code = updateProfileDto.countryCode;
        }
        if (updateProfileDto.profileImageUrl !== undefined) {
            user.profile_image_url = updateProfileDto.profileImageUrl;
        }
        return await this.userRepository.save(user);
    }
    async getUserPreferences(userId) {
        const profile = await this.userProfileRepository.findOne({
            where: { userId: userId },
        });
        if (!profile) {
            return {
                seatPreference: 'any',
                mealPreference: null,
                specialAssistance: null,
                emailNotifications: true,
                smsNotifications: true,
                pushNotifications: true,
                marketingEmails: true,
                profileVisible: false,
            };
        }
        return {
            seatPreference: profile.seatPreference,
            mealPreference: profile.mealPreference,
            specialAssistance: profile.specialAssistance,
            emailNotifications: profile.emailNotifications,
            smsNotifications: profile.smsNotifications,
            pushNotifications: profile.pushNotifications,
            marketingEmails: profile.marketingEmails,
            profileVisible: profile.profileVisible,
        };
    }
    async updateUserPreferences(userId, updatePreferencesDto) {
        let profile = await this.userProfileRepository.findOne({
            where: { userId: userId },
        });
        if (!profile) {
            profile = this.userProfileRepository.create({
                userId: userId,
                seatPreference: user_profile_entity_1.SeatPreference.ANY,
                emailNotifications: true,
                smsNotifications: true,
                pushNotifications: true,
                marketingEmails: true,
                profileVisible: false,
            });
        }
        if (updatePreferencesDto.language !== undefined) {
            const user = await this.getUserById(userId);
            if (user) {
                user.language = updatePreferencesDto.language;
                await this.userRepository.save(user);
            }
        }
        if (updatePreferencesDto.currency !== undefined) {
            const user = await this.getUserById(userId);
            if (user) {
                user.currency = updatePreferencesDto.currency;
                await this.userRepository.save(user);
            }
        }
        if (updatePreferencesDto.notifications !== undefined) {
            profile.emailNotifications = updatePreferencesDto.notifications;
            profile.smsNotifications = updatePreferencesDto.notifications;
            profile.pushNotifications = updatePreferencesDto.notifications;
        }
        if (updatePreferencesDto.dateOfBirth !== undefined) {
            const user = await this.getUserById(userId);
            if (user) {
                user.date_of_birth = new Date(updatePreferencesDto.dateOfBirth);
                await this.userRepository.save(user);
            }
        }
        if (updatePreferencesDto.nationality !== undefined) {
            const user = await this.getUserById(userId);
            if (user) {
                user.nationality = updatePreferencesDto.nationality;
                await this.userRepository.save(user);
            }
        }
        await this.userProfileRepository.save(profile);
        return {
            seatPreference: profile.seatPreference,
            mealPreference: profile.mealPreference,
            specialAssistance: profile.specialAssistance,
            emailNotifications: profile.emailNotifications,
            smsNotifications: profile.smsNotifications,
            pushNotifications: profile.pushNotifications,
            marketingEmails: profile.marketingEmails,
            profileVisible: profile.profileVisible,
        };
    }
    async createOrUpdateProfile(userId, profileData) {
        let profile = await this.userProfileRepository.findOne({
            where: { userId: userId },
        });
        if (!profile) {
            profile = this.userProfileRepository.create({
                userId: userId,
                ...profileData,
            });
        }
        else {
            Object.assign(profile, profileData);
        }
        return await this.userProfileRepository.save(profile);
    }
    async getUserProfile(userId) {
        return await this.userProfileRepository.findOne({
            where: { userId: userId },
        });
    }
    async deleteUserProfile(userId) {
        await this.userProfileRepository.delete({ userId: userId });
    }
};
exports.UserProfileService = UserProfileService;
exports.UserProfileService = UserProfileService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(user_entity_1.User)),
    __param(1, (0, typeorm_1.InjectRepository)(user_profile_entity_1.UserProfile)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object])
], UserProfileService);


/***/ }),
/* 43 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(44), exports);
__exportStar(__webpack_require__(45), exports);
__exportStar(__webpack_require__(46), exports);
__exportStar(__webpack_require__(47), exports);
__exportStar(__webpack_require__(48), exports);


/***/ }),
/* 44 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateUserProfileDto = void 0;
const swagger_1 = __webpack_require__(3);
const class_validator_1 = __webpack_require__(19);
class UpdateUserProfileDto {
}
exports.UpdateUserProfileDto = UpdateUserProfileDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User first name',
        required: false,
        example: 'John',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateUserProfileDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User last name',
        required: false,
        example: 'Doe',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateUserProfileDto.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User email address',
        required: false,
        example: 'john.doe@example.com',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEmail)(),
    __metadata("design:type", String)
], UpdateUserProfileDto.prototype, "email", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User phone number',
        required: false,
        example: '+1234567890',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateUserProfileDto.prototype, "phoneNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User country code',
        required: false,
        example: '+1',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateUserProfileDto.prototype, "countryCode", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User profile image URL',
        required: false,
        example: 'https://example.com/profile.jpg',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateUserProfileDto.prototype, "profileImageUrl", void 0);


/***/ }),
/* 45 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateUserPreferencesDto = void 0;
const swagger_1 = __webpack_require__(3);
const class_validator_1 = __webpack_require__(19);
class UpdateUserPreferencesDto {
}
exports.UpdateUserPreferencesDto = UpdateUserPreferencesDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User preferred language',
        required: false,
        example: 'English',
        enum: ['English', 'Spanish', 'French', 'German'],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateUserPreferencesDto.prototype, "language", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User preferred currency',
        required: false,
        example: 'USD ($)',
        enum: ['USD ($)', 'EUR (â‚¬)', 'GBP (Â£)', 'JPY (Â¥)'],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateUserPreferencesDto.prototype, "currency", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User preferred theme',
        required: false,
        example: 'light',
        enum: ['light', 'dark', 'system'],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateUserPreferencesDto.prototype, "theme", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User notification preferences',
        required: false,
        example: true,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateUserPreferencesDto.prototype, "notifications", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User date of birth',
        required: false,
        example: '1990-01-15',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], UpdateUserPreferencesDto.prototype, "dateOfBirth", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User nationality',
        required: false,
        example: 'United States',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateUserPreferencesDto.prototype, "nationality", void 0);


/***/ }),
/* 46 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangePasswordDto = void 0;
const swagger_1 = __webpack_require__(3);
const class_validator_1 = __webpack_require__(19);
class ChangePasswordDto {
}
exports.ChangePasswordDto = ChangePasswordDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Current password',
        example: 'currentPassword123',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ChangePasswordDto.prototype, "currentPassword", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'New password (minimum 8 characters)',
        example: 'newPassword123',
        minLength: 8,
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MinLength)(8),
    __metadata("design:type", String)
], ChangePasswordDto.prototype, "newPassword", void 0);


/***/ }),
/* 47 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteAccountDto = void 0;
const swagger_1 = __webpack_require__(3);
const class_validator_1 = __webpack_require__(19);
class DeleteAccountDto {
}
exports.DeleteAccountDto = DeleteAccountDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User password for confirmation',
        example: 'userPassword123',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], DeleteAccountDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Reason for account deletion (optional)',
        example: 'No longer using the service',
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DeleteAccountDto.prototype, "reason", void 0);


/***/ }),
/* 48 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrivacySettingsDto = void 0;
const swagger_1 = __webpack_require__(3);
const class_validator_1 = __webpack_require__(19);
class PrivacySettingsDto {
}
exports.PrivacySettingsDto = PrivacySettingsDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Allow data sharing with third parties',
        example: false,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], PrivacySettingsDto.prototype, "dataSharing", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Receive marketing emails',
        example: true,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], PrivacySettingsDto.prototype, "marketingEmails", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Receive SMS notifications',
        example: true,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], PrivacySettingsDto.prototype, "smsNotifications", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Receive push notifications',
        example: true,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], PrivacySettingsDto.prototype, "pushNotifications", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Profile visibility to other users',
        example: false,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], PrivacySettingsDto.prototype, "profileVisible", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Allow location tracking',
        example: true,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], PrivacySettingsDto.prototype, "locationTracking", void 0);


/***/ }),
/* 49 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CharterDealsModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const charter_deals_controller_1 = __webpack_require__(50);
const charter_deals_service_1 = __webpack_require__(51);
const charter_deal_entity_1 = __webpack_require__(30);
const charters_company_entity_1 = __webpack_require__(31);
const aircraft_entity_1 = __webpack_require__(35);
const aircraft_type_image_placeholder_entity_1 = __webpack_require__(40);
const amenities_module_1 = __webpack_require__(56);
const google_earth_engine_module_1 = __webpack_require__(63);
let CharterDealsModule = class CharterDealsModule {
};
exports.CharterDealsModule = CharterDealsModule;
exports.CharterDealsModule = CharterDealsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([
                charter_deal_entity_1.CharterDeal,
                charters_company_entity_1.ChartersCompany,
                aircraft_entity_1.Aircraft,
                aircraft_type_image_placeholder_entity_1.AircraftTypeImagePlaceholder,
            ]),
            amenities_module_1.AmenitiesModule,
            google_earth_engine_module_1.GoogleEarthEngineModule,
        ],
        controllers: [charter_deals_controller_1.CharterDealsController],
        providers: [charter_deals_service_1.CharterDealsService],
        exports: [charter_deals_service_1.CharterDealsService],
    })
], CharterDealsModule);


/***/ }),
/* 50 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CharterDealsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const charter_deals_service_1 = __webpack_require__(51);
const jwt_auth_guard_1 = __webpack_require__(16);
let CharterDealsController = class CharterDealsController {
    constructor(charterDealsService) {
        this.charterDealsService = charterDealsService;
    }
    async getCharterDeals(page = '1', limit = '10', search, dealType, fromDate, toDate, aircraftTypeImagePlaceholderId, origin, destination, userLat, userLng, groupBy) {
        const pageNum = parseInt(page, 10);
        const limitNum = parseInt(limit, 10);
        const fromDateObj = fromDate ? new Date(fromDate) : undefined;
        const toDateObj = toDate ? new Date(toDate) : undefined;
        const hasEnhancedFilters = aircraftTypeImagePlaceholderId || origin || destination || userLat || userLng || groupBy;
        if (hasEnhancedFilters) {
            const filters = {
                page: pageNum,
                limit: limitNum,
                search,
                dealType,
                fromDate,
                toDate,
                aircraftTypeImagePlaceholderId: aircraftTypeImagePlaceholderId ? parseInt(aircraftTypeImagePlaceholderId) : undefined,
                origin,
                destination,
                userLat: userLat ? parseFloat(userLat) : undefined,
                userLng: userLng ? parseFloat(userLng) : undefined,
                groupBy: groupBy === 'true',
            };
            return await this.charterDealsService.findAllWithEnhancedFilters(filters);
        }
        else {
            const result = await this.charterDealsService.findAllWithRelations(pageNum, limitNum, search, dealType, fromDateObj, toDateObj);
            return {
                success: true,
                data: result.deals,
                total: result.total,
                page: pageNum,
                limit: limitNum,
            };
        }
    }
    async getCharterDealById(id) {
        const dealId = parseInt(id, 10);
        const deal = await this.charterDealsService.findById(dealId);
        if (!deal) {
            return {
                success: false,
                message: 'Deal not found',
            };
        }
        return {
            success: true,
            data: deal,
        };
    }
    async getCharterDealsByCompany(companyId, page = '1', limit = '10') {
        const companyIdNum = parseInt(companyId, 10);
        const pageNum = parseInt(page, 10);
        const limitNum = parseInt(limit, 10);
        const result = await this.charterDealsService.findByCompany(companyIdNum, pageNum, limitNum);
        return {
            success: true,
            data: result.deals,
            total: result.total,
            page: pageNum,
            limit: limitNum,
        };
    }
    async debugDatabase() {
        return await this.charterDealsService.debugDatabaseConnection();
    }
    async getCharterDealsByRoute(origin, destination, page = '1', limit = '10', fromDate, toDate) {
        const pageNum = parseInt(page, 10);
        const limitNum = parseInt(limit, 10);
        const fromDateObj = fromDate ? new Date(fromDate) : undefined;
        const toDateObj = toDate ? new Date(toDate) : undefined;
        const result = await this.charterDealsService.findByRoute(origin, destination, pageNum, limitNum, fromDateObj, toDateObj);
        return {
            success: true,
            data: result.deals,
            total: result.total,
            page: pageNum,
            limit: limitNum,
        };
    }
};
exports.CharterDealsController = CharterDealsController;
__decorate([
    (0, common_1.Get)(),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiOperation)({ summary: 'Get all charter deals with filters' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Returns paginated charter deals with related data',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'number' },
                            companyId: { type: 'number' },
                            fixedRouteId: { type: 'number' },
                            aircraftId: { type: 'number' },
                            date: { type: 'string', format: 'date' },
                            time: { type: 'string' },
                            pricePerSeat: { type: 'number', nullable: true },
                            discountPerSeat: { type: 'number' },
                            pricePerHour: { type: 'number', nullable: true },
                            availableSeats: { type: 'number' },
                            dealType: { type: 'string' },
                            createdAt: { type: 'string', format: 'date-time' },
                            updatedAt: { type: 'string', format: 'date-time' },
                            companyName: { type: 'string' },
                            companyLogo: { type: 'string', nullable: true },
                            origin: { type: 'string' },
                            destination: { type: 'string' },
                            routeImageUrl: { type: 'string' },
                            aircraftName: { type: 'string' },
                            aircraftType: { type: 'string' },
                            aircraftCapacity: { type: 'number' },
                            aircraftImages: { type: 'array', items: { type: 'string' } },
                            routeImages: { type: 'array', items: { type: 'string' } },
                            duration: { type: 'string' },
                            amenities: { type: 'array', items: { type: 'object' } },
                        },
                    },
                },
                total: { type: 'number' },
                page: { type: 'number' },
                limit: { type: 'number' },
            },
        },
    }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, type: Number, description: 'Page number (default: 1)' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Items per page (default: 10)' }),
    (0, swagger_1.ApiQuery)({ name: 'search', required: false, type: String, description: 'Search query for company, route, or aircraft' }),
    (0, swagger_1.ApiQuery)({ name: 'dealType', required: false, enum: ['privateCharter', 'jetSharing'], description: 'Filter by deal type' }),
    (0, swagger_1.ApiQuery)({ name: 'fromDate', required: false, type: String, description: 'Filter deals from this date (YYYY-MM-DD)' }),
    (0, swagger_1.ApiQuery)({ name: 'toDate', required: false, type: String, description: 'Filter deals to this date (YYYY-MM-DD)' }),
    (0, swagger_1.ApiQuery)({ name: 'aircraftTypeImagePlaceholderId', required: false, type: Number, description: 'Filter by aircraft type image placeholder ID' }),
    (0, swagger_1.ApiQuery)({ name: 'origin', required: false, type: String, description: 'Filter by route origin' }),
    (0, swagger_1.ApiQuery)({ name: 'destination', required: false, type: String, description: 'Filter by route destination' }),
    (0, swagger_1.ApiQuery)({ name: 'userLat', required: false, type: Number, description: 'User latitude for proximity sorting' }),
    (0, swagger_1.ApiQuery)({ name: 'userLng', required: false, type: Number, description: 'User longitude for proximity sorting' }),
    (0, swagger_1.ApiQuery)({ name: 'groupBy', required: false, type: Boolean, description: 'Group by aircraft type and route' }),
    __param(0, (0, common_1.Query)('page')),
    __param(1, (0, common_1.Query)('limit')),
    __param(2, (0, common_1.Query)('search')),
    __param(3, (0, common_1.Query)('dealType')),
    __param(4, (0, common_1.Query)('fromDate')),
    __param(5, (0, common_1.Query)('toDate')),
    __param(6, (0, common_1.Query)('aircraftTypeImagePlaceholderId')),
    __param(7, (0, common_1.Query)('origin')),
    __param(8, (0, common_1.Query)('destination')),
    __param(9, (0, common_1.Query)('userLat')),
    __param(10, (0, common_1.Query)('userLng')),
    __param(11, (0, common_1.Query)('groupBy')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, String, String, String, String, String, String, String, String, String]),
    __metadata("design:returntype", Promise)
], CharterDealsController.prototype, "getCharterDeals", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiOperation)({ summary: 'Get charter deal by ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Returns charter deal details',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                data: {
                    type: 'object',
                    properties: {
                        id: { type: 'number' },
                        companyId: { type: 'number' },
                        fixedRouteId: { type: 'number' },
                        aircraftId: { type: 'number' },
                        date: { type: 'string', format: 'date' },
                        time: { type: 'string' },
                        pricePerSeat: { type: 'number', nullable: true },
                        discountPerSeat: { type: 'number' },
                        pricePerHour: { type: 'number', nullable: true },
                        discountPerHour: { type: 'number' },
                        availableSeats: { type: 'number' },
                        dealType: { type: 'string' },
                        createdAt: { type: 'string', format: 'date-time' },
                        updatedAt: { type: 'string', format: 'date-time' },
                        companyName: { type: 'string' },
                        companyLogo: { type: 'string', nullable: true },
                        origin: { type: 'string' },
                        destination: { type: 'string' },
                        routeImageUrl: { type: 'string' },
                        aircraftName: { type: 'string' },
                        aircraftType: { type: 'string' },
                        aircraftCapacity: { type: 'number' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Deal not found' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: Number, description: 'Charter deal ID' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], CharterDealsController.prototype, "getCharterDealById", null);
__decorate([
    (0, common_1.Get)('company/:companyId'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiOperation)({ summary: 'Get charter deals by company ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Returns paginated charter deals for a specific company',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'number' },
                            companyId: { type: 'number' },
                            fixedRouteId: { type: 'number' },
                            aircraftId: { type: 'number' },
                            date: { type: 'string', format: 'date' },
                            time: { type: 'string' },
                            pricePerSeat: { type: 'number', nullable: true },
                            discountPerSeat: { type: 'number' },
                            pricePerHour: { type: 'number', nullable: true },
                            discountPerHour: { type: 'number' },
                            availableSeats: { type: 'number' },
                            dealType: { type: 'string' },
                            createdAt: { type: 'string', format: 'date-time' },
                            updatedAt: { type: 'string', format: 'date-time' },
                            companyName: { type: 'string' },
                            companyLogo: { type: 'string', nullable: true },
                            origin: { type: 'string' },
                            destination: { type: 'string' },
                            routeImageUrl: { type: 'string' },
                            aircraftName: { type: 'string' },
                            aircraftType: { type: 'string' },
                            aircraftCapacity: { type: 'number' },
                        },
                    },
                },
                total: { type: 'number' },
                page: { type: 'number' },
                limit: { type: 'number' },
            },
        },
    }),
    (0, swagger_1.ApiParam)({ name: 'companyId', type: Number, description: 'Company ID' }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, type: Number, description: 'Page number (default: 1)' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Items per page (default: 10)' }),
    __param(0, (0, common_1.Param)('companyId')),
    __param(1, (0, common_1.Query)('page')),
    __param(2, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], CharterDealsController.prototype, "getCharterDealsByCompany", null);
__decorate([
    (0, common_1.Get)('debug/database'),
    (0, swagger_1.ApiOperation)({ summary: 'Debug database connection and data' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Returns database debug information',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CharterDealsController.prototype, "debugDatabase", null);
__decorate([
    (0, common_1.Get)('route/:origin/:destination'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiOperation)({ summary: 'Get charter deals by route' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Returns paginated charter deals for a specific route',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'number' },
                            companyId: { type: 'number' },
                            fixedRouteId: { type: 'number' },
                            aircraftId: { type: 'number' },
                            date: { type: 'string', format: 'date' },
                            time: { type: 'string' },
                            pricePerSeat: { type: 'number', nullable: true },
                            discountPerSeat: { type: 'number' },
                            priceFullCharter: { type: 'number', nullable: true },
                            availableSeats: { type: 'number' },
                            dealType: { type: 'string' },
                            createdAt: { type: 'string', format: 'date-time' },
                            updatedAt: { type: 'string', format: 'date-time' },
                            companyName: { type: 'string' },
                            companyLogo: { type: 'string', nullable: true },
                            origin: { type: 'string' },
                            destination: { type: 'string' },
                            routeImageUrl: { type: 'string' },
                            aircraftName: { type: 'string' },
                            aircraftType: { type: 'string' },
                            aircraftCapacity: { type: 'number' },
                        },
                    },
                },
                total: { type: 'number' },
                page: { type: 'number' },
                limit: { type: 'number' },
            },
        },
    }),
    (0, swagger_1.ApiParam)({ name: 'origin', type: String, description: 'Origin city' }),
    (0, swagger_1.ApiParam)({ name: 'destination', type: String, description: 'Destination city' }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, type: Number, description: 'Page number (default: 1)' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Items per page (default: 10)' }),
    (0, swagger_1.ApiQuery)({ name: 'fromDate', required: false, type: String, description: 'Filter deals from this date (YYYY-MM-DD)' }),
    (0, swagger_1.ApiQuery)({ name: 'toDate', required: false, type: String, description: 'Filter deals to this date (YYYY-MM-DD)' }),
    __param(0, (0, common_1.Param)('origin')),
    __param(1, (0, common_1.Param)('destination')),
    __param(2, (0, common_1.Query)('page')),
    __param(3, (0, common_1.Query)('limit')),
    __param(4, (0, common_1.Query)('fromDate')),
    __param(5, (0, common_1.Query)('toDate')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, String, String, String]),
    __metadata("design:returntype", Promise)
], CharterDealsController.prototype, "getCharterDealsByRoute", null);
exports.CharterDealsController = CharterDealsController = __decorate([
    (0, swagger_1.ApiTags)('Charter Deals'),
    (0, common_1.Controller)('charter-deals'),
    __metadata("design:paramtypes", [typeof (_a = typeof charter_deals_service_1.CharterDealsService !== "undefined" && charter_deals_service_1.CharterDealsService) === "function" ? _a : Object])
], CharterDealsController);


/***/ }),
/* 51 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CharterDealsService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const charter_deal_entity_1 = __webpack_require__(30);
const charters_company_entity_1 = __webpack_require__(31);
const aircraft_entity_1 = __webpack_require__(35);
const aircraft_type_image_placeholder_entity_1 = __webpack_require__(40);
const amenities_service_1 = __webpack_require__(52);
const google_earth_engine_service_1 = __webpack_require__(53);
let CharterDealsService = class CharterDealsService {
    constructor(charterDealRepository, companyRepository, aircraftRepository, aircraftTypeImagePlaceholderRepository, amenitiesService, googleEarthEngineService) {
        this.charterDealRepository = charterDealRepository;
        this.companyRepository = companyRepository;
        this.aircraftRepository = aircraftRepository;
        this.aircraftTypeImagePlaceholderRepository = aircraftTypeImagePlaceholderRepository;
        this.amenitiesService = amenitiesService;
        this.googleEarthEngineService = googleEarthEngineService;
    }
    async findAllWithRelations(page = 1, limit = 10, searchQuery, dealType, fromDate, toDate) {
        const offset = (page - 1) * limit;
        let query = this.charterDealRepository
            .createQueryBuilder('deal')
            .leftJoinAndSelect('deal.company', 'company')
            .leftJoinAndSelect('deal.aircraft', 'aircraft')
            .leftJoin('aircraft_images', 'images', 'images.aircraftId = aircraft.id')
            .where('company.status = :status', { status: 'active' })
            .andWhere('aircraft.isAvailable = :isAvailable', { isAvailable: true })
            .andWhere('aircraft.maintenanceStatus = :maintenanceStatus', { maintenanceStatus: 'operational' });
        if (searchQuery) {
            query = query.andWhere('(company.companyName LIKE :search OR deal.originName as deal_originName LIKE :search OR deal.destinationName as deal_destinationName LIKE :search OR aircraft.name LIKE :search)', { search: `%${searchQuery}%` });
        }
        if (fromDate) {
            query = query.andWhere('deal.date >= :fromDate', { fromDate });
        }
        if (toDate) {
            query = query.andWhere('deal.date <= :toDate', { toDate });
        }
        const total = await query.getCount();
        const deals = await query
            .select([
            'deal.id',
            'deal.companyId',
            'deal.aircraftId',
            'deal.date',
            'deal.time',
            'deal.pricePerSeat',
            'deal.discountPerSeat',
            'deal.availableSeats',
            'deal.createdAt',
            'deal.updatedAt',
            'company.companyName',
            'company.logo',
            'deal.originName as deal_originName',
            'deal.destinationName as deal_destinationName',
            'aircraft.name',
            'aircraft.type',
            'aircraft.capacity',
            'GROUP_CONCAT(images.url) as aircraftImages',
        ])
            .groupBy('deal.id')
            .orderBy('deal.date', 'ASC')
            .addOrderBy('deal.time', 'ASC')
            .offset(offset)
            .limit(limit)
            .getRawMany();
        const transformedDeals = await Promise.all(deals.map(async (deal) => ({
            id: deal.deal_id,
            companyId: deal.deal_companyId,
            aircraftId: deal.deal_aircraftId,
            date: deal.deal_date,
            time: deal.deal_time,
            pricePerSeat: deal.deal_pricePerSeat,
            discountPerSeat: deal.deal_discountPerSeat,
            availableSeats: deal.deal_availableSeats,
            createdAt: deal.deal_createdAt,
            updatedAt: deal.deal_updatedAt,
            companyName: deal.company_companyName,
            companyLogo: deal.company_logo,
            originName: deal.deal_originName,
            destinationName: deal.deal_destinationName,
            routeImageUrl: "",
            aircraftName: deal.aircraft_name,
            aircraftType: deal.aircraft_type,
            aircraftCapacity: deal.aircraft_capacity,
            aircraftImages: deal.aircraftImages ? deal.aircraftImages.split(',') : [],
            routeImages: [],
            duration: await this.calculateDuration(deal.deal_originName, deal.deal_destinationName, deal.aircraft_type),
            amenities: await this.getAircraftAmenities(deal.aircraft_id),
        })));
        return { deals: transformedDeals, total };
    }
    async findById(id) {
        const deal = await this.charterDealRepository
            .createQueryBuilder('deal')
            .leftJoinAndSelect('deal.company', 'company')
            .leftJoinAndSelect('deal.aircraft', 'aircraft')
            .leftJoin('aircraft_images', 'images', 'images.aircraftId = aircraft.id')
            .where('deal.id = :id', { id })
            .select([
            'deal.id',
            'deal.companyId',
            'deal.aircraftId',
            'deal.date',
            'deal.time',
            'deal.pricePerSeat',
            'deal.discountPerSeat',
            'deal.availableSeats',
            'deal.createdAt',
            'deal.updatedAt',
            'company.companyName',
            'company.logo',
            'deal.originName as deal_originName',
            'deal.destinationName as deal_destinationName',
            'aircraft.name',
            'aircraft.type',
            'aircraft.capacity',
            'GROUP_CONCAT(images.url) as aircraftImages',
        ])
            .groupBy('deal.id')
            .getRawOne();
        if (!deal)
            return null;
        return {
            id: deal.deal_id,
            companyId: deal.deal_companyId,
            aircraftId: deal.deal_aircraftId,
            date: deal.deal_date,
            time: deal.deal_time,
            pricePerSeat: deal.deal_pricePerSeat,
            discountPerSeat: deal.deal_discountPerSeat,
            availableSeats: deal.deal_availableSeats,
            createdAt: deal.deal_createdAt,
            updatedAt: deal.deal_updatedAt,
            companyName: deal.company_companyName,
            companyLogo: deal.company_logo,
            originName: deal.deal_originName,
            destinationName: deal.deal_destinationName,
            routeImageUrl: "",
            aircraftName: deal.aircraft_name,
            aircraftType: deal.aircraft_type,
            aircraftCapacity: deal.aircraft_capacity,
            aircraftImages: deal.aircraftImages ? deal.aircraftImages.split(',') : [],
            routeImages: [],
            duration: await this.calculateDuration(deal.deal_originName, deal.deal_destinationName),
            amenities: await this.getAircraftAmenities(deal.aircraft_id),
        };
    }
    async findByCompany(companyId, page = 1, limit = 10) {
        const offset = (page - 1) * limit;
        let query = this.charterDealRepository
            .createQueryBuilder('deal')
            .leftJoinAndSelect('deal.company', 'company')
            .leftJoinAndSelect('deal.aircraft', 'aircraft')
            .leftJoin('aircraft_images', 'images', 'images.aircraftId = aircraft.id')
            .where('deal.companyId = :companyId', { companyId });
        const total = await query.getCount();
        const deals = await query
            .select([
            'deal.id',
            'deal.companyId',
            'deal.aircraftId',
            'deal.date',
            'deal.time',
            'deal.pricePerSeat',
            'deal.discountPerSeat',
            'deal.availableSeats',
            'deal.createdAt',
            'deal.updatedAt',
            'company.companyName',
            'company.logo',
            'deal.originName as deal_originName',
            'deal.destinationName as deal_destinationName',
            'aircraft.name',
            'aircraft.type',
            'aircraft.capacity',
            'GROUP_CONCAT(images.url) as aircraftImages',
        ])
            .groupBy('deal.id')
            .orderBy('deal.date', 'ASC')
            .addOrderBy('deal.time', 'ASC')
            .offset(offset)
            .limit(limit)
            .getRawMany();
        const transformedDeals = await Promise.all(deals.map(async (deal) => ({
            id: deal.deal_id,
            companyId: deal.deal_companyId,
            aircraftId: deal.deal_aircraftId,
            date: deal.deal_date,
            time: deal.deal_time,
            pricePerSeat: deal.deal_pricePerSeat,
            discountPerSeat: deal.deal_discountPerSeat,
            availableSeats: deal.deal_availableSeats,
            createdAt: deal.deal_createdAt,
            updatedAt: deal.deal_updatedAt,
            companyName: deal.company_companyName,
            companyLogo: deal.company_logo,
            originName: deal.deal_originName,
            destinationName: deal.deal_destinationName,
            routeImageUrl: "",
            aircraftName: deal.aircraft_name,
            aircraftType: deal.aircraft_type,
            aircraftCapacity: deal.aircraft_capacity,
            aircraftImages: deal.aircraftImages ? deal.aircraftImages.split(',') : [],
            routeImages: [],
            duration: await this.calculateDuration(deal.deal_originName, deal.deal_destinationName),
            amenities: await this.getAircraftAmenities(deal.aircraft_id),
        })));
        return { deals: transformedDeals, total };
    }
    async findByRoute(origin, destination, page = 1, limit = 10, fromDate, toDate) {
        const offset = (page - 1) * limit;
        let query = this.charterDealRepository
            .createQueryBuilder('deal')
            .leftJoinAndSelect('deal.company', 'company')
            .leftJoinAndSelect('deal.aircraft', 'aircraft')
            .leftJoin('aircraft_images', 'images', 'images.aircraftId = aircraft.id')
            .where('company.status = :status', { status: 'active' })
            .andWhere('aircraft.isAvailable = :isAvailable', { isAvailable: true })
            .andWhere('aircraft.maintenanceStatus = :maintenanceStatus', { maintenanceStatus: 'operational' })
            .andWhere('deal.originName as deal_originName = :origin', { origin })
            .andWhere('deal.destinationName as deal_destinationName = :destination', { destination });
        if (fromDate) {
            query = query.andWhere('deal.date >= :fromDate', { fromDate });
        }
        if (toDate) {
            query = query.andWhere('deal.date <= :toDate', { toDate });
        }
        const total = await query.getCount();
        const deals = await query
            .select([
            'deal.id',
            'deal.companyId',
            'deal.aircraftId',
            'deal.date',
            'deal.time',
            'deal.pricePerSeat',
            'deal.discountPerSeat',
            'deal.availableSeats',
            'deal.createdAt',
            'deal.updatedAt',
            'company.companyName',
            'company.logo',
            'deal.originName as deal_originName',
            'deal.destinationName as deal_destinationName',
            'aircraft.name',
            'aircraft.type',
            'aircraft.capacity',
            'GROUP_CONCAT(images.url) as aircraftImages',
        ])
            .groupBy('deal.id')
            .orderBy('deal.date', 'ASC')
            .addOrderBy('deal.time', 'ASC')
            .offset(offset)
            .limit(limit)
            .getRawMany();
        const transformedDeals = await Promise.all(deals.map(async (deal) => ({
            id: deal.deal_id,
            companyId: deal.deal_companyId,
            aircraftId: deal.deal_aircraftId,
            date: deal.deal_date,
            time: deal.deal_time,
            pricePerSeat: deal.deal_pricePerSeat,
            discountPerSeat: deal.deal_discountPerSeat,
            availableSeats: deal.deal_availableSeats,
            createdAt: deal.deal_createdAt,
            updatedAt: deal.deal_updatedAt,
            companyName: deal.company_companyName,
            companyLogo: deal.company_logo,
            originName: deal.deal_originName,
            destinationName: deal.deal_destinationName,
            routeImageUrl: "",
            aircraftName: deal.aircraft_name,
            aircraftType: deal.aircraft_type,
            aircraftCapacity: deal.aircraft_capacity,
            aircraftImages: deal.aircraftImages ? deal.aircraftImages.split(',') : [],
            routeImages: [],
            duration: await this.calculateDuration(deal.deal_originName, deal.deal_destinationName),
            amenities: await this.getAircraftAmenities(deal.aircraft_id),
        })));
        return { deals: transformedDeals, total };
    }
    async calculateDuration(origin, destination, aircraftType) {
        if (!origin || !destination)
            return '';
        try {
            const originLocation = await this.getLocationCoordinates(origin);
            const destinationLocation = await this.getLocationCoordinates(destination);
            if (!originLocation || !destinationLocation) {
                return this.getEstimatedDuration(aircraftType);
            }
            const distance = this.googleEarthEngineService.calculateFlightDistance(originLocation.lat, originLocation.lng, destinationLocation.lat, destinationLocation.lng);
            const durationInSeconds = this.googleEarthEngineService.estimateFlightDuration(distance, aircraftType);
            const hours = Math.floor(durationInSeconds / 3600);
            const minutes = Math.floor((durationInSeconds % 3600) / 60);
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            }
            else {
                return `${minutes}m`;
            }
        }
        catch (error) {
            console.error('Error calculating flight duration:', error);
            return this.getEstimatedDuration(aircraftType);
        }
    }
    getEstimatedDuration(aircraftType) {
        switch (aircraftType?.toLowerCase()) {
            case 'jet':
                return '1h 30m';
            case 'turboprop':
                return '2h 15m';
            case 'helicopter':
                return '45m';
            case 'propeller':
                return '2h 30m';
            default:
                return '1h 45m';
        }
    }
    async getLocationCoordinates(locationName) {
        try {
            const searchResults = await this.googleEarthEngineService.searchLocations({
                query: locationName,
                type: 'airport',
            });
            if (searchResults.length > 0) {
                return searchResults[0].location;
            }
            const broaderResults = await this.googleEarthEngineService.searchLocations({
                query: locationName,
            });
            if (broaderResults.length > 0) {
                return broaderResults[0].location;
            }
            return null;
        }
        catch (error) {
            console.error(`Error getting coordinates for ${locationName}:`, error);
            return null;
        }
    }
    async getAircraftAmenities(aircraftId) {
        try {
            const amenities = await this.amenitiesService.getAircraftAmenities(aircraftId);
            const uniqueAmenities = amenities.filter((amenity, index, self) => index === self.findIndex(a => a.name === amenity.name));
            return uniqueAmenities.map(amenity => ({
                icon: 'star',
                name: amenity.name
            }));
        }
        catch (error) {
            console.error('Error fetching aircraft amenities:', error);
            return [];
        }
    }
    async findAllWithEnhancedFilters(filters) {
        const { page = 1, limit = 10, search, dealType, fromDate, toDate, aircraftTypeImagePlaceholderId, origin, destination, userLat, userLng, groupBy = false, } = filters;
        const offset = (page - 1) * limit;
        let query = this.charterDealRepository
            .createQueryBuilder('deal')
            .leftJoinAndSelect('deal.company', 'company')
            .leftJoinAndSelect('deal.aircraft', 'aircraft')
            .leftJoinAndSelect('aircraft.aircraftTypeImagePlaceholder', 'aircraftType')
            .leftJoin('aircraft_images', 'images', 'images.aircraftId = aircraft.id')
            .where('company.status = :status', { status: 'active' })
            .andWhere('aircraft.isAvailable = :isAvailable', { isAvailable: true })
            .andWhere('aircraft.maintenanceStatus = :maintenanceStatus', { maintenanceStatus: 'operational' });
        if (search) {
            query = query.andWhere('(company.companyName LIKE :search OR deal.originName as deal_originName LIKE :search OR deal.destinationName as deal_destinationName LIKE :search OR aircraft.name LIKE :search)', { search: `%${search}%` });
        }
        if (fromDate) {
            query = query.andWhere('deal.date >= :fromDate', { fromDate: new Date(fromDate) });
        }
        if (toDate) {
            query = query.andWhere('deal.date <= :toDate', { toDate: new Date(toDate) });
        }
        if (aircraftTypeImagePlaceholderId) {
            query = query.andWhere('aircraft.aircraftTypeImagePlaceholderId = :aircraftTypeId', { aircraftTypeId: aircraftTypeImagePlaceholderId });
        }
        if (origin) {
            query = query.andWhere('deal.originName as deal_originName LIKE :origin', { origin: `%${origin}%` });
        }
        if (destination) {
            query = query.andWhere('deal.destinationName as deal_destinationName LIKE :destination', { destination: `%${destination}%` });
        }
        const total = await query.getCount();
        query = query
            .select([
            'deal.id',
            'deal.companyId',
            'deal.aircraftId',
            'deal.date',
            'deal.time',
            'deal.pricePerSeat',
            'deal.discountPerSeat',
            'deal.availableSeats',
            'deal.createdAt',
            'deal.updatedAt',
            'company.companyName',
            'company.logo',
            'deal.originName as deal_originName',
            'deal.destinationName as deal_destinationName',
            'aircraft.name',
            'aircraft.type',
            'aircraft.capacity',
            'aircraft.aircraftTypeImagePlaceholderId',
            'aircraftType.placeholderImageUrl',
            'GROUP_CONCAT(images.url) as aircraftImages',
        ])
            .groupBy('deal.id')
            .orderBy('deal.date', 'ASC')
            .addOrderBy('deal.time', 'ASC')
            .offset(offset)
            .limit(limit);
        const deals = await query.getRawMany();
        if (groupBy) {
            return this.groupDealsByAircraftTypeAndRoute(deals, userLat, userLng, total, page, limit);
        }
        else {
            const transformedDeals = await Promise.all(deals.map(async (deal) => ({
                id: deal.deal_id,
                companyId: deal.deal_companyId,
                aircraftId: deal.deal_aircraftId,
                date: deal.deal_date,
                time: deal.deal_time,
                pricePerSeat: deal.deal_pricePerSeat,
                discountPerSeat: deal.deal_discountPerSeat,
                availableSeats: deal.deal_availableSeats,
                createdAt: deal.deal_createdAt,
                updatedAt: deal.deal_updatedAt,
                companyName: deal.company_companyName,
                companyLogo: deal.company_logo,
                originName: deal.deal_originName,
                destinationName: deal.deal_destinationName,
                routeImageUrl: "",
                aircraftName: deal.aircraft_name,
                aircraftType: deal.aircraft_type,
                aircraftCapacity: deal.aircraft_capacity,
                aircraftImages: deal.aircraftImages ? deal.aircraftImages.split(',') : [],
                routeImages: [],
                duration: await this.calculateDuration(deal.deal_originName, deal.deal_destinationName, deal.aircraft_type),
                amenities: await this.getAircraftAmenities(deal.deal_aircraftId),
            })));
            return {
                success: true,
                data: transformedDeals,
                total,
                page,
                limit,
                totalGroups: 1,
            };
        }
    }
    async groupDealsByAircraftTypeAndRoute(deals, userLat, userLng, total = 0, page = 1, limit = 10) {
        const groupedMap = new Map();
        for (const deal of deals) {
            const aircraftTypeId = deal.aircraft_aircraftTypeImagePlaceholderId || 0;
            const routeKey = `${deal.deal_originName}-${deal.deal_destinationName}`;
            const groupKey = `${aircraftTypeId}-${routeKey}`;
            if (!groupedMap.has(groupKey)) {
                groupedMap.set(groupKey, []);
            }
            groupedMap.get(groupKey).push(deal);
        }
        const groupedDeals = [];
        for (const [groupKey, groupDeals] of groupedMap) {
            if (groupDeals.length === 0)
                continue;
            const firstDeal = groupDeals[0];
            const aircraftTypeId = firstDeal.aircraft_aircraftTypeImagePlaceholderId || 0;
            const aircraftType = firstDeal.aircraft_type || 'unknown';
            const aircraftTypeImageUrl = firstDeal.aircraftType_placeholderImageUrl || '';
            let distanceFromUser;
            if (userLat && userLng && firstDeal.deal_originName) {
                try {
                    const originLocation = await this.getLocationCoordinates(firstDeal.deal_originName);
                    if (originLocation) {
                        distanceFromUser = this.googleEarthEngineService.calculateFlightDistance(userLat, userLng, originLocation.lat, originLocation.lng);
                    }
                }
                catch (error) {
                    console.error('Error calculating distance from user:', error);
                }
            }
            const transformedDeals = await Promise.all(groupDeals.map(async (deal) => ({
                id: deal.deal_id,
                companyId: deal.deal_companyId,
                aircraftId: deal.deal_aircraftId,
                date: deal.deal_date,
                time: deal.deal_time,
                pricePerSeat: deal.deal_pricePerSeat,
                discountPerSeat: deal.deal_discountPerSeat,
                availableSeats: deal.deal_availableSeats,
                createdAt: deal.deal_createdAt,
                updatedAt: deal.deal_updatedAt,
                companyName: deal.company_companyName,
                companyLogo: deal.company_logo,
                originName: deal.deal_originName,
                destinationName: deal.deal_destinationName,
                routeImageUrl: "",
                aircraftName: deal.aircraft_name,
                aircraftType: deal.aircraft_type,
                aircraftCapacity: deal.aircraft_capacity,
                aircraftImages: deal.aircraftImages ? deal.aircraftImages.split(',') : [],
                routeImages: [],
                duration: await this.calculateDuration(deal.deal_originName, deal.deal_destinationName, deal.aircraft_type),
                amenities: await this.getAircraftAmenities(deal.deal_aircraftId),
            })));
            groupedDeals.push({
                aircraftTypeId,
                aircraftType,
                aircraftTypeImageUrl,
                route: {
                    origin: firstDeal.deal_originName || '',
                    destination: firstDeal.deal_destinationName || '',
                    distanceFromUser,
                },
                deals: transformedDeals,
            });
        }
        if (userLat && userLng) {
            groupedDeals.sort((a, b) => {
                const distanceA = a.route.distanceFromUser || Infinity;
                const distanceB = b.route.distanceFromUser || Infinity;
                return distanceA - distanceB;
            });
        }
        return {
            success: true,
            data: groupedDeals,
            total,
            page,
            limit,
            totalGroups: groupedDeals.length,
        };
    }
    async debugDatabaseConnection() {
        try {
            const dealsCount = await this.charterDealRepository.count();
            const companiesCount = await this.companyRepository.count();
            const aircraftCount = await this.aircraftRepository.count();
            const sampleDeal = await this.charterDealRepository
                .createQueryBuilder('deal')
                .select(['deal.id', 'deal.originName', 'deal.destinationName'])
                .limit(1)
                .getOne();
            const activeCompanies = await this.companyRepository
                .createQueryBuilder('company')
                .where('company.status = :status', { status: 'active' })
                .getCount();
            const availableAircraft = await this.aircraftRepository
                .createQueryBuilder('aircraft')
                .where('aircraft.isAvailable = :isAvailable', { isAvailable: true })
                .andWhere('aircraft.maintenanceStatus = :maintenanceStatus', { maintenanceStatus: 'operational' })
                .getCount();
            return {
                dealsCount,
                companiesCount,
                aircraftCount,
                activeCompanies,
                availableAircraft,
                sampleDeal,
                timestamp: new Date().toISOString()
            };
        }
        catch (error) {
            return {
                error: error.message,
                stack: error.stack,
                timestamp: new Date().toISOString()
            };
        }
    }
};
exports.CharterDealsService = CharterDealsService;
exports.CharterDealsService = CharterDealsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(charter_deal_entity_1.CharterDeal)),
    __param(1, (0, typeorm_1.InjectRepository)(charters_company_entity_1.ChartersCompany)),
    __param(2, (0, typeorm_1.InjectRepository)(aircraft_entity_1.Aircraft)),
    __param(3, (0, typeorm_1.InjectRepository)(aircraft_type_image_placeholder_entity_1.AircraftTypeImagePlaceholder)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object, typeof (_d = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _d : Object, typeof (_e = typeof amenities_service_1.AmenitiesService !== "undefined" && amenities_service_1.AmenitiesService) === "function" ? _e : Object, typeof (_f = typeof google_earth_engine_service_1.GoogleEarthEngineService !== "undefined" && google_earth_engine_service_1.GoogleEarthEngineService) === "function" ? _f : Object])
], CharterDealsService);


/***/ }),
/* 52 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AmenitiesService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const amenity_entity_1 = __webpack_require__(38);
const aircraft_amenity_entity_1 = __webpack_require__(37);
const charter_deal_amenity_entity_1 = __webpack_require__(39);
let AmenitiesService = class AmenitiesService {
    constructor(amenityRepository, aircraftAmenityRepository, charterDealAmenityRepository) {
        this.amenityRepository = amenityRepository;
        this.aircraftAmenityRepository = aircraftAmenityRepository;
        this.charterDealAmenityRepository = charterDealAmenityRepository;
    }
    async create(createAmenityDto) {
        const { name } = createAmenityDto;
        const existingAmenity = await this.amenityRepository.findOne({
            where: { name: name.trim() }
        });
        if (existingAmenity) {
            throw new common_1.ConflictException(`Amenity with name "${name}" already exists`);
        }
        const amenity = this.amenityRepository.create({
            name: name.trim()
        });
        return await this.amenityRepository.save(amenity);
    }
    async findAll() {
        return await this.amenityRepository.find({
            order: { name: 'ASC' }
        });
    }
    async findOne(id) {
        const amenity = await this.amenityRepository.findOne({
            where: { id }
        });
        if (!amenity) {
            throw new common_1.NotFoundException(`Amenity with ID ${id} not found`);
        }
        return amenity;
    }
    async update(id, updateAmenityDto) {
        const amenity = await this.findOne(id);
        if (updateAmenityDto.name) {
            const existingAmenity = await this.amenityRepository.findOne({
                where: { name: updateAmenityDto.name.trim(), id: (0, typeorm_2.Not)(id) }
            });
            if (existingAmenity) {
                throw new common_1.ConflictException(`Amenity with name "${updateAmenityDto.name}" already exists`);
            }
            amenity.name = updateAmenityDto.name.trim();
        }
        return await this.amenityRepository.save(amenity);
    }
    async remove(id) {
        const amenity = await this.findOne(id);
        const aircraftUsage = await this.aircraftAmenityRepository.count({
            where: { amenityId: id }
        });
        const charterDealUsage = await this.charterDealAmenityRepository.count({
            where: { amenityId: id }
        });
        if (aircraftUsage > 0 || charterDealUsage > 0) {
            throw new common_1.ConflictException(`Cannot delete amenity. It is currently assigned to ${aircraftUsage} aircraft and ${charterDealUsage} charter deals.`);
        }
        await this.amenityRepository.remove(amenity);
    }
    async getAircraftAmenities(aircraftId) {
        const aircraftAmenities = await this.aircraftAmenityRepository.find({
            where: { aircraftId },
            relations: ['amenity'],
            order: { amenity: { name: 'ASC' } }
        });
        return aircraftAmenities.map(aa => aa.amenity);
    }
    async getCharterDealAmenities(dealId) {
        const charterDealAmenities = await this.charterDealAmenityRepository.find({
            where: { dealId },
            relations: ['amenity'],
            order: { amenity: { name: 'ASC' } }
        });
        return charterDealAmenities.map(cda => cda.amenity);
    }
    async assignAmenitiesToAircraft(aircraftId, assignAmenitiesDto) {
        const { amenityIds } = assignAmenitiesDto;
        await this.aircraftAmenityRepository.delete({ aircraftId });
        const aircraftAmenities = amenityIds.map(amenityId => this.aircraftAmenityRepository.create({
            aircraftId,
            amenityId
        }));
        await this.aircraftAmenityRepository.save(aircraftAmenities);
    }
    async assignAmenitiesToCharterDeal(dealId, assignAmenitiesDto) {
        const { amenityIds } = assignAmenitiesDto;
        await this.charterDealAmenityRepository.delete({ dealId });
        const charterDealAmenities = amenityIds.map(amenityId => this.charterDealAmenityRepository.create({
            dealId,
            amenityId
        }));
        await this.charterDealAmenityRepository.save(charterDealAmenities);
    }
    async getAmenitiesWithUsage() {
        const amenities = await this.amenityRepository.find({
            order: { name: 'ASC' }
        });
        const amenitiesWithUsage = await Promise.all(amenities.map(async (amenity) => {
            const aircraftCount = await this.aircraftAmenityRepository.count({
                where: { amenityId: amenity.id }
            });
            const charterDealCount = await this.charterDealAmenityRepository.count({
                where: { amenityId: amenity.id }
            });
            return {
                ...amenity,
                aircraftCount,
                charterDealCount,
                totalUsage: aircraftCount + charterDealCount
            };
        }));
        return amenitiesWithUsage;
    }
};
exports.AmenitiesService = AmenitiesService;
exports.AmenitiesService = AmenitiesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(amenity_entity_1.Amenity)),
    __param(1, (0, typeorm_1.InjectRepository)(aircraft_amenity_entity_1.AircraftAmenity)),
    __param(2, (0, typeorm_1.InjectRepository)(charter_deal_amenity_entity_1.CharterDealAmenity)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object])
], AmenitiesService);


/***/ }),
/* 53 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoogleEarthEngineService = void 0;
const common_1 = __webpack_require__(2);
const axios_1 = __webpack_require__(54);
const config_1 = __webpack_require__(5);
const rxjs_1 = __webpack_require__(55);
let GoogleEarthEngineService = class GoogleEarthEngineService {
    constructor(httpService, configService) {
        this.httpService = httpService;
        this.configService = configService;
        this.baseUrl = 'https://maps.googleapis.com/maps/api';
        this.apiKey = this.configService.get('GOOGLE_MAPS_API_KEY');
    }
    async searchLocations(searchDto) {
        if (!this.apiKey) {
            throw new common_1.HttpException('Google Maps API key not configured', common_1.HttpStatus.SERVICE_UNAVAILABLE);
        }
        try {
            const response = await (0, rxjs_1.firstValueFrom)(this.httpService.get(`${this.baseUrl}/place/textsearch/json`, {
                params: {
                    query: searchDto.query,
                    key: this.apiKey,
                    type: searchDto.type || 'establishment',
                    location: searchDto.location,
                    radius: searchDto.radius || 2000000,
                },
            }));
            if (response.data.status === 'ZERO_RESULTS') {
                return [];
            }
            if (response.data.status !== 'OK') {
                throw new common_1.HttpException(`Google Places API error: ${response.data.status}`, common_1.HttpStatus.BAD_REQUEST);
            }
            return response.data.results.map(place => ({
                placeId: place.place_id,
                name: place.name,
                formattedAddress: place.formatted_address,
                location: {
                    lat: place.geometry.location.lat,
                    lng: place.geometry.location.lng,
                },
                types: place.types,
                rating: place.rating,
                userRatingsTotal: place.user_ratings_total,
            }));
        }
        catch (error) {
            throw new common_1.HttpException(`Location search failed: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async getPlaceDetails(placeId) {
        if (!this.apiKey) {
            throw new common_1.HttpException('Google Maps API key not configured', common_1.HttpStatus.SERVICE_UNAVAILABLE);
        }
        try {
            const response = await (0, rxjs_1.firstValueFrom)(this.httpService.get(`${this.baseUrl}/place/details/json`, {
                params: {
                    place_id: placeId,
                    key: this.apiKey,
                    fields: 'place_id,name,formatted_address,geometry,types,rating,user_ratings_total',
                },
            }));
            if (response.data.status !== 'OK') {
                throw new common_1.HttpException(`Google Places API error: ${response.data.status}`, common_1.HttpStatus.BAD_REQUEST);
            }
            const place = response.data.result;
            return {
                placeId: place.place_id,
                name: place.name,
                formattedAddress: place.formatted_address,
                location: {
                    lat: place.geometry.location.lat,
                    lng: place.geometry.location.lng,
                },
                types: place.types,
                rating: place.rating,
                userRatingsTotal: place.user_ratings_total,
            };
        }
        catch (error) {
            throw new common_1.HttpException(`Place details failed: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async reverseGeocode(reverseGeocodeDto) {
        if (!this.apiKey) {
            throw new common_1.HttpException('Google Maps API key not configured', common_1.HttpStatus.SERVICE_UNAVAILABLE);
        }
        try {
            const response = await (0, rxjs_1.firstValueFrom)(this.httpService.get(`${this.baseUrl}/geocode/json`, {
                params: {
                    latlng: `${reverseGeocodeDto.latitude},${reverseGeocodeDto.longitude}`,
                    key: this.apiKey,
                },
            }));
            if (response.data.status !== 'OK') {
                throw new common_1.HttpException(`Google Geocoding API error: ${response.data.status}`, common_1.HttpStatus.BAD_REQUEST);
            }
            const result = response.data.results[0];
            return {
                placeId: result.place_id,
                name: this.extractLocationName(result),
                formattedAddress: result.formatted_address,
                location: {
                    lat: reverseGeocodeDto.latitude,
                    lng: reverseGeocodeDto.longitude,
                },
                types: result.types,
            };
        }
        catch (error) {
            throw new common_1.HttpException(`Reverse geocoding failed: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async calculateDistance(distanceDto) {
        if (!this.apiKey) {
            throw new common_1.HttpException('Google Maps API key not configured', common_1.HttpStatus.SERVICE_UNAVAILABLE);
        }
        try {
            const response = await (0, rxjs_1.firstValueFrom)(this.httpService.get(`${this.baseUrl}/distancematrix/json`, {
                params: {
                    origins: `${distanceDto.origin.lat},${distanceDto.origin.lng}`,
                    destinations: `${distanceDto.destination.lat},${distanceDto.destination.lng}`,
                    key: this.apiKey,
                    mode: distanceDto.mode || 'driving',
                    units: 'metric',
                },
            }));
            if (response.data.status !== 'OK') {
                throw new common_1.HttpException(`Google Distance Matrix API error: ${response.data.status}`, common_1.HttpStatus.BAD_REQUEST);
            }
            const element = response.data.rows[0].elements[0];
            return {
                distance: element.distance,
                duration: element.duration,
                status: element.status,
            };
        }
        catch (error) {
            throw new common_1.HttpException(`Distance calculation failed: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    calculateFlightDistance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = this.toRadians(lat2 - lat1);
        const dLon = this.toRadians(lon2 - lon1);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }
    estimateFlightDuration(distance, aircraftType = 'jet') {
        const speeds = {
            jet: 800,
            turboprop: 500,
            helicopter: 250,
            small: 300,
        };
        const speed = speeds[aircraftType] || speeds.jet;
        return (distance / speed) * 3600;
    }
    toRadians(degrees) {
        return degrees * (Math.PI / 180);
    }
    extractLocationName(result) {
        const components = result.address_components;
        const nameComponent = components.find(comp => comp.types.includes('establishment') ||
            comp.types.includes('point_of_interest') ||
            comp.types.includes('airport'));
        return nameComponent ? nameComponent.long_name : result.formatted_address;
    }
};
exports.GoogleEarthEngineService = GoogleEarthEngineService;
exports.GoogleEarthEngineService = GoogleEarthEngineService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof axios_1.HttpService !== "undefined" && axios_1.HttpService) === "function" ? _a : Object, typeof (_b = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _b : Object])
], GoogleEarthEngineService);


/***/ }),
/* 54 */
/***/ ((module) => {

module.exports = require("@nestjs/axios");

/***/ }),
/* 55 */
/***/ ((module) => {

module.exports = require("rxjs");

/***/ }),
/* 56 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AmenitiesModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const amenities_controller_1 = __webpack_require__(57);
const amenities_service_1 = __webpack_require__(52);
const amenity_entity_1 = __webpack_require__(38);
const aircraft_amenity_entity_1 = __webpack_require__(37);
const charter_deal_amenity_entity_1 = __webpack_require__(39);
let AmenitiesModule = class AmenitiesModule {
};
exports.AmenitiesModule = AmenitiesModule;
exports.AmenitiesModule = AmenitiesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([amenity_entity_1.Amenity, aircraft_amenity_entity_1.AircraftAmenity, charter_deal_amenity_entity_1.CharterDealAmenity]),
        ],
        controllers: [amenities_controller_1.AmenitiesController],
        providers: [amenities_service_1.AmenitiesService],
        exports: [amenities_service_1.AmenitiesService],
    })
], AmenitiesModule);


/***/ }),
/* 57 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AmenitiesController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const amenities_service_1 = __webpack_require__(52);
const create_amenity_dto_1 = __webpack_require__(58);
const update_amenity_dto_1 = __webpack_require__(59);
const assign_amenities_dto_1 = __webpack_require__(60);
const jwt_auth_guard_1 = __webpack_require__(16);
const roles_guard_1 = __webpack_require__(61);
const roles_decorator_1 = __webpack_require__(62);
let AmenitiesController = class AmenitiesController {
    constructor(amenitiesService) {
        this.amenitiesService = amenitiesService;
    }
    create(createAmenityDto) {
        return this.amenitiesService.create(createAmenityDto);
    }
    findAll() {
        return this.amenitiesService.findAll();
    }
    getAmenitiesWithUsage() {
        return this.amenitiesService.getAmenitiesWithUsage();
    }
    findOne(id) {
        return this.amenitiesService.findOne(id);
    }
    update(id, updateAmenityDto) {
        return this.amenitiesService.update(id, updateAmenityDto);
    }
    remove(id) {
        return this.amenitiesService.remove(id);
    }
    getAircraftAmenities(aircraftId) {
        return this.amenitiesService.getAircraftAmenities(aircraftId);
    }
    getCharterDealAmenities(dealId) {
        return this.amenitiesService.getCharterDealAmenities(dealId);
    }
    assignAmenitiesToAircraft(aircraftId, assignAmenitiesDto) {
        return this.amenitiesService.assignAmenitiesToAircraft(aircraftId, assignAmenitiesDto);
    }
    assignAmenitiesToCharterDeal(dealId, assignAmenitiesDto) {
        return this.amenitiesService.assignAmenitiesToCharterDeal(dealId, assignAmenitiesDto);
    }
};
exports.AmenitiesController = AmenitiesController;
__decorate([
    (0, common_1.Post)(),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new amenity' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Amenity created successfully' }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'Amenity with this name already exists' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof create_amenity_dto_1.CreateAmenityDto !== "undefined" && create_amenity_dto_1.CreateAmenityDto) === "function" ? _b : Object]),
    __metadata("design:returntype", void 0)
], AmenitiesController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all amenities' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'List of all amenities' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], AmenitiesController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)('with-usage'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all amenities with usage statistics' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'List of amenities with usage data' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], AmenitiesController.prototype, "getAmenitiesWithUsage", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, swagger_1.ApiOperation)({ summary: 'Get amenity by ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Amenity found' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Amenity not found' }),
    __param(0, (0, common_1.Param)('id', common_1.ParseIntPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", void 0)
], AmenitiesController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':id'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update amenity' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Amenity updated successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Amenity not found' }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'Amenity with this name already exists' }),
    __param(0, (0, common_1.Param)('id', common_1.ParseIntPipe)),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, typeof (_c = typeof update_amenity_dto_1.UpdateAmenityDto !== "undefined" && update_amenity_dto_1.UpdateAmenityDto) === "function" ? _c : Object]),
    __metadata("design:returntype", void 0)
], AmenitiesController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':id'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Delete amenity' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Amenity deleted successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Amenity not found' }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'Cannot delete amenity - it is in use' }),
    __param(0, (0, common_1.Param)('id', common_1.ParseIntPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", void 0)
], AmenitiesController.prototype, "remove", null);
__decorate([
    (0, common_1.Get)('aircraft/:aircraftId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get amenities for a specific aircraft' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'List of aircraft amenities' }),
    __param(0, (0, common_1.Param)('aircraftId', common_1.ParseIntPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", void 0)
], AmenitiesController.prototype, "getAircraftAmenities", null);
__decorate([
    (0, common_1.Get)('charter-deal/:dealId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get amenities for a specific charter deal' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'List of charter deal amenities' }),
    __param(0, (0, common_1.Param)('dealId', common_1.ParseIntPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", void 0)
], AmenitiesController.prototype, "getCharterDealAmenities", null);
__decorate([
    (0, common_1.Post)('aircraft/:aircraftId/assign'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('admin', 'superadmin', 'companyAdmin'),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Assign amenities to an aircraft' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Amenities assigned successfully' }),
    __param(0, (0, common_1.Param)('aircraftId', common_1.ParseIntPipe)),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, typeof (_d = typeof assign_amenities_dto_1.AssignAmenitiesDto !== "undefined" && assign_amenities_dto_1.AssignAmenitiesDto) === "function" ? _d : Object]),
    __metadata("design:returntype", void 0)
], AmenitiesController.prototype, "assignAmenitiesToAircraft", null);
__decorate([
    (0, common_1.Post)('charter-deal/:dealId/assign'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('admin', 'superadmin', 'companyAdmin'),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Assign amenities to a charter deal' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Amenities assigned successfully' }),
    __param(0, (0, common_1.Param)('dealId', common_1.ParseIntPipe)),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, typeof (_e = typeof assign_amenities_dto_1.AssignAmenitiesDto !== "undefined" && assign_amenities_dto_1.AssignAmenitiesDto) === "function" ? _e : Object]),
    __metadata("design:returntype", void 0)
], AmenitiesController.prototype, "assignAmenitiesToCharterDeal", null);
exports.AmenitiesController = AmenitiesController = __decorate([
    (0, swagger_1.ApiTags)('Amenities'),
    (0, common_1.Controller)('amenities'),
    __metadata("design:paramtypes", [typeof (_a = typeof amenities_service_1.AmenitiesService !== "undefined" && amenities_service_1.AmenitiesService) === "function" ? _a : Object])
], AmenitiesController);


/***/ }),
/* 58 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateAmenityDto = void 0;
const swagger_1 = __webpack_require__(3);
const class_validator_1 = __webpack_require__(19);
class CreateAmenityDto {
}
exports.CreateAmenityDto = CreateAmenityDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Amenity name', example: 'WiFi' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(255),
    __metadata("design:type", String)
], CreateAmenityDto.prototype, "name", void 0);


/***/ }),
/* 59 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateAmenityDto = void 0;
const swagger_1 = __webpack_require__(3);
const class_validator_1 = __webpack_require__(19);
class UpdateAmenityDto {
}
exports.UpdateAmenityDto = UpdateAmenityDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Amenity name', example: 'WiFi', required: false }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.MaxLength)(255),
    __metadata("design:type", String)
], UpdateAmenityDto.prototype, "name", void 0);


/***/ }),
/* 60 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssignAmenitiesDto = void 0;
const swagger_1 = __webpack_require__(3);
const class_validator_1 = __webpack_require__(19);
class AssignAmenitiesDto {
}
exports.AssignAmenitiesDto = AssignAmenitiesDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Array of amenity IDs to assign', example: [1, 2, 3] }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsNumber)({}, { each: true }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Array)
], AssignAmenitiesDto.prototype, "amenityIds", void 0);


/***/ }),
/* 61 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RolesGuard = void 0;
const common_1 = __webpack_require__(2);
const core_1 = __webpack_require__(1);
const roles_decorator_1 = __webpack_require__(62);
let RolesGuard = class RolesGuard {
    constructor(reflector) {
        this.reflector = reflector;
    }
    canActivate(context) {
        const requiredRoles = this.reflector.getAllAndOverride(roles_decorator_1.ROLES_KEY, [
            context.getHandler(),
            context.getClass(),
        ]);
        if (!requiredRoles) {
            return true;
        }
        const { user } = context.switchToHttp().getRequest();
        if (!user) {
            return false;
        }
        return requiredRoles.some((role) => {
            if (user.role) {
                return user.role === role;
            }
            if (user.roles && Array.isArray(user.roles)) {
                return user.roles.includes(role);
            }
            return false;
        });
    }
};
exports.RolesGuard = RolesGuard;
exports.RolesGuard = RolesGuard = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof core_1.Reflector !== "undefined" && core_1.Reflector) === "function" ? _a : Object])
], RolesGuard);


/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ROLES = exports.Roles = exports.ROLES_KEY = void 0;
const common_1 = __webpack_require__(2);
exports.ROLES_KEY = 'roles';
const Roles = (...roles) => (0, common_1.SetMetadata)(exports.ROLES_KEY, roles);
exports.Roles = Roles;
exports.ROLES = {
    SUPERADMIN: 'superadmin',
    CIT_ADMIN: 'citAdmin',
    COMPANY_ADMIN: 'companyAdmin',
    AGENT: 'agent',
    MANAGER: 'manager',
    OPERATOR: 'operator',
    FINANCE: 'finance',
    USER: 'user',
};


/***/ }),
/* 63 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoogleEarthEngineModule = void 0;
const common_1 = __webpack_require__(2);
const axios_1 = __webpack_require__(54);
const google_earth_engine_controller_1 = __webpack_require__(64);
const google_earth_engine_service_1 = __webpack_require__(53);
let GoogleEarthEngineModule = class GoogleEarthEngineModule {
};
exports.GoogleEarthEngineModule = GoogleEarthEngineModule;
exports.GoogleEarthEngineModule = GoogleEarthEngineModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [axios_1.HttpModule],
        controllers: [google_earth_engine_controller_1.GoogleEarthEngineController],
        providers: [google_earth_engine_service_1.GoogleEarthEngineService],
        exports: [google_earth_engine_service_1.GoogleEarthEngineService],
    })
], GoogleEarthEngineModule);


/***/ }),
/* 64 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoogleEarthEngineController = void 0;
const common_1 = __webpack_require__(2);
const google_earth_engine_service_1 = __webpack_require__(53);
const google_earth_engine_dto_1 = __webpack_require__(65);
let GoogleEarthEngineController = class GoogleEarthEngineController {
    constructor(googleEarthEngineService) {
        this.googleEarthEngineService = googleEarthEngineService;
    }
    async searchLocations(searchDto) {
        return this.googleEarthEngineService.searchLocations(searchDto);
    }
    async searchLocationsPost(searchDto) {
        return this.googleEarthEngineService.searchLocations(searchDto);
    }
    async reverseGeocode(reverseGeocodeDto) {
        return this.googleEarthEngineService.reverseGeocode(reverseGeocodeDto);
    }
    async reverseGeocodePost(reverseGeocodeDto) {
        return this.googleEarthEngineService.reverseGeocode(reverseGeocodeDto);
    }
    async calculateDistance(distanceDto) {
        return this.googleEarthEngineService.calculateDistance(distanceDto);
    }
    async calculateDistancePost(distanceDto) {
        return this.googleEarthEngineService.calculateDistance(distanceDto);
    }
    async getPlaceDetails(placeId) {
        return this.googleEarthEngineService.getPlaceDetails(placeId);
    }
    async calculateFlightDistance(lat1, lon1, lat2, lon2, aircraftType = 'jet') {
        const distance = this.googleEarthEngineService.calculateFlightDistance(lat1, lon1, lat2, lon2);
        const duration = this.googleEarthEngineService.estimateFlightDuration(distance, aircraftType);
        return {
            distance: distance,
            duration: duration,
            distanceText: `${distance.toFixed(1)} km`,
            durationText: `${(duration / 3600).toFixed(1)} hours`,
            aircraftType: aircraftType,
        };
    }
};
exports.GoogleEarthEngineController = GoogleEarthEngineController;
__decorate([
    (0, common_1.Get)('search/locations'),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof google_earth_engine_dto_1.GoogleEarthEngineSearchDto !== "undefined" && google_earth_engine_dto_1.GoogleEarthEngineSearchDto) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], GoogleEarthEngineController.prototype, "searchLocations", null);
__decorate([
    (0, common_1.Post)('search'),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof google_earth_engine_dto_1.GoogleEarthEngineSearchDto !== "undefined" && google_earth_engine_dto_1.GoogleEarthEngineSearchDto) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], GoogleEarthEngineController.prototype, "searchLocationsPost", null);
__decorate([
    (0, common_1.Get)('geocode/reverse'),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof google_earth_engine_dto_1.GoogleEarthEngineReverseGeocodeDto !== "undefined" && google_earth_engine_dto_1.GoogleEarthEngineReverseGeocodeDto) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], GoogleEarthEngineController.prototype, "reverseGeocode", null);
__decorate([
    (0, common_1.Post)('reverse-geocode'),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_e = typeof google_earth_engine_dto_1.GoogleEarthEngineReverseGeocodeDto !== "undefined" && google_earth_engine_dto_1.GoogleEarthEngineReverseGeocodeDto) === "function" ? _e : Object]),
    __metadata("design:returntype", Promise)
], GoogleEarthEngineController.prototype, "reverseGeocodePost", null);
__decorate([
    (0, common_1.Get)('distance/calculate'),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_f = typeof google_earth_engine_dto_1.GoogleEarthEngineDistanceDto !== "undefined" && google_earth_engine_dto_1.GoogleEarthEngineDistanceDto) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], GoogleEarthEngineController.prototype, "calculateDistance", null);
__decorate([
    (0, common_1.Post)('distance'),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_g = typeof google_earth_engine_dto_1.GoogleEarthEngineDistanceDto !== "undefined" && google_earth_engine_dto_1.GoogleEarthEngineDistanceDto) === "function" ? _g : Object]),
    __metadata("design:returntype", Promise)
], GoogleEarthEngineController.prototype, "calculateDistancePost", null);
__decorate([
    (0, common_1.Get)('place/:placeId'),
    __param(0, (0, common_1.Query)('placeId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], GoogleEarthEngineController.prototype, "getPlaceDetails", null);
__decorate([
    (0, common_1.Get)('distance/flight'),
    __param(0, (0, common_1.Query)('lat1')),
    __param(1, (0, common_1.Query)('lon1')),
    __param(2, (0, common_1.Query)('lat2')),
    __param(3, (0, common_1.Query)('lon2')),
    __param(4, (0, common_1.Query)('aircraftType')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number, Number, Number, String]),
    __metadata("design:returntype", Promise)
], GoogleEarthEngineController.prototype, "calculateFlightDistance", null);
exports.GoogleEarthEngineController = GoogleEarthEngineController = __decorate([
    (0, common_1.Controller)('google-earth-engine'),
    __metadata("design:paramtypes", [typeof (_a = typeof google_earth_engine_service_1.GoogleEarthEngineService !== "undefined" && google_earth_engine_service_1.GoogleEarthEngineService) === "function" ? _a : Object])
], GoogleEarthEngineController);


/***/ }),
/* 65 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoogleEarthEngineDistanceDto = exports.GoogleEarthEngineReverseGeocodeDto = exports.GoogleEarthEngineSearchDto = exports.GoogleEarthEngineLocationDto = void 0;
const class_validator_1 = __webpack_require__(19);
class GoogleEarthEngineLocationDto {
}
exports.GoogleEarthEngineLocationDto = GoogleEarthEngineLocationDto;
class GoogleEarthEngineSearchDto {
}
exports.GoogleEarthEngineSearchDto = GoogleEarthEngineSearchDto;
__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GoogleEarthEngineSearchDto.prototype, "query", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GoogleEarthEngineSearchDto.prototype, "type", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GoogleEarthEngineSearchDto.prototype, "location", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1000),
    (0, class_validator_1.Max)(2000000),
    __metadata("design:type", Number)
], GoogleEarthEngineSearchDto.prototype, "radius", void 0);
class GoogleEarthEngineReverseGeocodeDto {
}
exports.GoogleEarthEngineReverseGeocodeDto = GoogleEarthEngineReverseGeocodeDto;
__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(-90),
    (0, class_validator_1.Max)(90),
    __metadata("design:type", Number)
], GoogleEarthEngineReverseGeocodeDto.prototype, "latitude", void 0);
__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(-180),
    (0, class_validator_1.Max)(180),
    __metadata("design:type", Number)
], GoogleEarthEngineReverseGeocodeDto.prototype, "longitude", void 0);
class GoogleEarthEngineDistanceDto {
}
exports.GoogleEarthEngineDistanceDto = GoogleEarthEngineDistanceDto;
__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Object)
], GoogleEarthEngineDistanceDto.prototype, "origin", void 0);
__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Object)
], GoogleEarthEngineDistanceDto.prototype, "destination", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(['driving', 'walking', 'bicycling', 'transit']),
    __metadata("design:type", String)
], GoogleEarthEngineDistanceDto.prototype, "mode", void 0);


/***/ }),
/* 66 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PassengersModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const passengers_service_1 = __webpack_require__(67);
const passengers_controller_1 = __webpack_require__(68);
const passenger_entity_1 = __webpack_require__(41);
let PassengersModule = class PassengersModule {
};
exports.PassengersModule = PassengersModule;
exports.PassengersModule = PassengersModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([passenger_entity_1.Passenger])],
        controllers: [passengers_controller_1.PassengersController],
        providers: [passengers_service_1.PassengersService],
        exports: [passengers_service_1.PassengersService],
    })
], PassengersModule);


/***/ }),
/* 67 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PassengersService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const passenger_entity_1 = __webpack_require__(41);
let PassengersService = class PassengersService {
    constructor(passengerRepository) {
        this.passengerRepository = passengerRepository;
    }
    async create(createPassengerDto) {
        const passenger = this.passengerRepository.create(createPassengerDto);
        return await this.passengerRepository.save(passenger);
    }
    async findAll() {
        return await this.passengerRepository.find({
            order: { created_at: 'DESC' },
        });
    }
    async findOne(id) {
        const passenger = await this.passengerRepository.findOne({
            where: { id },
        });
        if (!passenger) {
            throw new common_1.NotFoundException(`Passenger with ID ${id} not found`);
        }
        return passenger;
    }
    async findByBookingId(bookingId) {
        return await this.passengerRepository.find({
            where: { booking_id: bookingId },
            order: { created_at: 'ASC' },
        });
    }
    async update(id, updatePassengerDto) {
        await this.passengerRepository.update(id, updatePassengerDto);
        return await this.findOne(id);
    }
    async remove(id) {
        await this.passengerRepository.delete(id);
    }
    async removeByBookingId(bookingId) {
        await this.passengerRepository.delete({ booking_id: bookingId });
    }
    async countByBookingId(bookingId) {
        return await this.passengerRepository.count({
            where: { booking_id: bookingId },
        });
    }
};
exports.PassengersService = PassengersService;
exports.PassengersService = PassengersService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(passenger_entity_1.Passenger)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], PassengersService);


/***/ }),
/* 68 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PassengersController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const passengers_service_1 = __webpack_require__(67);
const dto_1 = __webpack_require__(69);
const jwt_auth_guard_1 = __webpack_require__(16);
let PassengersController = class PassengersController {
    constructor(passengersService) {
        this.passengersService = passengersService;
    }
    async create(createPassengerDto) {
        const passenger = await this.passengersService.create(createPassengerDto);
        return {
            success: true,
            message: 'Passenger created successfully',
            data: passenger,
        };
    }
    async findAll() {
        const passengers = await this.passengersService.findAll();
        return {
            success: true,
            message: 'Passengers retrieved successfully',
            data: passengers,
        };
    }
    async findOne(id) {
        const passenger = await this.passengersService.findOne(+id);
        return {
            success: true,
            message: 'Passenger retrieved successfully',
            data: passenger,
        };
    }
    async findByBookingId(bookingId) {
        const passengers = await this.passengersService.findByBookingId(+bookingId);
        return {
            success: true,
            message: 'Passengers retrieved successfully',
            data: passengers,
            count: passengers.length,
        };
    }
    async update(id, updatePassengerDto) {
        const passenger = await this.passengersService.update(+id, updatePassengerDto);
        return {
            success: true,
            message: 'Passenger updated successfully',
            data: passenger,
        };
    }
    async remove(id) {
        await this.passengersService.remove(+id);
    }
    async removeByBookingId(bookingId) {
        await this.passengersService.removeByBookingId(+bookingId);
    }
};
exports.PassengersController = PassengersController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new passenger' }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Passenger created successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'object',
                    properties: {
                        id: { type: 'number' },
                        bookingId: { type: 'string' },
                        firstName: { type: 'string' },
                        lastName: { type: 'string' },
                        age: { type: 'number', nullable: true },
                        nationality: { type: 'string', nullable: true },
                        idPassportNumber: { type: 'string', nullable: true },
                        createdAt: { type: 'string', format: 'date-time' },
                        fullName: { type: 'string' },
                        displayName: { type: 'string' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad request' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof dto_1.CreatePassengerDto !== "undefined" && dto_1.CreatePassengerDto) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], PassengersController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all passengers' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Passengers retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'number' },
                            bookingId: { type: 'string' },
                            firstName: { type: 'string' },
                            lastName: { type: 'string' },
                            age: { type: 'number', nullable: true },
                            nationality: { type: 'string', nullable: true },
                            idPassportNumber: { type: 'string', nullable: true },
                            createdAt: { type: 'string', format: 'date-time' },
                            fullName: { type: 'string' },
                            displayName: { type: 'string' },
                        },
                    },
                },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PassengersController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, swagger_1.ApiOperation)({ summary: 'Get passenger by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: Number, description: 'Passenger ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Passenger retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'object',
                    properties: {
                        id: { type: 'number' },
                        bookingId: { type: 'string' },
                        firstName: { type: 'string' },
                        lastName: { type: 'string' },
                        age: { type: 'number', nullable: true },
                        nationality: { type: 'string', nullable: true },
                        idPassportNumber: { type: 'string', nullable: true },
                        createdAt: { type: 'string', format: 'date-time' },
                        fullName: { type: 'string' },
                        displayName: { type: 'string' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Passenger not found' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PassengersController.prototype, "findOne", null);
__decorate([
    (0, common_1.Get)('booking/:bookingId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get passengers by booking ID' }),
    (0, swagger_1.ApiParam)({ name: 'bookingId', type: String, description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Passengers retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'number' },
                            bookingId: { type: 'string' },
                            firstName: { type: 'string' },
                            lastName: { type: 'string' },
                            age: { type: 'number', nullable: true },
                            nationality: { type: 'string', nullable: true },
                            idPassportNumber: { type: 'string', nullable: true },
                            createdAt: { type: 'string', format: 'date-time' },
                            fullName: { type: 'string' },
                            displayName: { type: 'string' },
                        },
                    },
                },
                count: { type: 'number' },
            },
        },
    }),
    __param(0, (0, common_1.Param)('bookingId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PassengersController.prototype, "findByBookingId", null);
__decorate([
    (0, common_1.Patch)(':id'),
    (0, swagger_1.ApiOperation)({ summary: 'Update passenger by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: Number, description: 'Passenger ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Passenger updated successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'object',
                    properties: {
                        id: { type: 'number' },
                        bookingId: { type: 'string' },
                        firstName: { type: 'string' },
                        lastName: { type: 'string' },
                        age: { type: 'number', nullable: true },
                        nationality: { type: 'string', nullable: true },
                        idPassportNumber: { type: 'string', nullable: true },
                        createdAt: { type: 'string', format: 'date-time' },
                        fullName: { type: 'string' },
                        displayName: { type: 'string' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Passenger not found' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_c = typeof dto_1.UpdatePassengerDto !== "undefined" && dto_1.UpdatePassengerDto) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], PassengersController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':id'),
    (0, common_1.HttpCode)(common_1.HttpStatus.NO_CONTENT),
    (0, swagger_1.ApiOperation)({ summary: 'Delete passenger by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: Number, description: 'Passenger ID' }),
    (0, swagger_1.ApiResponse)({ status: 204, description: 'Passenger deleted successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Passenger not found' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PassengersController.prototype, "remove", null);
__decorate([
    (0, common_1.Delete)('booking/:bookingId'),
    (0, common_1.HttpCode)(common_1.HttpStatus.NO_CONTENT),
    (0, swagger_1.ApiOperation)({ summary: 'Delete all passengers for a booking' }),
    (0, swagger_1.ApiParam)({ name: 'bookingId', type: String, description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({ status: 204, description: 'Passengers deleted successfully' }),
    __param(0, (0, common_1.Param)('bookingId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PassengersController.prototype, "removeByBookingId", null);
exports.PassengersController = PassengersController = __decorate([
    (0, swagger_1.ApiTags)('Passengers'),
    (0, common_1.Controller)('passengers'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof passengers_service_1.PassengersService !== "undefined" && passengers_service_1.PassengersService) === "function" ? _a : Object])
], PassengersController);


/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdatePassengerDto = exports.CreatePassengerDto = void 0;
var create_passenger_dto_1 = __webpack_require__(70);
Object.defineProperty(exports, "CreatePassengerDto", ({ enumerable: true, get: function () { return create_passenger_dto_1.CreatePassengerDto; } }));
var update_passenger_dto_1 = __webpack_require__(71);
Object.defineProperty(exports, "UpdatePassengerDto", ({ enumerable: true, get: function () { return update_passenger_dto_1.UpdatePassengerDto; } }));


/***/ }),
/* 70 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatePassengerDto = void 0;
const swagger_1 = __webpack_require__(3);
const class_validator_1 = __webpack_require__(19);
class CreatePassengerDto {
}
exports.CreatePassengerDto = CreatePassengerDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Booking ID this passenger belongs to',
        example: 'booking_1752533042834_nsyj4iqyf',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePassengerDto.prototype, "bookingId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Passenger first name',
        example: 'John',
        minLength: 2,
        maxLength: 100,
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Length)(2, 100),
    __metadata("design:type", String)
], CreatePassengerDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Passenger last name',
        example: 'Doe',
        minLength: 2,
        maxLength: 100,
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Length)(2, 100),
    __metadata("design:type", String)
], CreatePassengerDto.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Passenger age',
        example: 25,
        minimum: 0,
        maximum: 120,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.Max)(120),
    __metadata("design:type", Number)
], CreatePassengerDto.prototype, "age", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Passenger nationality',
        example: 'United States',
        maxLength: 100,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Length)(1, 100),
    __metadata("design:type", String)
], CreatePassengerDto.prototype, "nationality", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID or Passport number',
        example: 'A12345678',
        maxLength: 100,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Length)(1, 100),
    __metadata("design:type", String)
], CreatePassengerDto.prototype, "idPassportNumber", void 0);


/***/ }),
/* 71 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdatePassengerDto = void 0;
const swagger_1 = __webpack_require__(3);
const class_validator_1 = __webpack_require__(19);
class UpdatePassengerDto {
}
exports.UpdatePassengerDto = UpdatePassengerDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Passenger first name',
        example: 'John',
        minLength: 2,
        maxLength: 100,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Length)(2, 100),
    __metadata("design:type", String)
], UpdatePassengerDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Passenger last name',
        example: 'Doe',
        minLength: 2,
        maxLength: 100,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Length)(2, 100),
    __metadata("design:type", String)
], UpdatePassengerDto.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Passenger age',
        example: 25,
        minimum: 0,
        maximum: 120,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.Max)(120),
    __metadata("design:type", Number)
], UpdatePassengerDto.prototype, "age", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Passenger nationality',
        example: 'United States',
        maxLength: 100,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Length)(1, 100),
    __metadata("design:type", String)
], UpdatePassengerDto.prototype, "nationality", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID or Passport number',
        example: 'A12345678',
        maxLength: 100,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Length)(1, 100),
    __metadata("design:type", String)
], UpdatePassengerDto.prototype, "idPassportNumber", void 0);


/***/ }),
/* 72 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BookingsModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const bookings_service_1 = __webpack_require__(73);
const bookings_controller_1 = __webpack_require__(94);
const booking_entity_1 = __webpack_require__(29);
const charter_deal_entity_1 = __webpack_require__(30);
const experience_schedule_entity_1 = __webpack_require__(34);
const passenger_entity_1 = __webpack_require__(41);
const booking_timeline_entity_1 = __webpack_require__(74);
const user_trips_entity_1 = __webpack_require__(77);
const wallet_transaction_entity_1 = __webpack_require__(28);
const user_entity_1 = __webpack_require__(14);
const payment_entity_1 = __webpack_require__(76);
const wallet_module_1 = __webpack_require__(97);
const payments_module_1 = __webpack_require__(99);
const email_module_1 = __webpack_require__(125);
const booking_payment_service_1 = __webpack_require__(75);
const booking_timeline_service_1 = __webpack_require__(79);
const booking_query_service_1 = __webpack_require__(80);
let BookingsModule = class BookingsModule {
};
exports.BookingsModule = BookingsModule;
exports.BookingsModule = BookingsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([booking_entity_1.Booking, charter_deal_entity_1.CharterDeal, experience_schedule_entity_1.ExperienceSchedule, passenger_entity_1.Passenger, booking_timeline_entity_1.BookingTimeline, user_trips_entity_1.UserTrip, wallet_transaction_entity_1.WalletTransaction, user_entity_1.User, payment_entity_1.Payment]),
            wallet_module_1.WalletModule,
            payments_module_1.PaymentsModule,
            email_module_1.EmailModule,
        ],
        controllers: [bookings_controller_1.BookingsController],
        providers: [
            bookings_service_1.BookingsService,
            booking_payment_service_1.BookingPaymentService,
            booking_timeline_service_1.BookingTimelineService,
            booking_query_service_1.BookingQueryService,
        ],
        exports: [bookings_service_1.BookingsService],
    })
], BookingsModule);


/***/ }),
/* 73 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BookingsService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const booking_entity_1 = __webpack_require__(29);
const charter_deal_entity_1 = __webpack_require__(30);
const passenger_entity_1 = __webpack_require__(41);
const booking_timeline_entity_1 = __webpack_require__(74);
const booking_payment_service_1 = __webpack_require__(75);
const booking_timeline_service_1 = __webpack_require__(79);
const booking_query_service_1 = __webpack_require__(80);
const email_service_1 = __webpack_require__(81);
const payment_provider_service_1 = __webpack_require__(83);
const payment_provider_interface_1 = __webpack_require__(84);
const user_entity_1 = __webpack_require__(14);
const user_trips_entity_1 = __webpack_require__(77);
const experience_schedule_entity_1 = __webpack_require__(34);
let BookingsService = class BookingsService {
    constructor(bookingRepository, charterDealRepository, experienceScheduleRepository, passengerRepository, timelineRepository, dataSource, bookingPaymentService, bookingTimelineService, bookingQueryService, paymentProviderService, emailService) {
        this.bookingRepository = bookingRepository;
        this.charterDealRepository = charterDealRepository;
        this.experienceScheduleRepository = experienceScheduleRepository;
        this.passengerRepository = passengerRepository;
        this.timelineRepository = timelineRepository;
        this.dataSource = dataSource;
        this.bookingPaymentService = bookingPaymentService;
        this.bookingTimelineService = bookingTimelineService;
        this.bookingQueryService = bookingQueryService;
        this.paymentProviderService = paymentProviderService;
        this.emailService = emailService;
        this.bookingCounter = 0;
    }
    async testUserExists(userId) {
        try {
            const user = await this.dataSource.getRepository(user_entity_1.User).findOne({
                where: { id: userId },
                select: ['id', 'email', 'first_name', 'last_name']
            });
            return {
                exists: !!user,
                user: user || null,
                message: user ? 'User exists in database' : 'User not found in database'
            };
        }
        catch (error) {
            return {
                exists: false,
                user: null,
                message: `Error checking user: ${error.message}`,
                error: error.message
            };
        }
    }
    async create(createBookingDto, userId) {
        const bookingId = this.generateBookingId();
        const deal = await this.charterDealRepository.findOne({
            where: { id: createBookingDto.dealId },
            select: ['id', 'companyId', 'availableSeats', 'aircraftId', 'originName', 'originLatitude', 'originLongitude', 'destinationName', 'destinationLatitude', 'destinationLongitude', 'date', 'time', 'pricePerSeat']
        });
        if (!deal) {
            throw new common_1.NotFoundException(`Charter deal with ID ${createBookingDto.dealId} not found`);
        }
        const user = await this.dataSource.getRepository(user_entity_1.User).findOne({
            where: { id: userId },
            select: ['id', 'first_name', 'last_name', 'nationality', 'date_of_birth']
        });
        if (!user) {
            throw new common_1.NotFoundException(`User with ID ${userId} not found`);
        }
        const passengersToCreate = [];
        const userInPassengers = createBookingDto.passengers?.find(p => p.firstName.toLowerCase() === user.first_name?.toLowerCase() &&
            p.lastName.toLowerCase() === user.last_name?.toLowerCase());
        if (!userInPassengers) {
            passengersToCreate.push({
                firstName: user.first_name || 'Unknown',
                lastName: user.last_name || 'User',
                age: user.date_of_birth ? this.calculateAge(user.date_of_birth) : 25,
                nationality: user.nationality,
                idPassportNumber: undefined,
                isUser: true,
            });
        }
        if (createBookingDto.passengers && createBookingDto.passengers.length > 0) {
            passengersToCreate.push(...createBookingDto.passengers.map(p => ({
                ...p,
                isUser: false,
            })));
        }
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        console.log('ðŸ” DEBUG: Starting booking creation transaction for user:', userId);
        console.log('ðŸ” DEBUG: Deal data:', {
            id: deal.id,
            companyId: deal.companyId,
            aircraftId: deal.aircraftId,
            date: deal.date,
            time: deal.time,
            pricePerSeat: deal.pricePerSeat,
            availableSeats: deal.availableSeats
        });
        console.log('ðŸ” DEBUG: Deal aircraftId type:', typeof deal.aircraftId, 'value:', deal.aircraftId);
        console.log('ðŸ” DEBUG: Passengers to create:', passengersToCreate);
        console.log('ðŸ” DEBUG: Total adults calculation:', passengersToCreate.filter(p => {
            const age = p.age || 25;
            console.log('ðŸ” DEBUG: Passenger age:', p.age, 'Default age:', 25, 'Final age:', age);
            return typeof age === 'number' && !isNaN(age) && age >= 18;
        }).length);
        console.log('ðŸ” DEBUG: Total children calculation:', passengersToCreate.filter(p => {
            const age = p.age || 25;
            return typeof age === 'number' && !isNaN(age) && age < 18;
        }).length);
        try {
            const lockedDeal = await queryRunner.manager.findOne(charter_deal_entity_1.CharterDeal, {
                where: { id: createBookingDto.dealId },
                lock: { mode: 'pessimistic_write' },
            });
            if (!lockedDeal) {
                throw new common_1.BadRequestException('Deal not found or no longer available');
            }
            if (lockedDeal.availableSeats < passengersToCreate.length) {
                throw new common_1.BadRequestException(`Insufficient seats available. Only ${lockedDeal.availableSeats} seats left, but ${passengersToCreate.length} passengers requested.`);
            }
            const referenceNumber = this.generateBookingReference();
            const now = new Date();
            const booking = this.bookingRepository.create({
                userId,
                dealId: createBookingDto.dealId,
                companyId: Number(deal.companyId) || 0,
                aircraftId: deal.aircraftId,
                bookingType: booking_entity_1.BookingType.DEAL,
                experienceScheduleId: null,
                totalPrice: null,
                taxType: null,
                taxAmount: null,
                subtotal: null,
                bookingStatus: booking_entity_1.BookingStatus.PENDING,
                paymentStatus: booking_entity_1.PaymentStatus.PENDING,
                referenceNumber: referenceNumber,
                specialRequirements: createBookingDto.specialRequirements,
                adminNotes: null,
                originName: null,
                originLatitude: null,
                originLongitude: null,
                destinationName: null,
                destinationLatitude: null,
                destinationLongitude: null,
                departureDateTime: null,
                estimatedFlightHours: null,
                estimatedArrivalTime: null,
                onboardDining: createBookingDto.onboardDining || false,
                totalAdults: (() => {
                    const adults = passengersToCreate.filter(p => {
                        const age = p.age || 25;
                        return typeof age === 'number' && !isNaN(age) && age >= 18;
                    }).length;
                    return Number(adults) || 0;
                })(),
                totalChildren: (() => {
                    const children = passengersToCreate.filter(p => {
                        const age = p.age || 25;
                        return typeof age === 'number' && !isNaN(age) && age < 18;
                    }).length;
                    return Number(children) || 0;
                })(),
                createdAt: now,
                updatedAt: now,
            });
            const savedBooking = await queryRunner.manager.save(booking);
            for (const passengerData of passengersToCreate) {
                const passenger = queryRunner.manager.create(passenger_entity_1.Passenger, {
                    booking_id: savedBooking.id,
                    first_name: passengerData.firstName,
                    last_name: passengerData.lastName,
                    age: passengerData.age || null,
                    nationality: passengerData.nationality || null,
                    id_passport_number: passengerData.idPassportNumber || null,
                    is_user: passengerData.isUser === true,
                });
                await queryRunner.manager.save(passenger);
            }
            const passengerCount = passengersToCreate.length;
            lockedDeal.availableSeats -= passengerCount;
            await queryRunner.manager.save(lockedDeal);
            await queryRunner.commitTransaction();
            await this.bookingTimelineService.createTimelineEvent(savedBooking.id.toString(), booking_timeline_entity_1.TimelineEventType.BOOKING_CREATED, {
                title: 'Booking Created',
                description: `Booking ${referenceNumber} has been created successfully with ${passengerCount} passengers. Loyalty points will be earned upon payment.`,
                metadata: {
                    passengerCount,
                    companyId: lockedDeal.companyId,
                    referenceNumber: referenceNumber,
                    totalPrice: createBookingDto.totalPrice,
                    userIncluded: !userInPassengers,
                }
            });
            return this.bookingQueryService.findOne(savedBooking.id.toString());
        }
        catch (error) {
            if (queryRunner.isTransactionActive) {
                await queryRunner.rollbackTransaction();
            }
            throw new common_1.BadRequestException('Failed to create booking: ' + error.message);
        }
        finally {
            await queryRunner.release();
        }
    }
    async createWithPaymentIntent(createBookingDto, userId) {
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            const booking = await this.createBookingInTransaction(createBookingDto, userId, queryRunner);
            let paymentIntent = null;
            if (booking.totalPrice > 0) {
                try {
                    paymentIntent = await this.paymentProviderService.createPaymentIntent({
                        amount: booking.totalPrice,
                        currency: 'USD',
                        bookingId: booking.id.toString(),
                        userId: booking.userId,
                        description: `Payment for booking ${booking.referenceNumber}`,
                        metadata: {
                            bookingId: booking.id.toString(),
                            referenceNumber: booking.referenceNumber,
                            dealId: booking.dealId,
                            company_id: booking.companyId,
                            bookingType: 'deal_booking',
                        },
                    }, payment_provider_interface_1.PaymentProviderType.PAYSTACK);
                }
                catch (error) {
                    console.error('Failed to create payment intent for deal booking:', error);
                    throw new common_1.BadRequestException(`Payment setup failed: ${error.message}`);
                }
            }
            else {
                console.log(`Skipping payment intent creation for deal inquiry (totalPrice: ${booking.totalPrice})`);
            }
            await queryRunner.commitTransaction();
            return {
                booking,
                paymentIntent: paymentIntent ? {
                    id: paymentIntent.id,
                    clientSecret: paymentIntent.clientSecret,
                    status: paymentIntent.status,
                    requiresAction: paymentIntent.requiresAction,
                    nextAction: paymentIntent.nextAction,
                } : null,
                paymentInstructions: paymentIntent ? {
                    amount: booking.totalPrice,
                    currency: 'USD',
                    paymentMethods: ['card', 'apple_pay', 'google_pay', 'bank_transfer'],
                    nextSteps: [
                        'Complete payment using the client secret',
                        'Confirm payment using /payments/confirm',
                        'Process booking using /bookings/:id/process-payment'
                    ],
                    apiEndpoints: {
                        confirmPayment: `/payments/confirm`,
                        processBooking: `/bookings/${booking.id}/process-payment`,
                        paymentStatus: `/payments/status/${paymentIntent.id}`
                    }
                } : null,
            };
        }
        catch (error) {
            await queryRunner.rollbackTransaction();
            throw error;
        }
        finally {
            await queryRunner.release();
        }
    }
    async createBookingInTransaction(createBookingDto, userId, queryRunner) {
        let deal = null;
        let experience = null;
        let companyId;
        let aircraftId;
        let bookingType;
        let dealId = null;
        let experienceScheduleId = null;
        if (createBookingDto.experienceScheduleId) {
            experience = await queryRunner.manager.findOne(experience_schedule_entity_1.ExperienceSchedule, {
                where: { id: createBookingDto.experienceScheduleId },
                relations: ['company', 'aircraft']
            });
            if (!experience) {
                throw new common_1.NotFoundException(`Experience schedule with ID ${createBookingDto.experienceScheduleId} not found`);
            }
            companyId = experience.companyId;
            aircraftId = experience.aircraftId;
            bookingType = booking_entity_1.BookingType.EXPERIENCE;
            experienceScheduleId = createBookingDto.experienceScheduleId;
        }
        else {
            deal = await queryRunner.manager.findOne(charter_deal_entity_1.CharterDeal, {
                where: { id: createBookingDto.dealId },
                relations: ['company', 'aircraft']
            });
            if (!deal) {
                throw new common_1.NotFoundException(`Deal with ID ${createBookingDto.dealId} not found`);
            }
            companyId = deal.companyId;
            aircraftId = deal.aircraftId;
            bookingType = booking_entity_1.BookingType.DEAL;
            dealId = createBookingDto.dealId;
        }
        const booking = queryRunner.manager.create(booking_entity_1.Booking, {
            userId,
            companyId,
            aircraftId,
            dealId,
            experienceScheduleId,
            bookingType,
            totalPrice: createBookingDto.totalPrice,
            onboardDining: createBookingDto.onboardDining,
            specialRequirements: createBookingDto.specialRequirements,
            billingRegion: createBookingDto.billingRegion,
            bookingStatus: booking_entity_1.BookingStatus.PENDING,
            paymentStatus: booking_entity_1.PaymentStatus.PENDING,
            referenceNumber: this.generateBookingReference(),
            originName: deal?.originName || experience?.originName,
            destinationName: deal?.destinationName || experience?.destinationName,
            originLatitude: deal?.originLatitude || experience?.originLatitude,
            originLongitude: deal?.originLongitude || experience?.originLongitude,
            destinationLatitude: deal?.destinationLatitude || experience?.destinationLatitude,
            destinationLongitude: deal?.destinationLongitude || experience?.destinationLongitude,
            departureDateTime: deal?.date || experience?.scheduledDate,
        });
        return await queryRunner.manager.save(booking);
    }
    async findAll(userId) {
        return this.bookingQueryService.findAll(userId);
    }
    async findOne(id) {
        return this.bookingQueryService.findOne(id);
    }
    async findByReference(referenceNumber) {
        return this.bookingQueryService.findByReference(referenceNumber);
    }
    async findByUser(userId) {
        return this.bookingQueryService.findAll(userId);
    }
    async findByUserWithFilters(userId, filters) {
        return this.bookingQueryService.findByUserWithFilters(userId, filters);
    }
    async updateStatus(id, bookingStatus) {
        const booking = await this.bookingQueryService.findOne(id);
        const oldStatus = booking.bookingStatus;
        booking.bookingStatus = bookingStatus;
        await this.bookingRepository.save(booking);
        await this.bookingTimelineService.createTimelineEvent(id, booking_timeline_entity_1.TimelineEventType.STATUS_CHANGED, {
            title: 'Booking Status Updated',
            description: `Booking status changed from ${oldStatus} to ${bookingStatus}`,
            oldValue: oldStatus,
            newValue: bookingStatus,
        });
        return this.bookingQueryService.findOne(id);
    }
    async updateLoyaltyAndWallet(bookingId, loyaltyPointsRedeemed = 0, walletAmountUsed = 0) {
        const booking = await this.bookingQueryService.findOne(bookingId);
        await this.bookingRepository.save(booking);
        await this.bookingTimelineService.createTimelineEvent(bookingId, booking_timeline_entity_1.TimelineEventType.LOYALTY_UPDATED, {
            title: 'Loyalty Points and Wallet Updated',
            description: `Loyalty points redeemed: ${loyaltyPointsRedeemed}, Wallet amount used: $${walletAmountUsed}`,
            metadata: { loyaltyPointsRedeemed, walletAmountUsed }
        });
        return this.bookingQueryService.findOne(bookingId);
    }
    async getBookingSummary(bookingId) {
        return this.bookingQueryService.getBookingSummary(bookingId);
    }
    async updatePaymentStatus(id, paymentStatus) {
        return this.bookingPaymentService.updatePaymentStatus(id, paymentStatus);
    }
    async cancel(id, userId) {
        const booking = await this.bookingQueryService.findOne(id);
        if (booking.userId !== userId) {
            throw new common_1.BadRequestException('You can only cancel your own bookings');
        }
        if (!booking.canBeCancelled) {
            throw new common_1.BadRequestException('This booking cannot be cancelled');
        }
        const oldStatus = booking.bookingStatus;
        booking.bookingStatus = booking_entity_1.BookingStatus.CANCELLED;
        await this.bookingRepository.save(booking);
        await this.bookingTimelineService.createTimelineEvent(id, booking_timeline_entity_1.TimelineEventType.BOOKING_CANCELLED, {
            title: 'Booking Cancelled',
            description: `Booking cancelled by user. Previous status: ${oldStatus}`,
            oldValue: oldStatus,
            newValue: booking_entity_1.BookingStatus.CANCELLED,
        });
        return this.bookingQueryService.findOne(id);
    }
    async remove(id) {
        const booking = await this.bookingQueryService.findOne(id);
        await this.bookingRepository.remove(booking);
    }
    generateBookingId() {
        const now = new Date();
        const day = String(now.getDate()).padStart(2, '0');
        const month = now.toLocaleString('en-US', { month: 'short' }).toUpperCase();
        const year = String(now.getFullYear()).slice(-2);
        const hour = String(now.getHours()).padStart(2, '0');
        const minute = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        const random = Math.random().toString(36).substring(2, 5).toUpperCase();
        this.bookingCounter = (this.bookingCounter + 1) % 100;
        const counter = String(this.bookingCounter).padStart(2, '0');
        return `BK-${day}${month}${year}-${hour}${minute}${seconds}-${random}${counter}`;
    }
    generateBookingReference() {
        const prefix = 'AC';
        const timestamp = Date.now().toString().slice(-6);
        const random = Math.random().toString(36).substring(2, 5).toUpperCase();
        return `${prefix}${timestamp}${random}`;
    }
    calculateAge(dateOfBirth) {
        try {
            const today = new Date();
            const birthDate = new Date(dateOfBirth);
            if (isNaN(birthDate.getTime())) {
                console.log('ðŸ” DEBUG: Invalid date of birth, returning default age 25');
                return 25;
            }
            let age = today.getFullYear() - birthDate.getFullYear();
            const monthDiff = today.getMonth() - birthDate.getMonth();
            if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
                age--;
            }
            if (age < 0 || age > 120) {
                console.log('ðŸ” DEBUG: Unreasonable age calculated, returning default age 25');
                return 25;
            }
            return age;
        }
        catch (error) {
            console.log('ðŸ” DEBUG: Error calculating age, returning default age 25:', error);
            return 25;
        }
    }
    async getBookingStats(userId) {
        return this.bookingQueryService.getBookingStats(userId);
    }
    async confirmBooking(id, userId, paymentTransactionId) {
        const booking = await this.bookingQueryService.findOne(id);
        if (booking.userId !== userId) {
            throw new common_1.BadRequestException('You can only confirm your own bookings');
        }
        if (booking.bookingStatus !== booking_entity_1.BookingStatus.PENDING) {
            throw new common_1.BadRequestException('Booking is not in pending status');
        }
        if (booking.paymentStatus !== booking_entity_1.PaymentStatus.PENDING) {
            throw new common_1.BadRequestException('Payment is not in pending status');
        }
        const updatedBooking = await this.bookingPaymentService.processPayment(id, paymentTransactionId, 'card', booking.totalPrice);
        const confirmationEmail = this.generateConfirmationEmail(updatedBooking);
        try {
            await this.emailService.sendBookingConfirmationEmail(updatedBooking.user.email, {
                referenceNumber: updatedBooking.referenceNumber,
                passengerName: `${updatedBooking.user.first_name} ${updatedBooking.user.last_name}`,
                departure: updatedBooking.deal.originName,
                destination: updatedBooking.deal.destinationName,
                date: updatedBooking.deal.date.toLocaleDateString(),
                time: updatedBooking.deal.time,
                aircraft: updatedBooking.deal.aircraft.name,
                company: updatedBooking.deal.company.companyName,
                totalAmount: updatedBooking.totalPrice,
            });
        }
        catch (error) {
            console.error('Failed to send booking confirmation email:', error);
        }
        return {
            id: updatedBooking.id,
            referenceNumber: updatedBooking.referenceNumber,
            bookingStatus: updatedBooking.bookingStatus,
            paymentStatus: updatedBooking.paymentStatus,
            confirmationEmail,
        };
    }
    async findPendingPaymentBookings(userId) {
        return this.bookingQueryService.findPendingPaymentBookings(userId);
    }
    generateConfirmationEmail(booking) {
        return `
      Dear ${booking.user.first_name} ${booking.user.last_name},
      
      Your booking has been confirmed!
      
      Booking Reference: ${booking.referenceNumber}
      Date: ${booking.deal.date}
      Time: ${booking.deal.time}
      Aircraft: ${booking.deal.aircraft.name}
      Company: ${booking.deal.company.companyName}
      
      Total Amount: $${booking.totalPrice}
      
      Please arrive 30 minutes before departure time.
      
      Thank you for choosing our service!
    `;
    }
    async getBookingTimeline(bookingId) {
        return this.bookingTimelineService.getBookingTimeline(bookingId);
    }
    async getBookingStatusByReference(referenceNumber) {
        return this.bookingQueryService.getBookingStatusByReference(referenceNumber);
    }
    async confirmBookingAfterPayment(bookingId, paymentReference) {
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            const booking = await queryRunner.manager.findOne(booking_entity_1.Booking, {
                where: { id: parseInt(bookingId) }
            });
            if (!booking) {
                throw new common_1.NotFoundException(`Booking with ID ${bookingId} not found`);
            }
            booking.bookingStatus = booking_entity_1.BookingStatus.CONFIRMED;
            booking.paymentStatus = booking_entity_1.PaymentStatus.PAID;
            booking.updatedAt = new Date();
            const updatedBooking = await queryRunner.manager.save(booking);
            await this.bookingTimelineService.createTimelineEvent(bookingId, booking_timeline_entity_1.TimelineEventType.PAYMENT_COMPLETED, {
                title: 'Payment Confirmed',
                description: 'Payment confirmed and booking confirmed',
                newValue: 'confirmed',
            });
            await this.createUserTripAfterPayment(updatedBooking, queryRunner);
            await queryRunner.commitTransaction();
            try {
                const user = await this.dataSource.getRepository(user_entity_1.User).findOne({
                    where: { id: updatedBooking.userId },
                    select: ['email', 'first_name', 'last_name']
                });
                if (user) {
                    await this.emailService.sendBookingConfirmationEmail(user.email, {
                        referenceNumber: updatedBooking.referenceNumber,
                        passengerName: `${user.first_name} ${user.last_name}`,
                        departure: updatedBooking.originName,
                        destination: updatedBooking.destinationName,
                        date: new Date(updatedBooking.departureDateTime).toLocaleDateString(),
                        time: new Date(updatedBooking.departureDateTime).toLocaleTimeString(),
                        aircraft: 'Private Aircraft',
                        company: 'Charter Company',
                        totalAmount: updatedBooking.totalPrice,
                    });
                }
            }
            catch (emailError) {
                console.error('Failed to send confirmation email:', emailError);
            }
            return updatedBooking;
        }
        catch (error) {
            await queryRunner.rollbackTransaction();
            throw error;
        }
        finally {
            await queryRunner.release();
        }
    }
    async createUserTripAfterPayment(booking, queryRunner) {
        try {
            const existingTrip = await queryRunner.manager.findOne(user_trips_entity_1.UserTrip, {
                where: { bookingId: booking.id.toString() }
            });
            if (existingTrip) {
                console.log(`UserTrip already exists for booking ${booking.id}`);
                return;
            }
            const userTrip = queryRunner.manager.create(user_trips_entity_1.UserTrip, {
                id: `trip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                userId: booking.userId,
                bookingId: booking.id.toString(),
                status: 'upcoming',
                createdAt: new Date(),
                updatedAt: new Date(),
            });
            await queryRunner.manager.save(userTrip);
            console.log(`Created UserTrip for booking ${booking.id}`);
        }
        catch (error) {
            console.error(`Failed to create UserTrip for booking ${booking.id}:`, error);
        }
    }
    async createPaymentIntentForInquiry(bookingId) {
        const booking = await this.findOne(bookingId);
        if (!booking) {
            throw new common_1.NotFoundException(`Booking with ID ${bookingId} not found`);
        }
        if (booking.totalPrice <= 0) {
            throw new common_1.BadRequestException('Booking has no price set. Please contact support.');
        }
        if (booking.paymentStatus === booking_entity_1.PaymentStatus.PAID) {
            throw new common_1.BadRequestException('Booking is already paid');
        }
        try {
            const paymentIntent = await this.paymentProviderService.createPaymentIntent({
                amount: booking.totalPrice,
                currency: 'USD',
                bookingId: booking.id.toString(),
                userId: booking.userId,
                description: `Payment for booking ${booking.referenceNumber}`,
                metadata: {
                    bookingId: booking.id.toString(),
                    referenceNumber: booking.referenceNumber,
                    dealId: booking.dealId,
                    company_id: booking.companyId,
                    bookingType: booking.dealId ? 'deal_booking' : 'direct_charter',
                },
            }, payment_provider_interface_1.PaymentProviderType.PAYSTACK);
            return {
                paymentIntent: {
                    id: paymentIntent.id,
                    clientSecret: paymentIntent.clientSecret,
                    status: paymentIntent.status,
                    requiresAction: paymentIntent.requiresAction,
                    nextAction: paymentIntent.nextAction,
                },
                booking: {
                    id: booking.id,
                    totalPrice: booking.totalPrice,
                    referenceNumber: booking.referenceNumber,
                },
                paymentInstructions: {
                    amount: booking.totalPrice,
                    currency: 'USD',
                    paymentMethods: ['card', 'apple_pay', 'google_pay', 'bank_transfer'],
                    nextSteps: [
                        'Complete payment using the client secret',
                        'Confirm payment using /payments/confirm',
                        'Booking will be automatically confirmed'
                    ],
                    apiEndpoints: {
                        confirmPayment: `/payments/confirm`,
                        bookingConfirmation: `/bookings/${booking.id}/confirm-payment`,
                        paymentStatus: `/payments/status/${paymentIntent.id}`
                    }
                }
            };
        }
        catch (error) {
            console.error('Failed to create payment intent for inquiry:', error);
            throw new common_1.BadRequestException(`Payment setup failed: ${error.message}`);
        }
    }
};
exports.BookingsService = BookingsService;
exports.BookingsService = BookingsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(booking_entity_1.Booking)),
    __param(1, (0, typeorm_1.InjectRepository)(charter_deal_entity_1.CharterDeal)),
    __param(2, (0, typeorm_1.InjectRepository)(experience_schedule_entity_1.ExperienceSchedule)),
    __param(3, (0, typeorm_1.InjectRepository)(passenger_entity_1.Passenger)),
    __param(4, (0, typeorm_1.InjectRepository)(booking_timeline_entity_1.BookingTimeline)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object, typeof (_d = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _d : Object, typeof (_e = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _e : Object, typeof (_f = typeof typeorm_2.DataSource !== "undefined" && typeorm_2.DataSource) === "function" ? _f : Object, typeof (_g = typeof booking_payment_service_1.BookingPaymentService !== "undefined" && booking_payment_service_1.BookingPaymentService) === "function" ? _g : Object, typeof (_h = typeof booking_timeline_service_1.BookingTimelineService !== "undefined" && booking_timeline_service_1.BookingTimelineService) === "function" ? _h : Object, typeof (_j = typeof booking_query_service_1.BookingQueryService !== "undefined" && booking_query_service_1.BookingQueryService) === "function" ? _j : Object, typeof (_k = typeof payment_provider_service_1.PaymentProviderService !== "undefined" && payment_provider_service_1.PaymentProviderService) === "function" ? _k : Object, typeof (_l = typeof email_service_1.EmailService !== "undefined" && email_service_1.EmailService) === "function" ? _l : Object])
], BookingsService);


/***/ }),
/* 74 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BookingTimeline = exports.TimelineEventType = void 0;
const typeorm_1 = __webpack_require__(13);
const booking_entity_1 = __webpack_require__(29);
var TimelineEventType;
(function (TimelineEventType) {
    TimelineEventType["BOOKING_CREATED"] = "booking_created";
    TimelineEventType["STATUS_CHANGED"] = "status_changed";
    TimelineEventType["PAYMENT_STATUS_CHANGED"] = "payment_status_changed";
    TimelineEventType["PAYMENT_COMPLETED"] = "payment_completed";
    TimelineEventType["BOOKING_CANCELLED"] = "booking_cancelled";
    TimelineEventType["BOOKING_CONFIRMED"] = "booking_confirmed";
    TimelineEventType["REMINDER_SENT"] = "reminder_sent";
    TimelineEventType["CHECK_IN"] = "check_in";
    TimelineEventType["FLIGHT_COMPLETED"] = "flight_completed";
    TimelineEventType["LOYALTY_UPDATED"] = "loyalty_updated";
})(TimelineEventType || (exports.TimelineEventType = TimelineEventType = {}));
let BookingTimeline = class BookingTimeline {
};
exports.BookingTimeline = BookingTimeline;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], BookingTimeline.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'bookingId' }),
    __metadata("design:type", Number)
], BookingTimeline.prototype, "bookingId", void 0);
__decorate([
    (0, typeorm_1.Column)({
        name: 'eventType',
        type: 'enum',
        enum: TimelineEventType
    }),
    __metadata("design:type", String)
], BookingTimeline.prototype, "eventType", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'title', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], BookingTimeline.prototype, "title", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'description', type: 'text', nullable: true }),
    __metadata("design:type", String)
], BookingTimeline.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'oldValue', type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], BookingTimeline.prototype, "oldValue", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'newValue', type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], BookingTimeline.prototype, "newValue", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'metadata', type: 'json', nullable: true }),
    __metadata("design:type", Object)
], BookingTimeline.prototype, "metadata", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], BookingTimeline.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => booking_entity_1.Booking, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'bookingId' }),
    __metadata("design:type", typeof (_b = typeof booking_entity_1.Booking !== "undefined" && booking_entity_1.Booking) === "function" ? _b : Object)
], BookingTimeline.prototype, "booking", void 0);
exports.BookingTimeline = BookingTimeline = __decorate([
    (0, typeorm_1.Entity)('booking_timeline')
], BookingTimeline);


/***/ }),
/* 75 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BookingPaymentService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const booking_entity_1 = __webpack_require__(29);
const booking_timeline_entity_1 = __webpack_require__(74);
const wallet_transaction_entity_1 = __webpack_require__(28);
const user_entity_1 = __webpack_require__(14);
const payment_entity_1 = __webpack_require__(76);
const user_trips_entity_1 = __webpack_require__(77);
const wallet_service_1 = __webpack_require__(78);
let BookingPaymentService = class BookingPaymentService {
    constructor(bookingRepository, timelineRepository, walletTransactionRepository, userRepository, paymentRepository, userTripRepository, walletService, dataSource) {
        this.bookingRepository = bookingRepository;
        this.timelineRepository = timelineRepository;
        this.walletTransactionRepository = walletTransactionRepository;
        this.userRepository = userRepository;
        this.paymentRepository = paymentRepository;
        this.userTripRepository = userTripRepository;
        this.walletService = walletService;
        this.dataSource = dataSource;
    }
    async processPayment(bookingId, paymentTransactionId, paymentMethod, amount) {
        const maxRetries = 3;
        let lastError;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await this.processPaymentAttempt(bookingId, paymentTransactionId, paymentMethod, amount);
            }
            catch (error) {
                lastError = error;
                if (error.message && error.message.includes('Lock wait timeout exceeded')) {
                    if (attempt < maxRetries) {
                        const delay = Math.pow(2, attempt - 1) * 1000;
                        console.log(`Lock timeout on attempt ${attempt}, retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                }
                throw error;
            }
        }
        throw lastError;
    }
    async processPaymentAttempt(bookingId, paymentTransactionId, paymentMethod, amount) {
        const existingBooking = await this.bookingRepository.findOne({
            where: { id: parseInt(bookingId) },
            relations: ['user'],
        });
        if (!existingBooking) {
            throw new common_1.BadRequestException('Booking not found');
        }
        if (existingBooking.paymentStatus === booking_entity_1.PaymentStatus.PAID) {
            throw new common_1.BadRequestException('Payment already processed');
        }
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            const booking = await queryRunner.manager.findOne(booking_entity_1.Booking, {
                where: { id: parseInt(bookingId) },
                relations: ['user'],
                lock: { mode: 'pessimistic_write' },
            });
            if (!booking) {
                throw new common_1.BadRequestException('Booking not found');
            }
            if (booking.paymentStatus === booking_entity_1.PaymentStatus.PAID) {
                throw new common_1.BadRequestException('Payment already processed');
            }
            booking.paymentStatus = booking_entity_1.PaymentStatus.PAID;
            booking.bookingStatus = booking_entity_1.BookingStatus.CONFIRMED;
            const loyaltyPointsToEarn = Math.floor(amount * 5);
            await queryRunner.manager.save(booking);
            const payment = queryRunner.manager.create(payment_entity_1.Payment, {
                userId: booking.userId,
                companyId: booking.companyId,
                bookingId: booking.id.toString(),
                paymentMethod: this.mapPaymentMethod(paymentMethod),
                totalAmount: amount,
                platformFee: Math.floor(amount * 0.05),
                companyAmount: amount - Math.floor(amount * 0.05),
                currency: 'USD',
                transactionId: paymentTransactionId,
                paymentStatus: payment_entity_1.PaymentStatus.COMPLETED,
            });
            await queryRunner.manager.save(payment);
            const userTrip = queryRunner.manager.create(user_trips_entity_1.UserTrip, {
                userId: booking.userId,
                bookingId: booking.id.toString(),
                status: user_trips_entity_1.UserTripStatus.UPCOMING,
            });
            await queryRunner.manager.save(userTrip);
            await this.createTimelineEvent(bookingId, booking_timeline_entity_1.TimelineEventType.PAYMENT_STATUS_CHANGED, {
                title: 'Payment Processed',
                description: `Payment of $${amount} processed successfully. ${loyaltyPointsToEarn} loyalty points earned.`,
                newValue: booking_entity_1.PaymentStatus.PAID,
                metadata: {
                    paymentTransactionId,
                    paymentMethod,
                    amount,
                    loyaltyPointsEarned: loyaltyPointsToEarn,
                    referenceNumber: booking.referenceNumber,
                },
            }, queryRunner);
            await this.createTimelineEvent(bookingId, booking_timeline_entity_1.TimelineEventType.BOOKING_CONFIRMED, {
                title: 'Booking Confirmed',
                description: `Booking confirmed after successful payment. Reference: ${booking.referenceNumber}`,
                metadata: {
                    paymentTransactionId,
                    referenceNumber: booking.referenceNumber,
                },
            }, queryRunner);
            await queryRunner.commitTransaction();
            if (loyaltyPointsToEarn > 0) {
                try {
                    await this.walletService.earnLoyaltyPoints(booking.userId, loyaltyPointsToEarn, `Booking ${booking.referenceNumber} - Earned ${loyaltyPointsToEarn} miles from $${amount} payment`, bookingId);
                }
                catch (walletError) {
                    console.error('Failed to process loyalty points:', walletError);
                }
            }
            return booking;
        }
        catch (error) {
            if (queryRunner.isTransactionActive) {
                await queryRunner.rollbackTransaction();
            }
            throw error;
        }
        finally {
            await queryRunner.release();
        }
    }
    async updatePaymentStatus(bookingId, paymentStatus, paymentTransactionId) {
        const booking = await this.bookingRepository.findOne({
            where: { id: parseInt(bookingId) },
        });
        if (!booking) {
            throw new common_1.BadRequestException('Booking not found');
        }
        const oldPaymentStatus = booking.paymentStatus;
        booking.paymentStatus = paymentStatus;
        if (paymentTransactionId) {
        }
        if (paymentStatus === booking_entity_1.PaymentStatus.PAID && booking.bookingStatus === booking_entity_1.BookingStatus.PENDING) {
            booking.bookingStatus = booking_entity_1.BookingStatus.CONFIRMED;
        }
        await this.bookingRepository.save(booking);
        await this.createTimelineEvent(bookingId, booking_timeline_entity_1.TimelineEventType.PAYMENT_STATUS_CHANGED, {
            title: 'Payment Status Updated',
            description: `Payment status changed from ${oldPaymentStatus} to ${paymentStatus}`,
            oldValue: oldPaymentStatus,
            newValue: paymentStatus,
            metadata: { paymentTransactionId },
        });
        return booking;
    }
    async processRefund(bookingId, refundAmount, refundReason) {
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            const booking = await queryRunner.manager.findOne(booking_entity_1.Booking, {
                where: { id: parseInt(bookingId) },
                relations: ['user'],
            });
            if (!booking) {
                throw new common_1.BadRequestException('Booking not found');
            }
            const refundRatio = refundAmount / booking.totalPrice;
            booking.bookingStatus = booking_entity_1.BookingStatus.CANCELLED;
            booking.paymentStatus = booking_entity_1.PaymentStatus.REFUNDED;
            await queryRunner.manager.save(booking);
            await this.createTimelineEvent(bookingId, booking_timeline_entity_1.TimelineEventType.PAYMENT_STATUS_CHANGED, {
                title: 'Refund Processed',
                description: `Refund of $${refundAmount} processed.`,
                newValue: booking_entity_1.PaymentStatus.REFUNDED,
                metadata: {
                    refundAmount,
                    refundReason,
                },
            }, queryRunner);
            await queryRunner.commitTransaction();
            return booking;
        }
        catch (error) {
            if (queryRunner.isTransactionActive) {
                await queryRunner.rollbackTransaction();
            }
            throw error;
        }
        finally {
            await queryRunner.release();
        }
    }
    generateBookingReference() {
        const prefix = 'AC';
        const timestamp = Date.now().toString().slice(-6);
        const random = Math.random().toString(36).substring(2, 5).toUpperCase();
        return `${prefix}${timestamp}${random}`;
    }
    async createTimelineEvent(bookingId, eventType, data, queryRunner) {
        const timelineEvent = queryRunner
            ? queryRunner.manager.create(booking_timeline_entity_1.BookingTimeline, {
                bookingId: parseInt(bookingId),
                eventType,
                title: data.title,
                description: data.description,
                oldValue: data.oldValue,
                newValue: data.newValue,
                metadata: data.metadata,
                createdAt: new Date(),
            })
            : this.timelineRepository.create({
                bookingId: parseInt(bookingId),
                eventType,
                title: data.title,
                description: data.description,
                oldValue: data.oldValue,
                newValue: data.newValue,
                metadata: data.metadata,
                createdAt: new Date(),
            });
        if (queryRunner) {
            await queryRunner.manager.save(timelineEvent);
        }
        else {
            await this.timelineRepository.save(timelineEvent);
        }
    }
    mapPaymentMethod(paymentMethod) {
        switch (paymentMethod.toLowerCase()) {
            case 'card':
            case 'credit_card':
            case 'debit_card':
                return payment_entity_1.PaymentMethod.CARD;
            case 'mpesa':
                return payment_entity_1.PaymentMethod.MPESA;
            case 'wallet':
                return payment_entity_1.PaymentMethod.WALLET;
            default:
                return payment_entity_1.PaymentMethod.CARD;
        }
    }
};
exports.BookingPaymentService = BookingPaymentService;
exports.BookingPaymentService = BookingPaymentService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(booking_entity_1.Booking)),
    __param(1, (0, typeorm_1.InjectRepository)(booking_timeline_entity_1.BookingTimeline)),
    __param(2, (0, typeorm_1.InjectRepository)(wallet_transaction_entity_1.WalletTransaction)),
    __param(3, (0, typeorm_1.InjectRepository)(user_entity_1.User)),
    __param(4, (0, typeorm_1.InjectRepository)(payment_entity_1.Payment)),
    __param(5, (0, typeorm_1.InjectRepository)(user_trips_entity_1.UserTrip)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object, typeof (_d = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _d : Object, typeof (_e = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _e : Object, typeof (_f = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _f : Object, typeof (_g = typeof wallet_service_1.WalletService !== "undefined" && wallet_service_1.WalletService) === "function" ? _g : Object, typeof (_h = typeof typeorm_2.DataSource !== "undefined" && typeorm_2.DataSource) === "function" ? _h : Object])
], BookingPaymentService);


/***/ }),
/* 76 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Payment = exports.PaymentStatus = exports.PaymentMethod = void 0;
const typeorm_1 = __webpack_require__(13);
const user_entity_1 = __webpack_require__(14);
const charters_company_entity_1 = __webpack_require__(31);
var PaymentMethod;
(function (PaymentMethod) {
    PaymentMethod["CARD"] = "card";
    PaymentMethod["MPESA"] = "mpesa";
    PaymentMethod["WALLET"] = "wallet";
})(PaymentMethod || (exports.PaymentMethod = PaymentMethod = {}));
var PaymentStatus;
(function (PaymentStatus) {
    PaymentStatus["PENDING"] = "pending";
    PaymentStatus["COMPLETED"] = "completed";
    PaymentStatus["FAILED"] = "failed";
    PaymentStatus["REFUNDED"] = "refunded";
})(PaymentStatus || (exports.PaymentStatus = PaymentStatus = {}));
let Payment = class Payment {
    get formattedAmount() {
        return `${this.currency} ${this.totalAmount.toFixed(2)}`;
    }
    get isCompleted() {
        return this.paymentStatus === PaymentStatus.COMPLETED;
    }
    get canBeRefunded() {
        return this.paymentStatus === PaymentStatus.COMPLETED;
    }
};
exports.Payment = Payment;
__decorate([
    (0, typeorm_1.PrimaryColumn)(),
    __metadata("design:type", String)
], Payment.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'bookingId' }),
    __metadata("design:type", String)
], Payment.prototype, "bookingId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'userId' }),
    __metadata("design:type", String)
], Payment.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'company_id', nullable: true }),
    __metadata("design:type", Number)
], Payment.prototype, "companyId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'paymentMethod', type: 'enum', enum: PaymentMethod }),
    __metadata("design:type", String)
], Payment.prototype, "paymentMethod", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'totalAmount', type: 'decimal', precision: 10, scale: 2 }),
    __metadata("design:type", Number)
], Payment.prototype, "totalAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'platformFee', type: 'decimal', precision: 10, scale: 2 }),
    __metadata("design:type", Number)
], Payment.prototype, "platformFee", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'companyAmount', type: 'decimal', precision: 10, scale: 2 }),
    __metadata("design:type", Number)
], Payment.prototype, "companyAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 3, default: 'USD' }),
    __metadata("design:type", String)
], Payment.prototype, "currency", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'transactionId', nullable: true }),
    __metadata("design:type", String)
], Payment.prototype, "transactionId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'paymentStatus', type: 'enum', enum: PaymentStatus, default: PaymentStatus.PENDING }),
    __metadata("design:type", String)
], Payment.prototype, "paymentStatus", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'paymentGatewayResponse', type: 'json', nullable: true }),
    __metadata("design:type", Object)
], Payment.prototype, "paymentGatewayResponse", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Payment.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Payment.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_c = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _c : Object)
], Payment.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => charters_company_entity_1.ChartersCompany),
    (0, typeorm_1.JoinColumn)({ name: 'company_id' }),
    __metadata("design:type", typeof (_d = typeof charters_company_entity_1.ChartersCompany !== "undefined" && charters_company_entity_1.ChartersCompany) === "function" ? _d : Object)
], Payment.prototype, "company", void 0);
exports.Payment = Payment = __decorate([
    (0, typeorm_1.Entity)('payments')
], Payment);


/***/ }),
/* 77 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserTrip = exports.UserTripStatus = void 0;
const typeorm_1 = __webpack_require__(13);
const user_entity_1 = __webpack_require__(14);
const booking_entity_1 = __webpack_require__(29);
var UserTripStatus;
(function (UserTripStatus) {
    UserTripStatus["UPCOMING"] = "upcoming";
    UserTripStatus["COMPLETED"] = "completed";
    UserTripStatus["CANCELLED"] = "cancelled";
})(UserTripStatus || (exports.UserTripStatus = UserTripStatus = {}));
let UserTrip = class UserTrip {
    get calculatedStatus() {
        if (this.status === UserTripStatus.CANCELLED) {
            return UserTripStatus.CANCELLED;
        }
        if (this.booking?.bookingStatus === booking_entity_1.BookingStatus.CANCELLED) {
            return UserTripStatus.CANCELLED;
        }
        if (this.booking?.bookingStatus === booking_entity_1.BookingStatus.CONFIRMED) {
            const flightDate = new Date(this.booking.deal?.date);
            const now = new Date();
            if (flightDate < now) {
                return UserTripStatus.COMPLETED;
            }
            else {
                return UserTripStatus.UPCOMING;
            }
        }
        return UserTripStatus.UPCOMING;
    }
    get needsStatusUpdate() {
        return this.calculatedStatus !== this.status;
    }
};
exports.UserTrip = UserTrip;
__decorate([
    (0, typeorm_1.PrimaryColumn)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], UserTrip.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'user_id', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], UserTrip.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'booking_id' }),
    __metadata("design:type", String)
], UserTrip.prototype, "bookingId", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: UserTripStatus }),
    __metadata("design:type", String)
], UserTrip.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], UserTrip.prototype, "rating", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], UserTrip.prototype, "review", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'review_date', type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], UserTrip.prototype, "reviewDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], UserTrip.prototype, "photos", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], UserTrip.prototype, "videos", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'created_at' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], UserTrip.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'completed_at', type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], UserTrip.prototype, "completedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'cancelled_at', type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], UserTrip.prototype, "cancelledAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, user => user.id),
    (0, typeorm_1.JoinColumn)({ name: 'user_id' }),
    __metadata("design:type", typeof (_e = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _e : Object)
], UserTrip.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => booking_entity_1.Booking, booking => booking.id),
    (0, typeorm_1.JoinColumn)({ name: 'booking_id' }),
    __metadata("design:type", typeof (_f = typeof booking_entity_1.Booking !== "undefined" && booking_entity_1.Booking) === "function" ? _f : Object)
], UserTrip.prototype, "booking", void 0);
exports.UserTrip = UserTrip = __decorate([
    (0, typeorm_1.Entity)('user_trips')
], UserTrip);


/***/ }),
/* 78 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WalletService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const wallet_transaction_entity_1 = __webpack_require__(28);
const user_entity_1 = __webpack_require__(14);
let WalletService = class WalletService {
    constructor(walletTransactionRepository, userRepository) {
        this.walletTransactionRepository = walletTransactionRepository;
        this.userRepository = userRepository;
        this.MILES_PER_USD = 5;
        this.USD_PER_100_MILES = 1;
        this.MILES_PER_DOLLAR_OFF = 100;
    }
    calculateMilesFromSpending(usdAmount) {
        return Math.floor(usdAmount * this.MILES_PER_USD);
    }
    calculateUsdFromMiles(miles) {
        return (miles / this.MILES_PER_DOLLAR_OFF) * this.USD_PER_100_MILES;
    }
    calculateMilesForUsdDiscount(usdDiscount) {
        return Math.ceil(usdDiscount * this.MILES_PER_DOLLAR_OFF / this.USD_PER_100_MILES);
    }
    async getUserTransactions(userId, page = 1, limit = 10) {
        const [transactions, total] = await this.walletTransactionRepository.findAndCount({
            where: { userId },
            order: { createdAt: 'DESC' },
            skip: (page - 1) * limit,
            take: limit,
        });
        return {
            transactions: transactions.map(tx => ({
                id: tx.id,
                type: tx.transactionType,
                amount: tx.amount,
                pointsAmount: tx.pointsAmount,
                description: tx.description,
                status: tx.status,
                createdAt: tx.createdAt,
                bookingId: tx.bookingId,
            })),
            total,
            page,
            limit,
        };
    }
    async getLoyaltyTransactions(userId, page = 1, limit = 10) {
        const [transactions, total] = await this.walletTransactionRepository.findAndCount({
            where: {
                userId,
                transactionType: (0, typeorm_2.In)([
                    wallet_transaction_entity_1.WalletTransactionType.LOYALTY_EARNED,
                    wallet_transaction_entity_1.WalletTransactionType.LOYALTY_REDEEMED,
                    wallet_transaction_entity_1.WalletTransactionType.LOYALTY_EXPIRED,
                    wallet_transaction_entity_1.WalletTransactionType.LOYALTY_ADJUSTMENT,
                ]),
            },
            order: { createdAt: 'DESC' },
            skip: (page - 1) * limit,
            take: limit,
        });
        return {
            transactions: transactions.map(tx => ({
                id: tx.id,
                type: tx.transactionType,
                pointsAmount: tx.pointsAmount,
                description: tx.description,
                pointsBefore: tx.pointsBefore,
                pointsAfter: tx.pointsAfter,
                createdAt: tx.createdAt,
                expiresAt: tx.expiresAt,
            })),
            total,
            page,
            limit,
        };
    }
    async getMonetaryTransactions(userId, page = 1, limit = 10) {
        const [transactions, total] = await this.walletTransactionRepository.findAndCount({
            where: {
                userId,
                transactionType: (0, typeorm_2.In)([
                    wallet_transaction_entity_1.WalletTransactionType.DEPOSIT,
                    wallet_transaction_entity_1.WalletTransactionType.WITHDRAWAL,
                    wallet_transaction_entity_1.WalletTransactionType.PAYMENT,
                    wallet_transaction_entity_1.WalletTransactionType.REFUND,
                    wallet_transaction_entity_1.WalletTransactionType.BONUS,
                    wallet_transaction_entity_1.WalletTransactionType.FEE,
                ]),
            },
            order: { createdAt: 'DESC' },
            skip: (page - 1) * limit,
            take: limit,
        });
        return {
            transactions: transactions.map(tx => ({
                id: tx.id,
                type: tx.transactionType,
                amount: tx.amount,
                currency: tx.currency,
                description: tx.description,
                balanceBefore: tx.balanceBefore,
                balanceAfter: tx.balanceAfter,
                paymentMethod: tx.paymentMethod,
                status: tx.status,
                createdAt: tx.createdAt,
                completedAt: tx.completedAt,
            })),
            total,
            page,
            limit,
        };
    }
    async earnLoyaltyPointsFromSpending(userId, usdAmount, description, bookingId, expiresAt) {
        const milesEarned = this.calculateMilesFromSpending(usdAmount);
        if (milesEarned <= 0) {
            throw new Error('No miles earned from this transaction');
        }
        return await this.earnLoyaltyPoints(userId, milesEarned, `${description} - Earned ${milesEarned} miles from $${usdAmount} spending`, bookingId, expiresAt);
    }
    async earnLoyaltyPoints(userId, points, description, bookingId, expiresAt) {
        const queryRunner = this.walletTransactionRepository.manager.connection.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            const user = await queryRunner.manager.findOne(user_entity_1.User, {
                where: { id: userId },
                lock: { mode: 'pessimistic_write' },
            });
            if (!user) {
                throw new common_1.NotFoundException('User not found');
            }
            const transaction = queryRunner.manager.create(wallet_transaction_entity_1.WalletTransaction, {
                id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                userId,
                bookingId,
                transactionType: wallet_transaction_entity_1.WalletTransactionType.LOYALTY_EARNED,
                amount: 0,
                pointsAmount: points,
                description,
                balanceBefore: user.wallet_balance,
                balanceAfter: user.wallet_balance,
                pointsBefore: user.loyalty_points,
                pointsAfter: user.loyalty_points + points,
                status: wallet_transaction_entity_1.WalletTransactionStatus.COMPLETED,
                expiresAt,
                completedAt: new Date(),
            });
            user.loyalty_points = transaction.pointsAfter;
            await queryRunner.manager.save(user);
            const savedTransaction = await queryRunner.manager.save(transaction);
            await queryRunner.commitTransaction();
            return savedTransaction;
        }
        catch (error) {
            if (queryRunner.isTransactionActive) {
                await queryRunner.rollbackTransaction();
            }
            throw error;
        }
        finally {
            await queryRunner.release();
        }
    }
    async redeemLoyaltyPoints(userId, miles, description, bookingId) {
        const user = await this.userRepository.findOne({ where: { id: userId } });
        if (!user) {
            throw new common_1.NotFoundException('User not found');
        }
        if (user.loyalty_points < miles) {
            throw new Error('Insufficient loyalty points');
        }
        const usdDiscount = this.calculateUsdFromMiles(miles);
        if (usdDiscount <= 0) {
            throw new Error('Invalid miles amount for redemption');
        }
        const transaction = this.walletTransactionRepository.create({
            id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            userId,
            bookingId,
            transactionType: wallet_transaction_entity_1.WalletTransactionType.LOYALTY_REDEEMED,
            amount: usdDiscount,
            pointsAmount: -miles,
            description: `${description} - Redeemed ${miles} miles for $${usdDiscount} discount`,
            balanceBefore: user.wallet_balance,
            balanceAfter: user.wallet_balance + usdDiscount,
            pointsBefore: user.loyalty_points,
            pointsAfter: user.loyalty_points - miles,
            status: wallet_transaction_entity_1.WalletTransactionStatus.COMPLETED,
            completedAt: new Date(),
        });
        user.loyalty_points = transaction.pointsAfter;
        user.wallet_balance = transaction.balanceAfter;
        await this.userRepository.save(user);
        return await this.walletTransactionRepository.save(transaction);
    }
    async getLoyaltySummary(userId) {
        const user = await this.userRepository.findOne({ where: { id: userId } });
        if (!user) {
            throw new common_1.NotFoundException('User not found');
        }
        const currentMiles = user.loyalty_points;
        const potentialUsdDiscount = this.calculateUsdFromMiles(currentMiles);
        const milesNeededForNextDollar = this.MILES_PER_DOLLAR_OFF - (currentMiles % this.MILES_PER_DOLLAR_OFF);
        return {
            currentMiles,
            potentialUsdDiscount,
            milesNeededForNextDollar,
            conversionRates: {
                milesPerUsd: this.MILES_PER_USD,
                usdPer100Miles: this.USD_PER_100_MILES,
            },
            examples: {
                spending10Usd: this.calculateMilesFromSpending(10),
                spending100Usd: this.calculateMilesFromSpending(100),
                redeeming100Miles: this.calculateUsdFromMiles(100),
                redeeming500Miles: this.calculateUsdFromMiles(500),
            },
        };
    }
    async depositMoney(userId, amount, description, paymentMethod, paymentReference) {
        const user = await this.userRepository.findOne({ where: { id: userId } });
        if (!user) {
            throw new common_1.NotFoundException('User not found');
        }
        const transaction = this.walletTransactionRepository.create({
            id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            userId,
            transactionType: wallet_transaction_entity_1.WalletTransactionType.DEPOSIT,
            amount,
            pointsAmount: 0,
            description,
            balanceBefore: user.wallet_balance,
            balanceAfter: user.wallet_balance + amount,
            pointsBefore: user.loyalty_points,
            pointsAfter: user.loyalty_points,
            paymentMethod,
            paymentReference,
            status: wallet_transaction_entity_1.WalletTransactionStatus.COMPLETED,
            completedAt: new Date(),
        });
        user.wallet_balance = transaction.balanceAfter;
        await this.userRepository.save(user);
        return await this.walletTransactionRepository.save(transaction);
    }
    async withdrawMoney(userId, amount, description, paymentMethod, paymentReference) {
        const user = await this.userRepository.findOne({ where: { id: userId } });
        if (!user) {
            throw new common_1.NotFoundException('User not found');
        }
        if (user.wallet_balance < amount) {
            throw new Error('Insufficient wallet balance');
        }
        const transaction = this.walletTransactionRepository.create({
            id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            userId,
            transactionType: wallet_transaction_entity_1.WalletTransactionType.WITHDRAWAL,
            amount: -amount,
            pointsAmount: 0,
            description,
            balanceBefore: user.wallet_balance,
            balanceAfter: user.wallet_balance - amount,
            pointsBefore: user.loyalty_points,
            pointsAfter: user.loyalty_points,
            paymentMethod,
            paymentReference,
            status: wallet_transaction_entity_1.WalletTransactionStatus.COMPLETED,
            completedAt: new Date(),
        });
        user.wallet_balance = transaction.balanceAfter;
        await this.userRepository.save(user);
        return await this.walletTransactionRepository.save(transaction);
    }
    async createWalletTransaction(userId, transactionType, amount, pointsAmount, description, bookingId, metadata) {
        const user = await this.userRepository.findOne({ where: { id: userId } });
        if (!user) {
            throw new common_1.NotFoundException('User not found');
        }
        const transaction = this.walletTransactionRepository.create({
            id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            userId,
            bookingId,
            transactionType,
            amount,
            pointsAmount,
            description,
            balanceBefore: user.wallet_balance,
            balanceAfter: user.wallet_balance + amount,
            pointsBefore: user.loyalty_points,
            pointsAfter: user.loyalty_points + pointsAmount,
            status: wallet_transaction_entity_1.WalletTransactionStatus.COMPLETED,
            metadata,
            completedAt: new Date(),
        });
        user.wallet_balance = transaction.balanceAfter;
        user.loyalty_points = transaction.pointsAfter;
        await this.userRepository.save(user);
        return await this.walletTransactionRepository.save(transaction);
    }
};
exports.WalletService = WalletService;
exports.WalletService = WalletService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(wallet_transaction_entity_1.WalletTransaction)),
    __param(1, (0, typeorm_1.InjectRepository)(user_entity_1.User)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object])
], WalletService);


/***/ }),
/* 79 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BookingTimelineService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const booking_timeline_entity_1 = __webpack_require__(74);
let BookingTimelineService = class BookingTimelineService {
    constructor(timelineRepository) {
        this.timelineRepository = timelineRepository;
    }
    async createTimelineEvent(bookingId, eventType, data) {
        const timelineEvent = this.timelineRepository.create({
            bookingId: parseInt(bookingId),
            eventType,
            title: data.title,
            description: data.description,
            oldValue: data.oldValue,
            newValue: data.newValue,
            metadata: data.metadata,
        });
        return await this.timelineRepository.save(timelineEvent);
    }
    async getBookingTimeline(bookingId) {
        return this.timelineRepository
            .createQueryBuilder('timeline')
            .where('timeline.bookingId = :bookingId', { bookingId })
            .orderBy('timeline.createdAt', 'DESC')
            .getMany();
    }
    async getTimelineEventsByType(bookingId, eventType) {
        return this.timelineRepository
            .createQueryBuilder('timeline')
            .where('timeline.bookingId = :bookingId', { bookingId })
            .andWhere('timeline.eventType = :eventType', { eventType })
            .orderBy('timeline.createdAt', 'DESC')
            .getMany();
    }
    async getRecentTimelineEvents(limit = 10) {
        return this.timelineRepository
            .createQueryBuilder('timeline')
            .orderBy('timeline.createdAt', 'DESC')
            .limit(limit)
            .getMany();
    }
    async deleteTimelineEvents(bookingId) {
        await this.timelineRepository
            .createQueryBuilder()
            .delete()
            .where('bookingId = :bookingId', { bookingId })
            .execute();
    }
};
exports.BookingTimelineService = BookingTimelineService;
exports.BookingTimelineService = BookingTimelineService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(booking_timeline_entity_1.BookingTimeline)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], BookingTimelineService);


/***/ }),
/* 80 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BookingQueryService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const booking_entity_1 = __webpack_require__(29);
let BookingQueryService = class BookingQueryService {
    constructor(bookingRepository) {
        this.bookingRepository = bookingRepository;
    }
    async findAll(userId) {
        const query = this.bookingRepository
            .createQueryBuilder('booking')
            .leftJoinAndSelect('booking.passengers', 'passengers')
            .leftJoinAndSelect('booking.user', 'user')
            .leftJoinAndSelect('booking.deal', 'deal')
            .leftJoinAndSelect('booking.company', 'company')
            .leftJoinAndSelect('deal.aircraft', 'aircraft');
        if (userId) {
            query.where('booking.userId = :userId', { userId });
        }
        return query
            .orderBy('booking.createdAt', 'DESC')
            .getMany();
    }
    async findOne(id) {
        const booking = await this.bookingRepository
            .createQueryBuilder('booking')
            .leftJoinAndSelect('booking.passengers', 'passengers')
            .leftJoinAndSelect('booking.user', 'user')
            .leftJoinAndSelect('booking.deal', 'deal')
            .leftJoinAndSelect('booking.company', 'company')
            .leftJoinAndSelect('deal.aircraft', 'aircraft')
            .where('booking.id = :id', { id })
            .getOne();
        if (!booking) {
            throw new common_1.NotFoundException(`Booking with ID ${id} not found`);
        }
        return booking;
    }
    async findByReference(referenceNumber) {
        const booking = await this.bookingRepository
            .createQueryBuilder('booking')
            .leftJoinAndSelect('booking.passengers', 'passengers')
            .leftJoinAndSelect('booking.user', 'user')
            .leftJoinAndSelect('booking.deal', 'deal')
            .leftJoinAndSelect('booking.company', 'company')
            .leftJoinAndSelect('deal.aircraft', 'aircraft')
            .where('booking.referenceNumber = :referenceNumber', { referenceNumber })
            .getOne();
        if (!booking) {
            throw new common_1.NotFoundException(`Booking with reference ${referenceNumber} not found`);
        }
        return booking;
    }
    async findByUserWithFilters(userId, filters) {
        const query = this.bookingRepository
            .createQueryBuilder('booking')
            .leftJoinAndSelect('booking.passengers', 'passengers')
            .leftJoinAndSelect('booking.user', 'user')
            .leftJoinAndSelect('booking.deal', 'deal')
            .leftJoinAndSelect('booking.company', 'company')
            .leftJoinAndSelect('deal.aircraft', 'aircraft')
            .where('booking.userId = :userId', { userId });
        if (filters.upcoming !== undefined) {
            const now = new Date();
            if (filters.upcoming) {
                query.andWhere('deal.date >= :now', { now });
            }
            else {
                query.andWhere('deal.date < :now', { now });
            }
        }
        if (filters.status) {
            query.andWhere('booking.bookingStatus = :status', { status: filters.status });
        }
        return query
            .orderBy('deal.date', 'ASC')
            .addOrderBy('deal.time', 'ASC')
            .getMany();
    }
    async findPendingPaymentBookings(userId) {
        return this.bookingRepository
            .createQueryBuilder('booking')
            .leftJoinAndSelect('booking.passengers', 'passengers')
            .leftJoinAndSelect('booking.deal', 'deal')
            .leftJoinAndSelect('deal.company', 'company')
            .leftJoinAndSelect('deal.aircraft', 'aircraft')
            .where('booking.userId = :userId', { userId })
            .andWhere('booking.paymentStatus = :paymentStatus', {
            paymentStatus: booking_entity_1.PaymentStatus.PENDING
        })
            .andWhere('booking.bookingStatus = :bookingStatus', {
            bookingStatus: booking_entity_1.BookingStatus.PENDING
        })
            .orderBy('booking.createdAt', 'DESC')
            .getMany();
    }
    async getBookingStatusByReference(referenceNumber) {
        const booking = await this.bookingRepository
            .createQueryBuilder('booking')
            .leftJoinAndSelect('booking.deal', 'deal')
            .leftJoinAndSelect('deal.company', 'company')
            .leftJoinAndSelect('deal.aircraft', 'aircraft')
            .leftJoinAndSelect('booking.passengers', 'passengers')
            .where('booking.referenceNumber = :referenceNumber', { referenceNumber })
            .getOne();
        if (!booking) {
            throw new common_1.NotFoundException(`Booking with reference ${referenceNumber} not found`);
        }
        return {
            referenceNumber: booking.referenceNumber,
            bookingStatus: booking.bookingStatus,
            paymentStatus: booking.paymentStatus,
            flightDate: booking.deal.date.toString(),
            flightTime: booking.deal.time.toString(),
            origin: booking.deal.originName,
            destination: booking.deal.destinationName,
            aircraftName: booking.deal.aircraft.name,
            companyName: booking.deal.company.companyName,
            totalPrice: booking.totalPrice.toString(),
            passengerCount: booking.passengers.length,
            createdAt: booking.createdAt.toISOString(),
            updatedAt: booking.updatedAt.toISOString(),
        };
    }
    async getBookingStats(userId) {
        const query = this.bookingRepository.createQueryBuilder('booking');
        if (userId) {
            query.where('booking.userId = :userId', { userId });
        }
        const [total, pending, confirmed, cancelled, completed] = await Promise.all([
            query.getCount(),
            query.andWhere('booking.bookingStatus = :status', { status: booking_entity_1.BookingStatus.PENDING }).getCount(),
            query.andWhere('booking.bookingStatus = :status', { status: booking_entity_1.BookingStatus.CONFIRMED }).getCount(),
            query.andWhere('booking.bookingStatus = :status', { status: booking_entity_1.BookingStatus.CANCELLED }).getCount(),
            query.andWhere('booking.bookingStatus = :status', { status: booking_entity_1.BookingStatus.COMPLETED }).getCount(),
        ]);
        return { total, pending, confirmed, cancelled, completed };
    }
    async hasExistingBooking(userId, dealId) {
        const existing = await this.bookingRepository.findOne({
            where: {
                userId,
                dealId,
                bookingStatus: (0, typeorm_2.In)([booking_entity_1.BookingStatus.PENDING, booking_entity_1.BookingStatus.CONFIRMED]),
            },
        });
        return !!existing;
    }
    async getBookingSummary(bookingId) {
        const booking = await this.findOne(bookingId);
        return {
            id: booking.id,
            referenceNumber: booking.referenceNumber,
            totalPrice: booking.totalPrice,
            netAmount: booking.totalPrice,
            company: booking.company,
            deal: booking.deal,
            passengers: booking.passengers,
            status: booking.bookingStatus,
            paymentStatus: booking.paymentStatus,
        };
    }
};
exports.BookingQueryService = BookingQueryService;
exports.BookingQueryService = BookingQueryService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(booking_entity_1.Booking)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], BookingQueryService);


/***/ }),
/* 81 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var EmailService_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailService = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(5);
const resend_1 = __webpack_require__(82);
let EmailService = EmailService_1 = class EmailService {
    constructor(configService) {
        this.configService = configService;
        this.logger = new common_1.Logger(EmailService_1.name);
        const apiKey = this.configService.get('RESEND_API_KEY');
        if (!apiKey) {
            this.logger.warn('RESEND_API_KEY not configured. Email service will be disabled.');
            return;
        }
        this.resend = new resend_1.Resend(apiKey);
    }
    async sendBookingConfirmationEmail(to, bookingData) {
        if (!this.resend) {
            this.logger.error('Resend not initialized. Check RESEND_API_KEY configuration.');
            return { success: false, error: 'Email service not configured' };
        }
        try {
            const emailHtml = this.generateBookingConfirmationHtml(bookingData);
            const result = await this.resend.emails.send({
                from: 'Air Charters <noreply@aircharters.com>',
                to: [to],
                subject: `Booking Confirmed - ${bookingData.referenceNumber}`,
                html: emailHtml,
            });
            this.logger.log(`Booking confirmation email sent to ${to}. Message ID: ${result.data?.id}`);
            return {
                success: true,
                messageId: result.data?.id
            };
        }
        catch (error) {
            this.logger.error(`Failed to send booking confirmation email to ${to}:`, error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }
    async sendPaymentConfirmationEmail(to, paymentData) {
        if (!this.resend) {
            this.logger.error('Resend not initialized. Check RESEND_API_KEY configuration.');
            return { success: false, error: 'Email service not configured' };
        }
        try {
            const emailHtml = this.generatePaymentConfirmationHtml(paymentData);
            const result = await this.resend.emails.send({
                from: 'Air Charters <noreply@aircharters.com>',
                to: [to],
                subject: `Payment Confirmed - ${paymentData.referenceNumber}`,
                html: emailHtml,
            });
            this.logger.log(`Payment confirmation email sent to ${to}. Message ID: ${result.data?.id}`);
            return {
                success: true,
                messageId: result.data?.id
            };
        }
        catch (error) {
            this.logger.error(`Failed to send payment confirmation email to ${to}:`, error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }
    generateBookingConfirmationHtml(bookingData) {
        return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Booking Confirmation</title>
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
          .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
          .booking-details { background: white; padding: 20px; border-radius: 8px; margin: 20px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
          .detail-row { display: flex; justify-content: space-between; margin: 10px 0; padding: 8px 0; border-bottom: 1px solid #eee; }
          .detail-label { font-weight: bold; color: #666; }
          .detail-value { color: #333; }
          .total { background: #667eea; color: white; padding: 15px; border-radius: 8px; text-align: center; font-size: 18px; font-weight: bold; margin: 20px 0; }
          .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
          .success-icon { font-size: 48px; margin-bottom: 10px; }
        </style>
      </head>
      <body>
        <div class="header">
          <div class="success-icon">âœˆï¸</div>
          <h1>Booking Confirmed!</h1>
          <p>Your flight has been successfully booked</p>
        </div>
        
        <div class="content">
          <p>Dear ${bookingData.passengerName},</p>
          
          <p>Great news! Your flight booking has been confirmed. Here are your booking details:</p>
          
          <div class="booking-details">
            <div class="detail-row">
              <span class="detail-label">Booking Reference:</span>
              <span class="detail-value">${bookingData.referenceNumber}</span>
            </div>
            <div class="detail-row">
              <span class="detail-label">Route:</span>
              <span class="detail-value">${bookingData.departure} â†’ ${bookingData.destination}</span>
            </div>
            <div class="detail-row">
              <span class="detail-label">Date:</span>
              <span class="detail-value">${bookingData.date}</span>
            </div>
            <div class="detail-row">
              <span class="detail-label">Time:</span>
              <span class="detail-value">${bookingData.time}</span>
            </div>
            <div class="detail-row">
              <span class="detail-label">Aircraft:</span>
              <span class="detail-value">${bookingData.aircraft}</span>
            </div>
            <div class="detail-row">
              <span class="detail-label">Company:</span>
              <span class="detail-value">${bookingData.company}</span>
            </div>
          </div>
          
          <div class="total">
            Total Amount: $${bookingData.totalAmount.toFixed(2)} USD
          </div>
          
          <div style="background: #e8f4fd; padding: 15px; border-radius: 8px; margin: 20px 0;">
            <h3 style="margin-top: 0; color: #1976d2;">ðŸ“‹ Important Information</h3>
            <ul style="margin: 10px 0; padding-left: 20px;">
              <li>Please arrive at the airport 30 minutes before departure time</li>
              <li>Bring a valid ID and your booking reference</li>
              <li>Contact us if you need to make any changes</li>
            </ul>
          </div>
          
          <p>Thank you for choosing Air Charters for your travel needs!</p>
          
          <p>Safe travels,<br>
          The Air Charters Team</p>
        </div>
        
        <div class="footer">
          <p>This is an automated email. Please do not reply to this message.</p>
          <p>Â© 2024 Air Charters. All rights reserved.</p>
        </div>
      </body>
      </html>
    `;
    }
    generatePaymentConfirmationHtml(paymentData) {
        return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Payment Confirmation</title>
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: linear-gradient(135deg, #4caf50 0%, #45a049 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
          .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
          .payment-details { background: white; padding: 20px; border-radius: 8px; margin: 20px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
          .detail-row { display: flex; justify-content: space-between; margin: 10px 0; padding: 8px 0; border-bottom: 1px solid #eee; }
          .detail-label { font-weight: bold; color: #666; }
          .detail-value { color: #333; }
          .total { background: #4caf50; color: white; padding: 15px; border-radius: 8px; text-align: center; font-size: 18px; font-weight: bold; margin: 20px 0; }
          .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
          .success-icon { font-size: 48px; margin-bottom: 10px; }
        </style>
      </head>
      <body>
        <div class="header">
          <div class="success-icon">ðŸ’³</div>
          <h1>Payment Confirmed!</h1>
          <p>Your payment has been processed successfully</p>
        </div>
        
        <div class="content">
          <p>Your payment has been successfully processed. Here are the payment details:</p>
          
          <div class="payment-details">
            <div class="detail-row">
              <span class="detail-label">Booking Reference:</span>
              <span class="detail-value">${paymentData.referenceNumber}</span>
            </div>
            <div class="detail-row">
              <span class="detail-label">Transaction ID:</span>
              <span class="detail-value">${paymentData.transactionId}</span>
            </div>
            <div class="detail-row">
              <span class="detail-label">Payment Method:</span>
              <span class="detail-value">${paymentData.paymentMethod}</span>
            </div>
            <div class="detail-row">
              <span class="detail-label">Amount:</span>
              <span class="detail-value">$${paymentData.amount.toFixed(2)} USD</span>
            </div>
          </div>
          
          <div class="total">
            Payment Successful âœ…
          </div>
          
          <p>Your booking is now confirmed and you will receive a separate email with your flight details.</p>
          
          <p>Thank you for your payment!</p>
          
          <p>Best regards,<br>
          The Air Charters Team</p>
        </div>
        
        <div class="footer">
          <p>This is an automated email. Please do not reply to this message.</p>
          <p>Â© 2024 Air Charters. All rights reserved.</p>
        </div>
      </body>
      </html>
    `;
    }
};
exports.EmailService = EmailService;
exports.EmailService = EmailService = EmailService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], EmailService);


/***/ }),
/* 82 */
/***/ ((module) => {

module.exports = require("resend");

/***/ }),
/* 83 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var PaymentProviderService_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaymentProviderService = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(5);
const payment_provider_interface_1 = __webpack_require__(84);
const stripe_provider_1 = __webpack_require__(85);
const mpesa_provider_1 = __webpack_require__(87);
const paystack_provider_1 = __webpack_require__(88);
let PaymentProviderService = PaymentProviderService_1 = class PaymentProviderService {
    constructor(configService, stripeProvider, mpesaProvider, paystackProvider) {
        this.configService = configService;
        this.stripeProvider = stripeProvider;
        this.mpesaProvider = mpesaProvider;
        this.paystackProvider = paystackProvider;
        this.logger = new common_1.Logger(PaymentProviderService_1.name);
        this.providers = new Map();
        this.initializeProviders();
    }
    initializeProviders() {
        this.providers.set(payment_provider_interface_1.PaymentProviderType.PAYSTACK, this.paystackProvider);
        this.providers.set(payment_provider_interface_1.PaymentProviderType.STRIPE, this.stripeProvider);
        this.providers.set(payment_provider_interface_1.PaymentProviderType.MPESA, this.mpesaProvider);
    }
    getProvider(type) {
        const provider = this.providers.get(type);
        if (!provider) {
            throw new Error(`Payment provider ${type} not found`);
        }
        return provider;
    }
    getDefaultProvider() {
        return this.getProvider(payment_provider_interface_1.PaymentProviderType.PAYSTACK);
    }
    async createPaymentIntent(request, providerType = payment_provider_interface_1.PaymentProviderType.PAYSTACK) {
        const provider = this.getProvider(providerType);
        if (!provider.supportedCurrencies.includes(request.currency.toUpperCase())) {
            throw new Error(`Currency ${request.currency} not supported by ${provider.name}`);
        }
        this.logger.log(`Creating payment intent with ${provider.name} for booking ${request.bookingId}`);
        try {
            const result = await provider.createPaymentIntent(request);
            this.logger.log(`Payment intent created: ${result.id}`);
            return result;
        }
        catch (error) {
            this.logger.error(`Failed to create payment intent with ${provider.name}`, error);
            throw error;
        }
    }
    async confirmPayment(request, providerType = payment_provider_interface_1.PaymentProviderType.PAYSTACK) {
        const provider = this.getProvider(providerType);
        this.logger.log(`Confirming payment with ${provider.name}: ${request.paymentIntentId}`);
        try {
            const result = await provider.confirmPayment(request);
            this.logger.log(`Payment confirmed: ${result.id} - Status: ${result.status}`);
            return result;
        }
        catch (error) {
            this.logger.error(`Failed to confirm payment with ${provider.name}`, error);
            throw error;
        }
    }
    async getPaymentStatus(paymentIntentId, providerType = payment_provider_interface_1.PaymentProviderType.PAYSTACK) {
        const provider = this.getProvider(providerType);
        try {
            const result = await provider.getPaymentStatus(paymentIntentId);
            this.logger.log(`Payment status retrieved: ${result.id} - Status: ${result.status}`);
            return result;
        }
        catch (error) {
            this.logger.error(`Failed to get payment status with ${provider.name}`, error);
            throw error;
        }
    }
    async createRefund(paymentIntentId, amount, reason, providerType = payment_provider_interface_1.PaymentProviderType.PAYSTACK) {
        const provider = this.getProvider(providerType);
        if (!provider.createRefund) {
            throw new Error(`Refunds not supported by ${provider.name}`);
        }
        this.logger.log(`Creating refund with ${provider.name}: ${paymentIntentId}`);
        try {
            const result = await provider.createRefund(paymentIntentId, amount, reason);
            this.logger.log(`Refund created: ${result.id}`);
            return result;
        }
        catch (error) {
            this.logger.error(`Failed to create refund with ${provider.name}`, error);
            throw error;
        }
    }
    getSupportedProviders() {
        return Array.from(this.providers.keys());
    }
    getProviderInfo(type) {
        const provider = this.getProvider(type);
        return {
            name: provider.name,
            supportedCurrencies: provider.supportedCurrencies,
            supportedPaymentMethods: provider.supportedPaymentMethods,
        };
    }
};
exports.PaymentProviderService = PaymentProviderService;
exports.PaymentProviderService = PaymentProviderService = PaymentProviderService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object, typeof (_b = typeof stripe_provider_1.StripeProvider !== "undefined" && stripe_provider_1.StripeProvider) === "function" ? _b : Object, typeof (_c = typeof mpesa_provider_1.MpesaProvider !== "undefined" && mpesa_provider_1.MpesaProvider) === "function" ? _c : Object, typeof (_d = typeof paystack_provider_1.PaystackProvider !== "undefined" && paystack_provider_1.PaystackProvider) === "function" ? _d : Object])
], PaymentProviderService);


/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaymentProviderType = void 0;
var PaymentProviderType;
(function (PaymentProviderType) {
    PaymentProviderType["STRIPE"] = "stripe";
    PaymentProviderType["MPESA"] = "mpesa";
    PaymentProviderType["PAYSTACK"] = "paystack";
    PaymentProviderType["PAYPAL"] = "paypal";
    PaymentProviderType["FLUTTERWAVE"] = "flutterwave";
})(PaymentProviderType || (exports.PaymentProviderType = PaymentProviderType = {}));


/***/ }),
/* 85 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var StripeProvider_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StripeProvider = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(5);
const stripe_1 = __webpack_require__(86);
let StripeProvider = StripeProvider_1 = class StripeProvider {
    constructor(configService) {
        this.configService = configService;
        this.logger = new common_1.Logger(StripeProvider_1.name);
        this.name = 'Stripe';
        this.supportedCurrencies = ['USD', 'EUR', 'GBP', 'CAD', 'AUD'];
        this.supportedPaymentMethods = [
            'card',
            'apple_pay',
            'google_pay',
            'bank_transfer',
            'us_bank_account',
        ];
        const secretKey = this.configService.get('STRIPE_SECRET_KEY');
        if (!secretKey) {
            throw new Error('STRIPE_SECRET_KEY is required');
        }
        this.stripe = new stripe_1.default(secretKey, {
            apiVersion: '2023-10-16',
        });
    }
    async createPaymentIntent(request) {
        try {
            const paymentIntent = await this.stripe.paymentIntents.create({
                amount: Math.round(request.amount * 100),
                currency: request.currency.toLowerCase(),
                metadata: {
                    bookingId: request.bookingId,
                    userId: request.userId,
                    ...request.metadata,
                },
                description: request.description,
                automatic_payment_methods: {
                    enabled: true,
                },
            });
            return {
                id: paymentIntent.id,
                clientSecret: paymentIntent.client_secret,
                status: paymentIntent.status,
                amount: request.amount,
                currency: request.currency,
                requiresAction: paymentIntent.status === 'requires_action',
                nextAction: paymentIntent.next_action,
            };
        }
        catch (error) {
            this.logger.error('Failed to create Stripe payment intent', error);
            throw new Error(`Payment intent creation failed: ${error.message}`);
        }
    }
    async confirmPayment(request) {
        try {
            const paymentIntent = await this.stripe.paymentIntents.retrieve(request.paymentIntentId);
            if (paymentIntent.status === 'requires_confirmation') {
                await this.stripe.paymentIntents.confirm(request.paymentIntentId, {
                    payment_method: request.paymentMethodId,
                });
            }
            const updatedPaymentIntent = await this.stripe.paymentIntents.retrieve(request.paymentIntentId);
            return {
                id: updatedPaymentIntent.id,
                status: updatedPaymentIntent.status,
                amount: updatedPaymentIntent.amount / 100,
                currency: updatedPaymentIntent.currency.toUpperCase(),
                transactionId: updatedPaymentIntent.latest_charge,
                paymentMethod: updatedPaymentIntent.payment_method_types?.[0] || 'unknown',
                metadata: updatedPaymentIntent.metadata,
            };
        }
        catch (error) {
            this.logger.error('Failed to confirm Stripe payment', error);
            throw new Error(`Payment confirmation failed: ${error.message}`);
        }
    }
    async getPaymentStatus(paymentIntentId) {
        try {
            const paymentIntent = await this.stripe.paymentIntents.retrieve(paymentIntentId);
            const charge = paymentIntent.latest_charge
                ? await this.stripe.charges.retrieve(paymentIntent.latest_charge)
                : null;
            return {
                id: paymentIntent.id,
                status: paymentIntent.status,
                amount: paymentIntent.amount / 100,
                currency: paymentIntent.currency.toUpperCase(),
                transactionId: charge?.id || paymentIntent.id,
                paymentMethod: paymentIntent.payment_method_types?.[0] || 'unknown',
                metadata: paymentIntent.metadata,
            };
        }
        catch (error) {
            this.logger.error('Failed to get Stripe payment status', error);
            throw new Error(`Payment status retrieval failed: ${error.message}`);
        }
    }
    async createRefund(paymentIntentId, amount, reason) {
        try {
            const paymentIntent = await this.stripe.paymentIntents.retrieve(paymentIntentId);
            const charge = paymentIntent.latest_charge;
            const refund = await this.stripe.refunds.create({
                charge,
                amount: amount ? Math.round(amount * 100) : undefined,
                reason: reason,
                metadata: {
                    paymentIntentId,
                    reason,
                },
            });
            return {
                id: refund.id,
                amount: refund.amount / 100,
                status: refund.status,
                reason: refund.reason,
            };
        }
        catch (error) {
            this.logger.error('Failed to create Stripe refund', error);
            throw new Error(`Refund creation failed: ${error.message}`);
        }
    }
    async getPaymentMethods(userId) {
        try {
            const paymentMethods = await this.stripe.paymentMethods.list({
                customer: userId,
                type: 'card',
            });
            return paymentMethods.data.map(pm => ({
                id: pm.id,
                type: pm.type,
                brand: pm.card?.brand,
                last4: pm.card?.last4,
                expiryMonth: pm.card?.exp_month,
                expiryYear: pm.card?.exp_year,
            }));
        }
        catch (error) {
            this.logger.error('Failed to get Stripe payment methods', error);
            return [];
        }
    }
    async savePaymentMethod(userId, paymentMethodData) {
        try {
            const paymentMethod = await this.stripe.paymentMethods.attach(paymentMethodData.paymentMethodId, { customer: userId });
            return {
                id: paymentMethod.id,
                type: paymentMethod.type,
                brand: paymentMethod.card?.brand,
                last4: paymentMethod.card?.last4,
                expiryMonth: paymentMethod.card?.exp_month,
                expiryYear: paymentMethod.card?.exp_year,
            };
        }
        catch (error) {
            this.logger.error('Failed to save Stripe payment method', error);
            throw new Error(`Payment method save failed: ${error.message}`);
        }
    }
    async deletePaymentMethod(paymentMethodId) {
        try {
            await this.stripe.paymentMethods.detach(paymentMethodId);
            return true;
        }
        catch (error) {
            this.logger.error('Failed to delete Stripe payment method', error);
            return false;
        }
    }
};
exports.StripeProvider = StripeProvider;
exports.StripeProvider = StripeProvider = StripeProvider_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], StripeProvider);


/***/ }),
/* 86 */
/***/ ((module) => {

module.exports = require("stripe");

/***/ }),
/* 87 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var MpesaProvider_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MpesaProvider = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(5);
const axios_1 = __webpack_require__(54);
const rxjs_1 = __webpack_require__(55);
let MpesaProvider = MpesaProvider_1 = class MpesaProvider {
    constructor(configService, httpService) {
        this.configService = configService;
        this.httpService = httpService;
        this.logger = new common_1.Logger(MpesaProvider_1.name);
        this.accessToken = null;
        this.tokenExpiry = 0;
        this.name = 'M-Pesa';
        this.supportedCurrencies = ['KES'];
        this.supportedPaymentMethods = ['mobile_money'];
        this.config = {
            consumerKey: this.configService.get('MPESA_CONSUMER_KEY'),
            consumerSecret: this.configService.get('MPESA_CONSUMER_SECRET'),
            passkey: this.configService.get('MPESA_PASSKEY'),
            businessShortCode: this.configService.get('MPESA_BUSINESS_SHORT_CODE'),
            environment: this.configService.get('MPESA_ENVIRONMENT') || 'sandbox',
        };
        this.validateConfig();
    }
    validateConfig() {
        const requiredFields = ['consumerKey', 'consumerSecret', 'passkey', 'businessShortCode'];
        for (const field of requiredFields) {
            if (!this.config[field]) {
                throw new Error(`M-Pesa ${field} is not configured`);
            }
        }
    }
    getBaseUrl() {
        return this.config.environment === 'live'
            ? 'https://api.safaricom.co.ke'
            : 'https://sandbox.safaricom.co.ke';
    }
    async getAccessToken() {
        const now = Date.now();
        if (this.accessToken && now < this.tokenExpiry) {
            return this.accessToken;
        }
        try {
            const authUrl = `${this.getBaseUrl()}/oauth/v1/generate?grant_type=client_credentials`;
            const authString = Buffer.from(`${this.config.consumerKey}:${this.config.consumerSecret}`).toString('base64');
            const response = await (0, rxjs_1.firstValueFrom)(this.httpService.get(authUrl, {
                headers: {
                    Authorization: `Basic ${authString}`,
                },
            }));
            this.accessToken = response.data.access_token;
            this.tokenExpiry = now + (response.data.expires_in * 1000) - 60000;
            this.logger.log('M-Pesa access token refreshed');
            return this.accessToken;
        }
        catch (error) {
            this.logger.error('Failed to get M-Pesa access token', error);
            throw new common_1.HttpException('Failed to authenticate with M-Pesa', common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    generatePassword() {
        const timestamp = new Date().toISOString().replace(/[^0-9]/g, '').slice(0, -3);
        const password = Buffer.from(`${this.config.businessShortCode}${this.config.passkey}${timestamp}`).toString('base64');
        return password;
    }
    async createPaymentIntent(request) {
        try {
            const accessToken = await this.getAccessToken();
            const password = this.generatePassword();
            const timestamp = new Date().toISOString().replace(/[^0-9]/g, '').slice(0, -3);
            const phoneNumber = request.metadata?.phoneNumber || request.metadata?.phone || '254700000000';
            const formattedPhone = phoneNumber.replace(/^\+/, '').replace(/^0/, '254');
            const stkPushRequest = {
                BusinessShortCode: this.config.businessShortCode,
                Password: password,
                Timestamp: timestamp,
                TransactionType: 'CustomerPayBillOnline',
                Amount: Math.round(request.amount),
                PartyA: formattedPhone,
                PartyB: this.config.businessShortCode,
                PhoneNumber: formattedPhone,
                CallBackURL: `${this.configService.get('APP_URL')}/api/payments/mpesa/callback`,
                AccountReference: request.bookingId,
                TransactionDesc: request.description,
            };
            const response = await (0, rxjs_1.firstValueFrom)(this.httpService.post(`${this.getBaseUrl()}/mpesa/stkpush/v1/processrequest`, stkPushRequest, {
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                },
            }));
            const result = response.data;
            if (result.ResponseCode !== '0') {
                throw new common_1.HttpException(`M-Pesa STK Push failed: ${result.ResponseDescription}`, common_1.HttpStatus.BAD_REQUEST);
            }
            this.logger.log(`M-Pesa STK Push initiated: ${result.CheckoutRequestID}`);
            return {
                id: result.CheckoutRequestID,
                status: 'pending',
                amount: request.amount,
                currency: request.currency,
                paymentMethod: 'mobile_money',
                requiresAction: true,
                nextAction: {
                    type: 'mpesa_stk_push',
                    message: result.CustomerMessage,
                    checkoutRequestId: result.CheckoutRequestID,
                },
            };
        }
        catch (error) {
            this.logger.error('Failed to create M-Pesa payment intent', error);
            throw error;
        }
    }
    async confirmPayment(request) {
        return this.getPaymentStatus(request.paymentIntentId);
    }
    async getPaymentStatus(paymentIntentId) {
        try {
            return {
                id: paymentIntentId,
                status: 'pending',
                amount: 0,
                currency: 'KES',
                transactionId: paymentIntentId,
                paymentMethod: 'mobile_money',
            };
        }
        catch (error) {
            this.logger.error('Failed to get M-Pesa payment status', error);
            throw error;
        }
    }
    async processCallback(callbackData) {
        const stkCallback = callbackData.Body.stkCallback;
        this.logger.log(`M-Pesa callback received: ${stkCallback.CheckoutRequestID}`);
        if (stkCallback.ResultCode === 0) {
            const metadata = stkCallback.CallbackMetadata?.Item.reduce((acc, item) => {
                acc[item.Name] = item.Value;
                return acc;
            }, {});
            return {
                id: stkCallback.CheckoutRequestID,
                status: 'succeeded',
                amount: metadata?.Amount || 0,
                currency: 'KES',
                transactionId: metadata?.MpesaReceiptNumber || stkCallback.CheckoutRequestID,
                paymentMethod: 'mobile_money',
                metadata: {
                    mpesaReceiptNumber: metadata?.MpesaReceiptNumber,
                    transactionDate: metadata?.TransactionDate,
                    phoneNumber: metadata?.PhoneNumber,
                },
            };
        }
        else {
            return {
                id: stkCallback.CheckoutRequestID,
                status: 'failed',
                amount: 0,
                currency: 'KES',
                transactionId: stkCallback.CheckoutRequestID,
                paymentMethod: 'mobile_money',
                metadata: {
                    errorCode: stkCallback.ResultCode,
                    errorDescription: stkCallback.ResultDesc,
                },
            };
        }
    }
    async createRefund(paymentIntentId, amount, reason) {
        this.logger.log(`M-Pesa refund requested for: ${paymentIntentId}`);
        return {
            id: `refund_${Date.now()}`,
            status: 'pending',
            amount: amount || 0,
            currency: 'KES',
            reason: reason || 'Customer request',
        };
    }
};
exports.MpesaProvider = MpesaProvider;
exports.MpesaProvider = MpesaProvider = MpesaProvider_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object, typeof (_b = typeof axios_1.HttpService !== "undefined" && axios_1.HttpService) === "function" ? _b : Object])
], MpesaProvider);


/***/ }),
/* 88 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PaystackProvider_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaystackProvider = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const exchange_rate_service_1 = __webpack_require__(89);
const transaction_ledger_entity_1 = __webpack_require__(90);
const company_payment_account_entity_1 = __webpack_require__(91);
const booking_entity_1 = __webpack_require__(29);
const Paystack = __webpack_require__(92);
let PaystackProvider = PaystackProvider_1 = class PaystackProvider {
    constructor(exchangeRateService, transactionLedgerRepository, bookingRepository) {
        this.exchangeRateService = exchangeRateService;
        this.transactionLedgerRepository = transactionLedgerRepository;
        this.bookingRepository = bookingRepository;
        this.logger = new common_1.Logger(PaystackProvider_1.name);
        this.name = 'Paystack';
        this.supportedCurrencies = ['NGN', 'GHS', 'ZAR', 'KES', 'USD'];
        this.supportedPaymentMethods = ['card', 'bank_transfer', 'ussd', 'qr', 'mobile_money'];
        this.paystack = Paystack(process.env.PAYSTACK_SECRET_KEY);
    }
    async createPaymentIntent(request) {
        try {
            this.logger.log(`Initializing Paystack payment for booking: ${request.bookingId}`);
            const subaccount = await this.getVendorSubaccount(request.metadata?.companyId);
            if (!subaccount) {
                throw new Error(`No Paystack subaccount found for company: ${request.metadata?.companyId}`);
            }
            const platformFeeRate = 0.05;
            const splitAmounts = this.calculateSplitAmounts(request.amount, platformFeeRate);
            let paystackAmount = request.amount;
            let paystackCurrency = request.currency || 'KES';
            if (request.currency === 'USD') {
                try {
                    const conversion = await this.exchangeRateService.convertCurrency({
                        amount: request.amount,
                        from: transaction_ledger_entity_1.Currency.USD,
                        to: transaction_ledger_entity_1.Currency.KES
                    });
                    paystackAmount = conversion.convertedAmount;
                    paystackCurrency = 'KES';
                    this.logger.log(`Converted ${request.amount} USD to ${paystackAmount} KES (rate: ${conversion.rate})`);
                }
                catch (error) {
                    this.logger.error(`Currency conversion failed: ${error.message}`);
                    paystackAmount = request.amount * 129;
                    paystackCurrency = 'KES';
                    this.logger.warn(`Using fallback conversion: ${request.amount} USD = ${paystackAmount} KES`);
                }
            }
            const transactionData = {
                amount: Math.round(paystackAmount * 100),
                email: request.metadata?.customerEmail || 'customer@example.com',
                currency: paystackCurrency,
                reference: this.generateReference(request.bookingId),
                callback_url: process.env.PAYSTACK_CALLBACK_URL || `${process.env.APP_URL || 'http://localhost:5000'}/api/payments/paystack/verify`,
                metadata: {
                    bookingId: request.bookingId,
                    companyId: request.metadata?.companyId,
                    userId: request.userId,
                    platformFee: splitAmounts.platformFee,
                    companyAmount: splitAmounts.companyAmount,
                    originalCurrency: request.currency,
                    originalAmount: request.amount,
                    convertedAmount: paystackAmount,
                    convertedCurrency: paystackCurrency
                },
                subaccount: subaccount.paystackSubaccountId
            };
            const response = await this.paystack.transaction.initialize(transactionData);
            if (!response.status) {
                throw new Error(`Paystack initialization failed: ${response.message}`);
            }
            this.logger.log(`Paystack payment initialized successfully: ${response.data.reference}`);
            this.logger.log(`Attempting to log transaction to ledger: ${response.data.reference}`);
            const userId = this.extractUserIdFromString(request.userId);
            this.logger.log(`Logging transaction for user ID: ${userId} (from: ${request.userId})`);
            this.logTransactionToLedger({
                transactionId: response.data.reference,
                companyId: request.metadata?.companyId,
                userId: userId,
                bookingId: request.bookingId,
                amount: request.amount,
                currency: request.currency,
                paystackAmount: paystackAmount,
                paystackCurrency: paystackCurrency,
                exchangeRate: request.currency === 'USD' ? (paystackAmount / request.amount) : 1.0,
                status: transaction_ledger_entity_1.TransactionStatus.PROCESSING,
                description: request.description,
                metadata: request.metadata,
            }).catch(error => {
                this.logger.error(`Background transaction logging failed: ${error.message}`);
            });
            return {
                id: response.data.reference,
                clientSecret: response.data.access_code,
                status: 'requires_action',
                amount: request.amount,
                currency: request.currency,
                paymentMethod: 'paystack',
                requiresAction: true,
                nextAction: {
                    type: 'redirect_to_url',
                    redirect_to_url: {
                        url: response.data.authorization_url
                    }
                },
                metadata: {
                    paystackAmount: paystackAmount,
                    paystackCurrency: paystackCurrency,
                    exchangeRate: request.currency === 'USD' ? (paystackAmount / request.amount) : 1.0
                }
            };
        }
        catch (error) {
            this.logger.error(`Paystack payment initialization failed: ${error.message}`, error.stack);
            throw new Error(`Payment initialization failed: ${error.message}`);
        }
    }
    async confirmPayment(request) {
        try {
            this.logger.log(`Confirming Paystack payment: ${request.paymentIntentId}`);
            const response = await this.paystack.transaction.verify(request.paymentIntentId);
            if (!response.status) {
                throw new Error(`Paystack verification failed: ${response.message}`);
            }
            const transaction = response.data;
            const isSuccessful = transaction.status === 'success' && transaction.amount > 0;
            this.logger.log(`Paystack payment verification result: ${isSuccessful ? 'SUCCESS' : 'FAILED'}`);
            await this.updateTransactionLedger(transaction.reference, {
                status: isSuccessful ? transaction_ledger_entity_1.TransactionStatus.COMPLETED : transaction_ledger_entity_1.TransactionStatus.FAILED,
                providerTransactionId: transaction.reference,
                providerMetadata: transaction,
                processedAt: new Date(),
                errorMessage: !isSuccessful ? (transaction.message || transaction.gateway_response || 'Payment failed') : null,
            });
            if (isSuccessful && transaction.metadata?.bookingId) {
                await this.updateBookingStatus(transaction.metadata.bookingId, true);
            }
            else if (!isSuccessful && transaction.metadata?.bookingId) {
                await this.updateBookingStatus(transaction.metadata.bookingId, false);
            }
            return {
                id: transaction.reference,
                status: isSuccessful ? 'succeeded' : 'failed',
                amount: transaction.amount / 100,
                currency: transaction.currency,
                transactionId: transaction.reference,
                paymentMethod: 'paystack',
                metadata: {
                    paystackReference: transaction.reference,
                    gatewayResponse: transaction,
                    customer: transaction.customer,
                    authorization: transaction.authorization
                }
            };
        }
        catch (error) {
            this.logger.error(`Paystack payment verification failed: ${error.message}`, error.stack);
            throw new Error(`Payment verification failed: ${error.message}`);
        }
    }
    async getPaymentStatus(paymentIntentId) {
        try {
            this.logger.log(`Getting Paystack payment status: ${paymentIntentId}`);
            const response = await this.paystack.transaction.verify(paymentIntentId);
            if (!response.status) {
                throw new Error(`Paystack status check failed: ${response.message}`);
            }
            const transaction = response.data;
            this.logger.log(`Paystack transaction details: ${JSON.stringify({
                reference: transaction.reference,
                status: transaction.status,
                amount: transaction.amount,
                currency: transaction.currency,
                gateway_response: transaction.gateway_response,
                message: transaction.message
            })}`);
            const isSuccessful = transaction.status === 'success' && transaction.amount > 0;
            if (!isSuccessful) {
                this.logger.warn(`Paystack payment failed: Status=${transaction.status}, Amount=${transaction.amount}, Message=${transaction.message || transaction.gateway_response || 'No message'}`);
            }
            const existingLedger = await this.getTransactionLedger(transaction.reference);
            const currentStatus = isSuccessful ? transaction_ledger_entity_1.TransactionStatus.COMPLETED : transaction_ledger_entity_1.TransactionStatus.FAILED;
            if (!existingLedger || existingLedger.status !== currentStatus) {
                await this.updateTransactionLedger(transaction.reference, {
                    status: currentStatus,
                    providerTransactionId: transaction.reference,
                    providerMetadata: transaction,
                    processedAt: new Date(),
                    errorMessage: !isSuccessful ? (transaction.message || transaction.gateway_response || 'Payment failed') : null,
                });
                if (transaction.metadata?.bookingId) {
                    await this.updateBookingStatus(transaction.metadata.bookingId, isSuccessful);
                }
            }
            return {
                id: transaction.reference,
                status: isSuccessful ? 'succeeded' : 'failed',
                amount: transaction.amount / 100,
                currency: transaction.currency,
                transactionId: transaction.reference,
                paymentMethod: 'paystack',
                metadata: {
                    paystackReference: transaction.reference,
                    gatewayResponse: transaction,
                    failureReason: !isSuccessful ? transaction.message || 'Payment failed' : null
                }
            };
        }
        catch (error) {
            this.logger.error(`Paystack status check failed: ${error.message}`, error.stack);
            throw new Error(`Payment status check failed: ${error.message}`);
        }
    }
    async createRefund(paymentIntentId, amount, reason) {
        try {
            this.logger.log(`Creating Paystack refund: ${paymentIntentId}`);
            const refundData = {
                transaction: paymentIntentId,
                amount: amount ? Math.round(amount * 100) : undefined,
                reason: reason || 'requested_by_customer'
            };
            const response = await this.paystack.refund.create(refundData);
            if (!response.status) {
                throw new Error(`Paystack refund failed: ${response.message}`);
            }
            return {
                id: response.data.id,
                status: response.data.status,
                amount: response.data.amount / 100,
                currency: response.data.currency,
                reason: response.data.reason
            };
        }
        catch (error) {
            this.logger.error(`Paystack refund failed: ${error.message}`, error.stack);
            throw new Error(`Refund creation failed: ${error.message}`);
        }
    }
    async handleWebhook(event, signature) {
        try {
            this.logger.log(`Processing Paystack webhook: ${event.event}`);
            if (!this.verifyWebhookSignature(event, signature)) {
                this.logger.error('Invalid Paystack webhook signature');
                return false;
            }
            switch (event.event) {
                case 'charge.success':
                    await this.handlePaymentSuccess(event.data);
                    break;
                case 'charge.failed':
                    await this.handlePaymentFailed(event.data);
                    break;
                case 'transfer.success':
                    await this.handleTransferSuccess(event.data);
                    break;
                case 'transfer.failed':
                    await this.handleTransferFailed(event.data);
                    break;
                case 'subscription.create':
                case 'subscription.disable':
                case 'subscription.enable':
                    this.logger.log(`Subscription webhook event: ${event.event} - not implemented yet`);
                    break;
                default:
                    this.logger.log(`Unhandled Paystack webhook event: ${event.event}`);
            }
            return true;
        }
        catch (error) {
            this.logger.error(`Paystack webhook processing failed: ${error.message}`, error.stack);
            return false;
        }
    }
    async createVendorSubaccount(companyId, companyData) {
        try {
            this.logger.log(`Creating Paystack subaccount for company: ${companyId}`);
            const subaccountData = {
                business_name: companyData.companyName,
                settlement_bank: companyData.bankCode || '044',
                account_number: companyData.accountNumber,
                percentage_charge: companyData.commissionRate || 0,
                description: `Subaccount for ${companyData.companyName}`,
                primary_contact_email: companyData.email,
                primary_contact_name: `${companyData.contactPersonFirstName} ${companyData.contactPersonLastName}`,
                primary_contact_phone: companyData.mobileNumber,
                metadata: {
                    companyId: companyId,
                    companyName: companyData.companyName
                }
            };
            const response = await this.paystack.subaccount.create(subaccountData);
            if (!response.status) {
                throw new Error(`Paystack subaccount creation failed: ${response.message}`);
            }
            this.logger.log(`Paystack subaccount created successfully: ${response.data.subaccount_code}`);
            return {
                subaccountId: response.data.id,
                subaccountCode: response.data.subaccount_code,
                splitCode: response.data.split_code,
                status: response.data.active ? 'active' : 'pending'
            };
        }
        catch (error) {
            this.logger.error(`Paystack subaccount creation failed: ${error.message}`, error.stack);
            throw new Error(`Subaccount creation failed: ${error.message}`);
        }
    }
    async getVendorSubaccount(companyId) {
        return {
            paystackSubaccountId: 'ACCT_4evq96sxvwuf7va',
            accountId: 'ACCT_4evq96sxvwuf7va',
            percentageCharge: 5.0,
            settlementBank: 'Absa Bank Kenya Plc',
            settlementAccountNumber: '2051951312',
            businessName: 'SPAir Services',
            status: 'active'
        };
    }
    calculateSplitAmounts(totalAmount, commissionRate) {
        const platformFee = totalAmount * commissionRate;
        const companyAmount = totalAmount - platformFee;
        const companyPercentage = (companyAmount / totalAmount) * 100;
        return {
            totalAmount,
            platformFee,
            companyAmount,
            companyPercentage,
            commissionRate
        };
    }
    generateReference(bookingId) {
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(2, 8);
        return `PAYSTACK_${bookingId}_${timestamp}_${random}`.toUpperCase();
    }
    extractUserIdFromString(userIdString) {
        const numericId = parseInt(userIdString);
        if (!isNaN(numericId)) {
            return numericId;
        }
        const match = userIdString.match(/user_(\d+)_/);
        if (match && match[1]) {
            return parseInt(match[1]);
        }
        let hash = 0;
        for (let i = 0; i < userIdString.length; i++) {
            const char = userIdString.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash);
    }
    verifyWebhookSignature(event, signature) {
        try {
            if (process.env.NODE_ENV === 'development') {
                this.logger.warn('Skipping webhook signature verification in development mode');
                return true;
            }
            const webhookSecret = process.env.PAYSTACK_WEBHOOK_SECRET;
            if (!webhookSecret) {
                this.logger.error('PAYSTACK_WEBHOOK_SECRET not configured');
                return false;
            }
            if (!signature) {
                this.logger.error('No webhook signature provided');
                return false;
            }
            const crypto = __webpack_require__(93);
            const expectedSignature = crypto
                .createHmac('sha512', webhookSecret)
                .update(JSON.stringify(event))
                .digest('hex');
            const isValid = crypto.timingSafeEqual(Buffer.from(signature, 'hex'), Buffer.from(expectedSignature, 'hex'));
            if (!isValid) {
                this.logger.error('Invalid webhook signature');
                return false;
            }
            return true;
        }
        catch (error) {
            this.logger.error(`Webhook signature verification failed: ${error.message}`);
            return false;
        }
    }
    async handlePaymentSuccess(data) {
        this.logger.log(`Payment successful: ${data.reference}`);
    }
    async handlePaymentFailed(data) {
        this.logger.log(`Payment failed: ${data.reference}`);
    }
    async handleTransferSuccess(data) {
        this.logger.log(`Transfer successful: ${data.reference}`);
    }
    async handleTransferFailed(data) {
        this.logger.log(`Transfer failed: ${data.reference}`);
    }
    async logTransactionToLedger(data) {
        const maxRetries = 3;
        let lastError;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const isTestBooking = data.bookingId.startsWith('TEST_') ||
                    data.bookingId.startsWith('TEMP_') ||
                    data.bookingId.startsWith('1757959') ||
                    data.bookingId.startsWith('BK-') ||
                    data.bookingId.startsWith('AC');
                const ledgerEntry = this.transactionLedgerRepository.create({
                    transactionId: data.transactionId,
                    companyId: isTestBooking ? null : data.companyId,
                    userId: this.extractUserIdFromString(data.userId.toString()),
                    bookingId: isTestBooking ? null : data.bookingId,
                    transactionType: transaction_ledger_entity_1.TransactionType.PAYMENT_RECEIVED,
                    paymentProvider: company_payment_account_entity_1.PaymentProvider.PAYSTACK,
                    amount: data.amount,
                    currency: data.currency,
                    exchangeRate: data.exchangeRate,
                    baseAmount: data.amount * data.exchangeRate,
                    netAmount: data.amount,
                    status: data.status,
                    description: data.description,
                    metadata: {
                        ...data.metadata,
                        paystackAmount: data.paystackAmount,
                        paystackCurrency: data.paystackCurrency,
                        originalCurrency: data.currency,
                        convertedCurrency: data.paystackCurrency,
                        isTestTransaction: isTestBooking,
                    },
                    providerMetadata: {
                        paystackReference: data.transactionId,
                        paystackAmount: data.paystackAmount,
                        paystackCurrency: data.paystackCurrency,
                    },
                });
                await this.transactionLedgerRepository.insert(ledgerEntry);
                this.logger.log(`Transaction logged to ledger: ${data.transactionId}`);
                return;
            }
            catch (error) {
                lastError = error;
                if (error.message && error.message.includes('Lock wait timeout exceeded')) {
                    if (attempt < maxRetries) {
                        const delay = Math.pow(2, attempt - 1) * 1000;
                        this.logger.warn(`Lock timeout on attempt ${attempt}, retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                }
                this.logger.error(`Failed to log transaction to ledger (attempt ${attempt}): ${error.message}`, error.stack);
                break;
            }
        }
        this.logger.error(`Failed to log transaction to ledger after ${maxRetries} attempts: ${lastError?.message}`);
    }
    async updateBookingStatus(bookingId, paymentSuccessful) {
        try {
            if (bookingId.startsWith('TEST_') || bookingId.startsWith('1757959')) {
                this.logger.log(`Skipping booking status update for test booking: ${bookingId}`);
                return;
            }
            const booking = await this.bookingRepository.findOne({
                where: { id: parseInt(bookingId) }
            });
            if (!booking) {
                this.logger.warn(`Booking not found for ID: ${bookingId}`);
                return;
            }
            booking.paymentStatus = paymentSuccessful ? booking_entity_1.PaymentStatus.PAID : booking_entity_1.PaymentStatus.FAILED;
            if (paymentSuccessful && booking.bookingStatus === booking_entity_1.BookingStatus.PENDING) {
                booking.bookingStatus = booking_entity_1.BookingStatus.CONFIRMED;
                this.logger.log(`Booking ${bookingId} confirmed after successful payment`);
            }
            await this.bookingRepository.save(booking);
            this.logger.log(`Booking ${bookingId} status updated - Payment: ${booking.paymentStatus}, Booking: ${booking.bookingStatus}`);
        }
        catch (error) {
            this.logger.error(`Failed to update booking status for ${bookingId}: ${error.message}`, error.stack);
        }
    }
    async updateTransactionLedger(transactionId, updates) {
        try {
            const ledgerEntry = await this.transactionLedgerRepository.findOne({
                where: { transactionId }
            });
            if (ledgerEntry) {
                Object.assign(ledgerEntry, updates);
                await this.transactionLedgerRepository.save(ledgerEntry);
                this.logger.log(`Transaction ledger updated: ${transactionId} - Status: ${updates.status}`);
            }
            else {
                this.logger.log(`Transaction not found in ledger, creating entry for: ${transactionId}`);
                const providerData = updates.providerMetadata || {};
                const amount = providerData.amount ? providerData.amount / 100 : 0;
                const currency = providerData.currency || 'KES';
                const isTestTransaction = transactionId.startsWith('PAYSTACK_TEST_') ||
                    transactionId.includes('1757959') ||
                    (providerData.metadata?.bookingId && providerData.metadata.bookingId.startsWith('1757959'));
                const newLedgerEntry = this.transactionLedgerRepository.create({
                    transactionId: transactionId,
                    companyId: isTestTransaction ? null : (providerData.metadata?.companyId || null),
                    userId: this.extractUserIdFromString(providerData.metadata?.userId || '1'),
                    bookingId: isTestTransaction ? null : (providerData.metadata?.bookingId || null),
                    transactionType: transaction_ledger_entity_1.TransactionType.PAYMENT_RECEIVED,
                    paymentProvider: company_payment_account_entity_1.PaymentProvider.PAYSTACK,
                    amount: amount,
                    currency: currency,
                    exchangeRate: 1.0,
                    baseAmount: amount,
                    netAmount: amount,
                    status: updates.status || transaction_ledger_entity_1.TransactionStatus.FAILED,
                    description: `Payment ${updates.status === transaction_ledger_entity_1.TransactionStatus.COMPLETED ? 'completed' : 'failed'}`,
                    metadata: providerData.metadata || {},
                    providerMetadata: providerData,
                    errorMessage: updates.errorMessage,
                    processedAt: updates.processedAt,
                });
                await this.transactionLedgerRepository.save(newLedgerEntry);
                this.logger.log(`Transaction ledger entry created: ${transactionId} - Status: ${updates.status}`);
            }
        }
        catch (error) {
            this.logger.error(`Failed to update transaction ledger: ${error.message}`, error.stack);
        }
    }
    async getTransactionLedger(transactionId) {
        try {
            return await this.transactionLedgerRepository.findOne({
                where: { transactionId }
            });
        }
        catch (error) {
            this.logger.error(`Failed to get transaction ledger: ${error.message}`, error.stack);
            return null;
        }
    }
};
exports.PaystackProvider = PaystackProvider;
exports.PaystackProvider = PaystackProvider = PaystackProvider_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(1, (0, typeorm_1.InjectRepository)(transaction_ledger_entity_1.TransactionLedger)),
    __param(2, (0, typeorm_1.InjectRepository)(booking_entity_1.Booking)),
    __metadata("design:paramtypes", [typeof (_a = typeof exchange_rate_service_1.ExchangeRateService !== "undefined" && exchange_rate_service_1.ExchangeRateService) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object])
], PaystackProvider);


/***/ }),
/* 89 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ExchangeRateService_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExchangeRateService = void 0;
const common_1 = __webpack_require__(2);
const axios_1 = __webpack_require__(54);
const rxjs_1 = __webpack_require__(55);
const transaction_ledger_entity_1 = __webpack_require__(90);
let ExchangeRateService = ExchangeRateService_1 = class ExchangeRateService {
    constructor(httpService) {
        this.httpService = httpService;
        this.logger = new common_1.Logger(ExchangeRateService_1.name);
        this.cache = new Map();
        this.CACHE_DURATION = 5 * 60 * 1000;
        this.API_ENDPOINT = {
            name: 'exchangeratesapi.io',
            url: 'https://api.exchangeratesapi.io/v1/latest',
            apiKey: process.env.EXCHANGE_RATES_API_KEY,
            format: (data, from, to) => {
                const rates = data.rates;
                const fromRate = rates[from] || 1;
                const toRate = rates[to] || 1;
                return toRate / fromRate;
            }
        };
    }
    async getExchangeRate(from, to) {
        if (from === to) {
            return {
                from,
                to,
                rate: 1.0,
                timestamp: new Date(),
                source: 'same_currency'
            };
        }
        const cacheKey = `${from}_${to}`;
        const cached = this.cache.get(cacheKey);
        if (cached && (Date.now() - cached.timestamp.getTime()) < this.CACHE_DURATION) {
            this.logger.log(`Using cached exchange rate: ${from} to ${to} = ${cached.rate}`);
            return {
                from,
                to,
                rate: cached.rate,
                timestamp: cached.timestamp,
                source: 'cache'
            };
        }
        if (!this.API_ENDPOINT.apiKey) {
            this.logger.warn(`No API key configured for ${this.API_ENDPOINT.name}`);
        }
        else {
            try {
                const rate = await this.fetchFromAPI(this.API_ENDPOINT, from, to);
                if (rate !== null) {
                    this.cache.set(cacheKey, { rate, timestamp: new Date() });
                    this.logger.log(`Exchange rate fetched from ${this.API_ENDPOINT.name}: ${from} to ${to} = ${rate}`);
                    return {
                        from,
                        to,
                        rate,
                        timestamp: new Date(),
                        source: this.API_ENDPOINT.name
                    };
                }
            }
            catch (error) {
                this.logger.warn(`Failed to fetch from ${this.API_ENDPOINT.name}: ${error.message}`);
            }
        }
        this.logger.warn('ExchangeRatesAPI.io failed, using fallback rates');
        const fallbackRate = this.getFallbackRate(from, to);
        return {
            from,
            to,
            rate: fallbackRate,
            timestamp: new Date(),
            source: 'fallback'
        };
    }
    async convertCurrency(request) {
        const exchangeRate = await this.getExchangeRate(request.from, request.to);
        return {
            originalAmount: request.amount,
            convertedAmount: request.amount * exchangeRate.rate,
            from: request.from,
            to: request.to,
            rate: exchangeRate.rate,
            timestamp: exchangeRate.timestamp
        };
    }
    async getUSDToKESRate() {
        const response = await this.getExchangeRate(transaction_ledger_entity_1.Currency.USD, transaction_ledger_entity_1.Currency.KES);
        return response.rate;
    }
    async getKESToUSDRate() {
        const response = await this.getExchangeRate(transaction_ledger_entity_1.Currency.KES, transaction_ledger_entity_1.Currency.USD);
        return response.rate;
    }
    async fetchFromAPI(endpoint, from, to) {
        try {
            const url = `${endpoint.url}?access_key=${endpoint.apiKey}&base=EUR&symbols=${from},${to}`;
            const response = await (0, rxjs_1.firstValueFrom)(this.httpService.get(url));
            if (response.data.success === false) {
                throw new Error(response.data.error?.info || 'API returned error');
            }
            return endpoint.format(response.data, from, to);
        }
        catch (error) {
            this.logger.error(`Error fetching from ${endpoint.name}: ${error.message}`);
            return null;
        }
    }
    getFallbackRate(from, to) {
        const fallbackRates = {
            [`${transaction_ledger_entity_1.Currency.USD}_${transaction_ledger_entity_1.Currency.KES}`]: 129.0,
            [`${transaction_ledger_entity_1.Currency.KES}_${transaction_ledger_entity_1.Currency.USD}`]: 0.0077,
            [`${transaction_ledger_entity_1.Currency.USD}_${transaction_ledger_entity_1.Currency.EUR}`]: 0.92,
            [`${transaction_ledger_entity_1.Currency.EUR}_${transaction_ledger_entity_1.Currency.USD}`]: 1.09,
            [`${transaction_ledger_entity_1.Currency.USD}_${transaction_ledger_entity_1.Currency.GBP}`]: 0.79,
            [`${transaction_ledger_entity_1.Currency.GBP}_${transaction_ledger_entity_1.Currency.USD}`]: 1.27,
        };
        const key = `${from}_${to}`;
        const rate = fallbackRates[key];
        if (rate) {
            this.logger.warn(`Using fallback rate for ${key}: ${rate}`);
            return rate;
        }
        this.logger.error(`No fallback rate found for ${key}, returning 1.0`);
        return 1.0;
    }
    clearCache() {
        this.cache.clear();
        this.logger.log('Exchange rate cache cleared');
    }
    getCacheStats() {
        return {
            size: this.cache.size,
            keys: Array.from(this.cache.keys())
        };
    }
};
exports.ExchangeRateService = ExchangeRateService;
exports.ExchangeRateService = ExchangeRateService = ExchangeRateService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof axios_1.HttpService !== "undefined" && axios_1.HttpService) === "function" ? _a : Object])
], ExchangeRateService);


/***/ }),
/* 90 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionLedger = exports.Currency = exports.TransactionStatus = exports.TransactionType = void 0;
const typeorm_1 = __webpack_require__(13);
const charters_company_entity_1 = __webpack_require__(31);
const payment_entity_1 = __webpack_require__(76);
const company_payment_account_entity_1 = __webpack_require__(91);
var TransactionType;
(function (TransactionType) {
    TransactionType["PAYMENT_RECEIVED"] = "payment_received";
    TransactionType["PLATFORM_FEE"] = "platform_fee";
    TransactionType["COMPANY_PAYOUT"] = "company_payout";
    TransactionType["REFUND"] = "refund";
    TransactionType["CHARGEBACK"] = "chargeback";
    TransactionType["ADJUSTMENT"] = "adjustment";
    TransactionType["TRANSFER"] = "transfer";
})(TransactionType || (exports.TransactionType = TransactionType = {}));
var TransactionStatus;
(function (TransactionStatus) {
    TransactionStatus["PENDING"] = "pending";
    TransactionStatus["PROCESSING"] = "processing";
    TransactionStatus["COMPLETED"] = "completed";
    TransactionStatus["FAILED"] = "failed";
    TransactionStatus["CANCELLED"] = "cancelled";
    TransactionStatus["REVERSED"] = "reversed";
})(TransactionStatus || (exports.TransactionStatus = TransactionStatus = {}));
var Currency;
(function (Currency) {
    Currency["USD"] = "USD";
    Currency["KES"] = "KES";
    Currency["EUR"] = "EUR";
    Currency["GBP"] = "GBP";
})(Currency || (exports.Currency = Currency = {}));
let TransactionLedger = class TransactionLedger {
};
exports.TransactionLedger = TransactionLedger;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], TransactionLedger.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'transactionId', type: 'varchar', length: 255, unique: true }),
    __metadata("design:type", String)
], TransactionLedger.prototype, "transactionId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'parentTransactionId', type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], TransactionLedger.prototype, "parentTransactionId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'companyId', type: 'int', nullable: true }),
    __metadata("design:type", Number)
], TransactionLedger.prototype, "companyId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'userId', type: 'int', nullable: true }),
    __metadata("design:type", Number)
], TransactionLedger.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'bookingId', nullable: true }),
    __metadata("design:type", String)
], TransactionLedger.prototype, "bookingId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'transactionType', type: 'enum', enum: TransactionType }),
    __metadata("design:type", String)
], TransactionLedger.prototype, "transactionType", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'paymentProvider', type: 'enum', enum: company_payment_account_entity_1.PaymentProvider }),
    __metadata("design:type", typeof (_a = typeof company_payment_account_entity_1.PaymentProvider !== "undefined" && company_payment_account_entity_1.PaymentProvider) === "function" ? _a : Object)
], TransactionLedger.prototype, "paymentProvider", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'providerTransactionId', type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], TransactionLedger.prototype, "providerTransactionId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'amount', type: 'decimal', precision: 15, scale: 2 }),
    __metadata("design:type", Number)
], TransactionLedger.prototype, "amount", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'currency', type: 'enum', enum: Currency, default: Currency.USD }),
    __metadata("design:type", String)
], TransactionLedger.prototype, "currency", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'exchangeRate', type: 'decimal', precision: 10, scale: 6, default: 1.0 }),
    __metadata("design:type", Number)
], TransactionLedger.prototype, "exchangeRate", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'baseAmount', type: 'decimal', precision: 15, scale: 2 }),
    __metadata("design:type", Number)
], TransactionLedger.prototype, "baseAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'fee', type: 'decimal', precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], TransactionLedger.prototype, "fee", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'tax', type: 'decimal', precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], TransactionLedger.prototype, "tax", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'netAmount', type: 'decimal', precision: 15, scale: 2 }),
    __metadata("design:type", Number)
], TransactionLedger.prototype, "netAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'status', type: 'enum', enum: TransactionStatus, default: TransactionStatus.PENDING }),
    __metadata("design:type", String)
], TransactionLedger.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'description', type: 'text', nullable: true }),
    __metadata("design:type", String)
], TransactionLedger.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'metadata', type: 'json', nullable: true }),
    __metadata("design:type", Object)
], TransactionLedger.prototype, "metadata", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'providerMetadata', type: 'json', nullable: true }),
    __metadata("design:type", Object)
], TransactionLedger.prototype, "providerMetadata", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'errorMessage', type: 'text', nullable: true }),
    __metadata("design:type", String)
], TransactionLedger.prototype, "errorMessage", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'processedAt', type: 'datetime', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], TransactionLedger.prototype, "processedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'settledAt', type: 'datetime', nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], TransactionLedger.prototype, "settledAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'reversedAt', type: 'datetime', nullable: true }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], TransactionLedger.prototype, "reversedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'reversalReason', type: 'text', nullable: true }),
    __metadata("design:type", String)
], TransactionLedger.prototype, "reversalReason", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'ipAddress', type: 'varchar', length: 45, nullable: true }),
    __metadata("design:type", String)
], TransactionLedger.prototype, "ipAddress", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'userAgent', type: 'text', nullable: true }),
    __metadata("design:type", String)
], TransactionLedger.prototype, "userAgent", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'isReconciled', type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], TransactionLedger.prototype, "isReconciled", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'reconciledAt', type: 'datetime', nullable: true }),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], TransactionLedger.prototype, "reconciledAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'reconciliationNotes', type: 'text', nullable: true }),
    __metadata("design:type", String)
], TransactionLedger.prototype, "reconciliationNotes", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_f = typeof Date !== "undefined" && Date) === "function" ? _f : Object)
], TransactionLedger.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_g = typeof Date !== "undefined" && Date) === "function" ? _g : Object)
], TransactionLedger.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => charters_company_entity_1.ChartersCompany, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'companyId' }),
    __metadata("design:type", typeof (_h = typeof charters_company_entity_1.ChartersCompany !== "undefined" && charters_company_entity_1.ChartersCompany) === "function" ? _h : Object)
], TransactionLedger.prototype, "company", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => payment_entity_1.Payment, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'parentTransactionId', referencedColumnName: 'transactionId' }),
    __metadata("design:type", typeof (_j = typeof payment_entity_1.Payment !== "undefined" && payment_entity_1.Payment) === "function" ? _j : Object)
], TransactionLedger.prototype, "parentTransaction", void 0);
exports.TransactionLedger = TransactionLedger = __decorate([
    (0, typeorm_1.Entity)('transaction_ledger'),
    (0, typeorm_1.Index)(['transactionId'], { unique: true }),
    (0, typeorm_1.Index)(['companyId', 'createdAt']),
    (0, typeorm_1.Index)(['paymentProvider', 'createdAt']),
    (0, typeorm_1.Index)(['transactionType', 'createdAt']),
    (0, typeorm_1.Index)(['status', 'createdAt']),
    (0, typeorm_1.Index)(['bookingId']),
    (0, typeorm_1.Index)(['userId'])
], TransactionLedger);


/***/ }),
/* 91 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompanyPaymentAccount = exports.AccountType = exports.AccountStatus = exports.PaymentProvider = void 0;
const typeorm_1 = __webpack_require__(13);
const charters_company_entity_1 = __webpack_require__(31);
var PaymentProvider;
(function (PaymentProvider) {
    PaymentProvider["STRIPE"] = "stripe";
    PaymentProvider["MPESA"] = "mpesa";
    PaymentProvider["PAYSTACK"] = "paystack";
})(PaymentProvider || (exports.PaymentProvider = PaymentProvider = {}));
var AccountStatus;
(function (AccountStatus) {
    AccountStatus["PENDING"] = "pending";
    AccountStatus["ACTIVE"] = "active";
    AccountStatus["SUSPENDED"] = "suspended";
    AccountStatus["REJECTED"] = "rejected";
})(AccountStatus || (exports.AccountStatus = AccountStatus = {}));
var AccountType;
(function (AccountType) {
    AccountType["EXPRESS"] = "express";
    AccountType["CUSTOM"] = "custom";
    AccountType["STANDARD"] = "standard";
})(AccountType || (exports.AccountType = AccountType = {}));
let CompanyPaymentAccount = class CompanyPaymentAccount {
};
exports.CompanyPaymentAccount = CompanyPaymentAccount;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], CompanyPaymentAccount.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'companyId', type: 'int' }),
    __metadata("design:type", Number)
], CompanyPaymentAccount.prototype, "companyId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'paymentProvider', type: 'enum', enum: PaymentProvider }),
    __metadata("design:type", String)
], CompanyPaymentAccount.prototype, "paymentProvider", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'accountType', type: 'enum', enum: AccountType, default: AccountType.EXPRESS }),
    __metadata("design:type", String)
], CompanyPaymentAccount.prototype, "accountType", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'accountId', type: 'varchar', length: 255, unique: true }),
    __metadata("design:type", String)
], CompanyPaymentAccount.prototype, "accountId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'accountStatus', type: 'enum', enum: AccountStatus, default: AccountStatus.PENDING }),
    __metadata("design:type", String)
], CompanyPaymentAccount.prototype, "accountStatus", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'verificationStatus', type: 'varchar', length: 50, default: 'pending' }),
    __metadata("design:type", String)
], CompanyPaymentAccount.prototype, "verificationStatus", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'country', type: 'varchar', length: 2 }),
    __metadata("design:type", String)
], CompanyPaymentAccount.prototype, "country", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'currency', type: 'varchar', length: 3, default: 'USD' }),
    __metadata("design:type", String)
], CompanyPaymentAccount.prototype, "currency", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'capabilities', type: 'json', nullable: true }),
    __metadata("design:type", Object)
], CompanyPaymentAccount.prototype, "capabilities", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'requirements', type: 'json', nullable: true }),
    __metadata("design:type", Object)
], CompanyPaymentAccount.prototype, "requirements", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'businessProfile', type: 'json', nullable: true }),
    __metadata("design:type", Object)
], CompanyPaymentAccount.prototype, "businessProfile", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'bankAccountInfo', type: 'json', nullable: true }),
    __metadata("design:type", Object)
], CompanyPaymentAccount.prototype, "bankAccountInfo", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'onboardingUrl', type: 'varchar', length: 500, nullable: true }),
    __metadata("design:type", String)
], CompanyPaymentAccount.prototype, "onboardingUrl", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'dashboardUrl', type: 'varchar', length: 500, nullable: true }),
    __metadata("design:type", String)
], CompanyPaymentAccount.prototype, "dashboardUrl", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'lastPayoutDate', type: 'datetime', nullable: true }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], CompanyPaymentAccount.prototype, "lastPayoutDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'totalPayouts', type: 'decimal', precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], CompanyPaymentAccount.prototype, "totalPayouts", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'pendingBalance', type: 'decimal', precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], CompanyPaymentAccount.prototype, "pendingBalance", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'availableBalance', type: 'decimal', precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], CompanyPaymentAccount.prototype, "availableBalance", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'metadata', type: 'json', nullable: true }),
    __metadata("design:type", Object)
], CompanyPaymentAccount.prototype, "metadata", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'paystackSubaccountId', type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], CompanyPaymentAccount.prototype, "paystackSubaccountId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'isActive', type: 'boolean', default: true }),
    __metadata("design:type", Boolean)
], CompanyPaymentAccount.prototype, "isActive", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], CompanyPaymentAccount.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], CompanyPaymentAccount.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => charters_company_entity_1.ChartersCompany, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'companyId' }),
    __metadata("design:type", typeof (_d = typeof charters_company_entity_1.ChartersCompany !== "undefined" && charters_company_entity_1.ChartersCompany) === "function" ? _d : Object)
], CompanyPaymentAccount.prototype, "company", void 0);
exports.CompanyPaymentAccount = CompanyPaymentAccount = __decorate([
    (0, typeorm_1.Entity)('company_payment_accounts')
], CompanyPaymentAccount);


/***/ }),
/* 92 */
/***/ ((module) => {

module.exports = require("paystack");

/***/ }),
/* 93 */
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),
/* 94 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BookingsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const bookings_service_1 = __webpack_require__(73);
const create_booking_dto_1 = __webpack_require__(95);
const jwt_auth_guard_1 = __webpack_require__(16);
const booking_entity_1 = __webpack_require__(29);
let BookingsController = class BookingsController {
    constructor(bookingsService) {
        this.bookingsService = bookingsService;
    }
    async testUser(userId) {
        return await this.bookingsService.testUserExists(userId);
    }
    async create(createBookingDto, req) {
        const result = await this.bookingsService.createWithPaymentIntent(createBookingDto, req.user.sub);
        return {
            success: true,
            message: 'Booking created successfully. Please complete payment to confirm.',
            data: result,
        };
    }
    async findAll(req, upcoming, status) {
        const bookings = await this.bookingsService.findByUserWithFilters(req.user.sub, { upcoming, status });
        return {
            success: true,
            message: 'Bookings retrieved successfully',
            data: bookings,
            count: bookings.length,
        };
    }
    async getStats(req) {
        const stats = await this.bookingsService.getBookingStats(req.user.sub);
        return {
            success: true,
            message: 'Booking statistics retrieved successfully',
            data: stats,
        };
    }
    async findByReference(reference) {
        const booking = await this.bookingsService.findByReference(reference);
        return {
            success: true,
            message: 'Booking retrieved successfully',
            data: booking,
        };
    }
    async findOne(id) {
        const booking = await this.bookingsService.findOne(id);
        return {
            success: true,
            message: 'Booking retrieved successfully',
            data: booking,
        };
    }
    async updateStatus(id, body) {
        const booking = await this.bookingsService.updateStatus(id, body.status);
        return {
            success: true,
            message: 'Booking status updated successfully',
            data: booking,
        };
    }
    async updatePaymentStatus(id, body) {
        const booking = await this.bookingsService.updatePaymentStatus(id, body.paymentStatus);
        return {
            success: true,
            message: 'Payment status updated successfully',
            data: booking,
        };
    }
    async cancel(id, req) {
        const booking = await this.bookingsService.cancel(id, req.user.sub);
        return {
            success: true,
            message: 'Booking cancelled successfully',
            data: booking,
        };
    }
    async confirmBooking(id, req, confirmData) {
        const result = await this.bookingsService.confirmBooking(id, req.user.sub, confirmData.paymentTransactionId);
        return {
            success: true,
            message: 'Booking confirmed successfully',
            data: result,
        };
    }
    async getPendingPaymentBookings(req) {
        const bookings = await this.bookingsService.findPendingPaymentBookings(req.user.sub);
        return {
            success: true,
            message: 'Pending payment bookings retrieved',
            data: bookings,
            count: bookings.length,
        };
    }
    async processPayment(id, req, paymentData) {
        const booking = await this.bookingsService.bookingPaymentService.processPayment(id, paymentData.paymentTransactionId, paymentData.paymentMethod, paymentData.amount);
        return {
            success: true,
            message: 'Payment processed successfully. Booking confirmed and loyalty points earned.',
            data: {
                id: booking.id,
                referenceNumber: booking.referenceNumber,
                bookingStatus: booking.bookingStatus,
                paymentStatus: booking.paymentStatus,
            },
        };
    }
    async completePayment(id, req, body) {
        const payment = await this.bookingsService.paymentProviderService.confirmPayment({
            paymentIntentId: body.paymentIntentId,
            paymentMethodId: body.paymentMethodId,
        });
        const booking = await this.bookingsService.bookingPaymentService.processPayment(id, payment.transactionId, payment.paymentMethod, payment.amount);
        return {
            success: true,
            message: 'Payment completed and booking confirmed',
            data: {
                booking,
                payment: {
                    id: payment.id,
                    transactionId: payment.transactionId,
                    amount: payment.amount,
                    status: payment.status,
                    paymentMethod: payment.paymentMethod,
                },
            },
        };
    }
    async processRefund(id, req, refundData) {
        const booking = await this.bookingsService.bookingPaymentService.processRefund(id, refundData.refundAmount, refundData.refundReason);
        return {
            success: true,
            message: 'Refund processed successfully. Loyalty points adjusted accordingly.',
            data: {
                id: booking.id,
                bookingStatus: booking.bookingStatus,
                paymentStatus: booking.paymentStatus,
                refundAmount: refundData.refundAmount,
                refundReason: refundData.refundReason,
            },
        };
    }
    async remove(id) {
        await this.bookingsService.remove(id);
        return {
            success: true,
            message: 'Booking deleted successfully',
        };
    }
    async getBookingStatus(reference) {
        const bookingStatus = await this.bookingsService.getBookingStatusByReference(reference);
        return {
            success: true,
            message: 'Booking status retrieved successfully',
            data: bookingStatus,
        };
    }
    async getBookingTimeline(id, req) {
        const booking = await this.bookingsService.findOne(id);
        if (booking.userId !== req.user.sub) {
            throw new common_1.BadRequestException('You can only view your own booking timeline');
        }
        const timeline = await this.bookingsService.getBookingTimeline(id);
        return {
            success: true,
            message: 'Booking timeline retrieved successfully',
            data: timeline,
        };
    }
    async confirmBookingAfterPayment(id, body, req) {
        const booking = await this.bookingsService.findOne(id);
        if (booking.userId !== req.user.sub) {
            throw new common_1.BadRequestException('You can only confirm your own bookings');
        }
        const updatedBooking = await this.bookingsService.confirmBookingAfterPayment(id, body.paymentReference);
        return {
            success: true,
            message: 'Booking confirmed successfully',
            data: {
                id: updatedBooking.id,
                bookingStatus: updatedBooking.bookingStatus,
                paymentStatus: updatedBooking.paymentStatus,
                referenceNumber: updatedBooking.referenceNumber,
            },
        };
    }
    async createPaymentIntentForInquiry(id, req) {
        const booking = await this.bookingsService.findOne(id);
        if (booking.userId !== req.user.sub) {
            throw new common_1.BadRequestException('You can only create payment intents for your own bookings');
        }
        if (booking.bookingStatus !== 'pending' && booking.bookingStatus !== 'priced') {
            throw new common_1.BadRequestException('Booking is not in a payable state');
        }
        if (booking.totalPrice <= 0) {
            throw new common_1.BadRequestException('Booking has no price set. Please contact support.');
        }
        if (booking.paymentStatus === 'paid') {
            throw new common_1.BadRequestException('Booking is already paid');
        }
        const result = await this.bookingsService.createPaymentIntentForInquiry(id);
        return {
            success: true,
            message: 'Payment intent created successfully',
            data: result,
        };
    }
};
exports.BookingsController = BookingsController;
__decorate([
    (0, common_1.Get)('test-user/:userId'),
    (0, swagger_1.ApiOperation)({ summary: 'Test if user exists in database' }),
    __param(0, (0, common_1.Param)('userId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "testUser", null);
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new booking with passengers and payment intent' }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Booking created successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'object',
                    properties: {
                        booking: { $ref: '#/components/schemas/Booking' },
                        paymentIntent: {
                            type: 'object',
                            properties: {
                                id: { type: 'string' },
                                clientSecret: { type: 'string' },
                                status: { type: 'string' },
                                requiresAction: { type: 'boolean' },
                                nextAction: { type: 'object' },
                            },
                        },
                        paymentInstructions: {
                            type: 'object',
                            properties: {
                                amount: { type: 'number' },
                                currency: { type: 'string' },
                                paymentMethods: { type: 'array', items: { type: 'string' } },
                                nextSteps: { type: 'array', items: { type: 'string' } },
                                apiEndpoints: { type: 'object' },
                            },
                        },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad request - Invalid booking data' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof create_booking_dto_1.CreateBookingDto !== "undefined" && create_booking_dto_1.CreateBookingDto) === "function" ? _b : Object, Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all bookings for the authenticated user' }),
    (0, swagger_1.ApiQuery)({
        name: 'upcoming',
        required: false,
        type: Boolean,
        description: 'Filter upcoming (true) or past (false) bookings'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'status',
        required: false,
        enum: booking_entity_1.BookingStatus,
        description: 'Filter by booking status'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Bookings retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'array',
                    items: { $ref: '#/components/schemas/Booking' },
                },
                count: { type: 'number' },
            },
        },
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Query)('upcoming')),
    __param(2, (0, common_1.Query)('status')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Boolean, typeof (_c = typeof booking_entity_1.BookingStatus !== "undefined" && booking_entity_1.BookingStatus) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)('stats'),
    (0, swagger_1.ApiOperation)({ summary: 'Get booking statistics' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Booking statistics retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'object',
                    properties: {
                        total: { type: 'number' },
                        pending: { type: 'number' },
                        confirmed: { type: 'number' },
                        cancelled: { type: 'number' },
                        completed: { type: 'number' },
                    },
                },
            },
        },
    }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "getStats", null);
__decorate([
    (0, common_1.Get)('reference/:reference'),
    (0, swagger_1.ApiOperation)({ summary: 'Get booking by reference number' }),
    (0, swagger_1.ApiParam)({ name: 'reference', type: String, description: 'Booking reference number' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Booking retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: { $ref: '#/components/schemas/Booking' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Booking not found' }),
    __param(0, (0, common_1.Param)('reference')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "findByReference", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, swagger_1.ApiOperation)({ summary: 'Get booking by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: String, description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Booking retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: { $ref: '#/components/schemas/Booking' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Booking not found' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':id/status'),
    (0, swagger_1.ApiOperation)({ summary: 'Update booking status' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: String, description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Booking status updated successfully',
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "updateStatus", null);
__decorate([
    (0, common_1.Patch)(':id/payment-status'),
    (0, swagger_1.ApiOperation)({ summary: 'Update payment status' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: String, description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Payment status updated successfully',
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "updatePaymentStatus", null);
__decorate([
    (0, common_1.Patch)(':id/cancel'),
    (0, swagger_1.ApiOperation)({ summary: 'Cancel a booking' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: String, description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Booking cancelled successfully',
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Booking cannot be cancelled' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "cancel", null);
__decorate([
    (0, common_1.Post)(':id/confirm'),
    (0, swagger_1.ApiOperation)({ summary: 'Confirm booking after payment' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: String, description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Booking confirmed successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'object',
                    properties: {
                        id: { type: 'string' },
                        referenceNumber: { type: 'string' },
                        bookingStatus: { type: 'string' },
                        paymentStatus: { type: 'string' },
                        confirmationEmail: { type: 'string' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Booking cannot be confirmed' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Booking not found' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Request)()),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "confirmBooking", null);
__decorate([
    (0, common_1.Get)('pending-payment'),
    (0, swagger_1.ApiOperation)({ summary: 'Get bookings pending payment' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Pending payment bookings retrieved',
    }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "getPendingPaymentBookings", null);
__decorate([
    (0, common_1.Post)(':id/process-payment'),
    (0, swagger_1.ApiOperation)({ summary: 'Process payment for a booking and populate points/reference' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Payment processed successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'object',
                    properties: {
                        id: { type: 'string' },
                        referenceNumber: { type: 'string' },
                        bookingStatus: { type: 'string' },
                        paymentStatus: { type: 'string' },
                        loyaltyPointsEarned: { type: 'number' },
                        paymentTransactionId: { type: 'string' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad request - Payment processing failed' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Booking not found' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Request)()),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "processPayment", null);
__decorate([
    (0, common_1.Post)(':id/pay'),
    (0, swagger_1.ApiOperation)({ summary: 'Complete payment for booking with Stripe integration' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Payment completed and booking confirmed',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'object',
                    properties: {
                        booking: { $ref: '#/components/schemas/Booking' },
                        payment: {
                            type: 'object',
                            properties: {
                                id: { type: 'string' },
                                transactionId: { type: 'string' },
                                amount: { type: 'number' },
                                status: { type: 'string' },
                                paymentMethod: { type: 'string' },
                            },
                        },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad request - Payment failed' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Booking not found' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Request)()),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "completePayment", null);
__decorate([
    (0, common_1.Post)(':id/refund'),
    (0, swagger_1.ApiOperation)({ summary: 'Process refund for a booking and adjust loyalty points' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Refund processed successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'object',
                    properties: {
                        id: { type: 'string' },
                        bookingStatus: { type: 'string' },
                        paymentStatus: { type: 'string' },
                        refundAmount: { type: 'number' },
                        loyaltyPointsDeducted: { type: 'number' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad request - Refund processing failed' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Booking not found' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Request)()),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "processRefund", null);
__decorate([
    (0, common_1.Delete)(':id'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete a booking' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: String, description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Booking deleted successfully',
    }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "remove", null);
__decorate([
    (0, common_1.Get)('status/:reference'),
    (0, swagger_1.ApiOperation)({ summary: 'Get booking status by reference number (public)' }),
    (0, swagger_1.ApiParam)({ name: 'reference', type: String, description: 'Booking reference number' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Booking status retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: { $ref: '#/components/schemas/BookingStatusResponseDto' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Booking not found' }),
    __param(0, (0, common_1.Param)('reference')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "getBookingStatus", null);
__decorate([
    (0, common_1.Get)(':id/timeline'),
    (0, swagger_1.ApiOperation)({ summary: 'Get booking timeline' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: String, description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Booking timeline retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'number' },
                            eventType: { type: 'string' },
                            title: { type: 'string' },
                            description: { type: 'string' },
                            oldValue: { type: 'string' },
                            newValue: { type: 'string' },
                            createdAt: { type: 'string', format: 'date-time' },
                        },
                    },
                },
            },
        },
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "getBookingTimeline", null);
__decorate([
    (0, common_1.Patch)(':id/confirm-payment'),
    (0, swagger_1.ApiOperation)({ summary: 'Confirm booking after successful payment' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Booking confirmed successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'object',
                    properties: {
                        id: { type: 'string' },
                        bookingStatus: { type: 'string' },
                        paymentStatus: { type: 'string' },
                        paymentTransactionId: { type: 'string' },
                    },
                },
            },
        },
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "confirmBookingAfterPayment", null);
__decorate([
    (0, common_1.Post)(':id/create-payment-intent'),
    (0, swagger_1.ApiOperation)({ summary: 'Create payment intent for a pending inquiry' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Booking ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Payment intent created successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'object',
                    properties: {
                        paymentIntent: {
                            type: 'object',
                            properties: {
                                id: { type: 'string' },
                                clientSecret: { type: 'string' },
                                status: { type: 'string' },
                                requiresAction: { type: 'boolean' },
                                nextAction: { type: 'object' },
                            },
                        },
                        booking: {
                            type: 'object',
                            properties: {
                                id: { type: 'string' },
                                totalPrice: { type: 'number' },
                                referenceNumber: { type: 'string' },
                            },
                        },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad request - booking not found or not payable' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], BookingsController.prototype, "createPaymentIntentForInquiry", null);
exports.BookingsController = BookingsController = __decorate([
    (0, swagger_1.ApiTags)('Bookings'),
    (0, common_1.Controller)('bookings'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof bookings_service_1.BookingsService !== "undefined" && bookings_service_1.BookingsService) === "function" ? _a : Object])
], BookingsController);


/***/ }),
/* 95 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateBookingDto = exports.PassengerDataDto = void 0;
const class_validator_1 = __webpack_require__(19);
const class_transformer_1 = __webpack_require__(96);
const swagger_1 = __webpack_require__(3);
class PassengerDataDto {
}
exports.PassengerDataDto = PassengerDataDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], PassengerDataDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], PassengerDataDto.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(120),
    __metadata("design:type", Number)
], PassengerDataDto.prototype, "age", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PassengerDataDto.prototype, "nationality", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PassengerDataDto.prototype, "idPassportNumber", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], PassengerDataDto.prototype, "isUser", void 0);
class CreateBookingDto {
}
exports.CreateBookingDto = CreateBookingDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], CreateBookingDto.prototype, "dealId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], CreateBookingDto.prototype, "experienceScheduleId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], CreateBookingDto.prototype, "totalPrice", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], CreateBookingDto.prototype, "onboardDining", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBookingDto.prototype, "specialRequirements", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBookingDto.prototype, "billingRegion", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        type: [PassengerDataDto],
        description: 'Additional passengers (the booking user will be automatically added as the first passenger if not already included)'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => PassengerDataDto),
    __metadata("design:type", Array)
], CreateBookingDto.prototype, "passengers", void 0);


/***/ }),
/* 96 */
/***/ ((module) => {

module.exports = require("class-transformer");

/***/ }),
/* 97 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WalletModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const wallet_transaction_entity_1 = __webpack_require__(28);
const user_entity_1 = __webpack_require__(14);
const wallet_service_1 = __webpack_require__(78);
const wallet_controller_1 = __webpack_require__(98);
let WalletModule = class WalletModule {
};
exports.WalletModule = WalletModule;
exports.WalletModule = WalletModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([wallet_transaction_entity_1.WalletTransaction, user_entity_1.User]),
        ],
        controllers: [wallet_controller_1.WalletController],
        providers: [wallet_service_1.WalletService],
        exports: [wallet_service_1.WalletService],
    })
], WalletModule);


/***/ }),
/* 98 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WalletController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const jwt_auth_guard_1 = __webpack_require__(16);
const wallet_service_1 = __webpack_require__(78);
let WalletController = class WalletController {
    constructor(walletService) {
        this.walletService = walletService;
    }
    async getUserTransactions(req, page = '1', limit = '10') {
        const userId = req.user.id;
        return await this.walletService.getUserTransactions(userId, parseInt(page), parseInt(limit));
    }
    async getLoyaltyTransactions(req, page = '1', limit = '10') {
        const userId = req.user.id;
        return await this.walletService.getLoyaltyTransactions(userId, parseInt(page), parseInt(limit));
    }
    async getMonetaryTransactions(req, page = '1', limit = '10') {
        const userId = req.user.id;
        return await this.walletService.getMonetaryTransactions(userId, parseInt(page), parseInt(limit));
    }
    async getLoyaltySummary(req) {
        const userId = req.user.id;
        return await this.walletService.getLoyaltySummary(userId);
    }
    async earnLoyaltyPoints(req, body) {
        const userId = req.user.id;
        return await this.walletService.earnLoyaltyPoints(userId, body.points, body.description, body.bookingId, body.expiresAt ? new Date(body.expiresAt) : undefined);
    }
    async earnLoyaltyPointsFromSpending(req, body) {
        const userId = req.user.id;
        return await this.walletService.earnLoyaltyPointsFromSpending(userId, body.usdAmount, body.description, body.bookingId, body.expiresAt ? new Date(body.expiresAt) : undefined);
    }
    async redeemLoyaltyPoints(req, body) {
        const userId = req.user.id;
        return await this.walletService.redeemLoyaltyPoints(userId, body.miles, body.description, body.bookingId);
    }
    async depositMoney(req, body) {
        const userId = req.user.id;
        return await this.walletService.depositMoney(userId, body.amount, body.description, body.paymentMethod, body.paymentReference);
    }
    async withdrawMoney(req, body) {
        const userId = req.user.id;
        return await this.walletService.withdrawMoney(userId, body.amount, body.description, body.paymentMethod, body.paymentReference);
    }
};
exports.WalletController = WalletController;
__decorate([
    (0, common_1.Get)('transactions'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user wallet transactions' }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Transactions retrieved successfully' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Query)('page')),
    __param(2, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, String]),
    __metadata("design:returntype", Promise)
], WalletController.prototype, "getUserTransactions", null);
__decorate([
    (0, common_1.Get)('loyalty/transactions'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user loyalty transactions' }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Loyalty transactions retrieved successfully' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Query)('page')),
    __param(2, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, String]),
    __metadata("design:returntype", Promise)
], WalletController.prototype, "getLoyaltyTransactions", null);
__decorate([
    (0, common_1.Get)('money/transactions'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user monetary transactions' }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Monetary transactions retrieved successfully' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Query)('page')),
    __param(2, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, String]),
    __metadata("design:returntype", Promise)
], WalletController.prototype, "getMonetaryTransactions", null);
__decorate([
    (0, common_1.Get)('loyalty/summary'),
    (0, swagger_1.ApiOperation)({ summary: 'Get loyalty points summary with conversion rates' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Loyalty summary retrieved successfully' }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], WalletController.prototype, "getLoyaltySummary", null);
__decorate([
    (0, common_1.Post)('loyalty/earn'),
    (0, swagger_1.ApiOperation)({ summary: 'Earn loyalty points (direct miles)' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Loyalty points earned successfully' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], WalletController.prototype, "earnLoyaltyPoints", null);
__decorate([
    (0, common_1.Post)('loyalty/earn-from-spending'),
    (0, swagger_1.ApiOperation)({ summary: 'Earn loyalty points from USD spending (1 USD = 5 miles)' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Loyalty points earned from spending successfully' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], WalletController.prototype, "earnLoyaltyPointsFromSpending", null);
__decorate([
    (0, common_1.Post)('loyalty/redeem'),
    (0, swagger_1.ApiOperation)({ summary: 'Redeem loyalty points for USD discount (100 miles = $1 off)' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Loyalty points redeemed successfully' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], WalletController.prototype, "redeemLoyaltyPoints", null);
__decorate([
    (0, common_1.Post)('deposit'),
    (0, swagger_1.ApiOperation)({ summary: 'Deposit money to wallet' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Money deposited successfully' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], WalletController.prototype, "depositMoney", null);
__decorate([
    (0, common_1.Post)('withdraw'),
    (0, swagger_1.ApiOperation)({ summary: 'Withdraw money from wallet' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Money withdrawn successfully' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], WalletController.prototype, "withdrawMoney", null);
exports.WalletController = WalletController = __decorate([
    (0, swagger_1.ApiTags)('Wallet'),
    (0, common_1.Controller)('wallet'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof wallet_service_1.WalletService !== "undefined" && wallet_service_1.WalletService) === "function" ? _a : Object])
], WalletController);


/***/ }),
/* 99 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaymentsModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const config_1 = __webpack_require__(5);
const axios_1 = __webpack_require__(54);
const payments_controller_1 = __webpack_require__(100);
const mpesa_callback_controller_1 = __webpack_require__(105);
const payments_service_1 = __webpack_require__(101);
const payment_provider_service_1 = __webpack_require__(83);
const stripe_provider_1 = __webpack_require__(85);
const mpesa_provider_1 = __webpack_require__(87);
const paystack_provider_1 = __webpack_require__(88);
const stripe_connect_provider_1 = __webpack_require__(106);
const mpesa_merchant_provider_1 = __webpack_require__(107);
const company_onboarding_service_1 = __webpack_require__(109);
const unified_payment_service_1 = __webpack_require__(110);
const exchange_rate_service_1 = __webpack_require__(89);
const stripe_connect_controller_1 = __webpack_require__(116);
const mpesa_merchant_controller_1 = __webpack_require__(118);
const unified_payment_controller_1 = __webpack_require__(119);
const paystack_controller_1 = __webpack_require__(120);
const exchange_rate_controller_1 = __webpack_require__(121);
const payment_entity_1 = __webpack_require__(76);
const booking_entity_1 = __webpack_require__(29);
const company_payment_account_entity_1 = __webpack_require__(91);
const charters_company_entity_1 = __webpack_require__(31);
const transaction_ledger_entity_1 = __webpack_require__(90);
const commission_module_1 = __webpack_require__(122);
let PaymentsModule = class PaymentsModule {
};
exports.PaymentsModule = PaymentsModule;
exports.PaymentsModule = PaymentsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([payment_entity_1.Payment, booking_entity_1.Booking, company_payment_account_entity_1.CompanyPaymentAccount, charters_company_entity_1.ChartersCompany, transaction_ledger_entity_1.TransactionLedger]),
            config_1.ConfigModule,
            axios_1.HttpModule,
            commission_module_1.CommissionModule,
        ],
        controllers: [payments_controller_1.PaymentsController, mpesa_callback_controller_1.MpesaCallbackController, stripe_connect_controller_1.StripeConnectController, mpesa_merchant_controller_1.MpesaMerchantController, unified_payment_controller_1.UnifiedPaymentController, paystack_controller_1.PaystackController, exchange_rate_controller_1.ExchangeRateController],
        providers: [
            payments_service_1.PaymentsService,
            payment_provider_service_1.PaymentProviderService,
            stripe_provider_1.StripeProvider,
            mpesa_provider_1.MpesaProvider,
            paystack_provider_1.PaystackProvider,
            stripe_connect_provider_1.StripeConnectProvider,
            mpesa_merchant_provider_1.MpesaMerchantProvider,
            company_onboarding_service_1.CompanyOnboardingService,
            unified_payment_service_1.UnifiedPaymentService,
            exchange_rate_service_1.ExchangeRateService,
        ],
        exports: [
            payments_service_1.PaymentsService,
            payment_provider_service_1.PaymentProviderService,
            stripe_provider_1.StripeProvider,
            mpesa_provider_1.MpesaProvider,
            paystack_provider_1.PaystackProvider,
            stripe_connect_provider_1.StripeConnectProvider,
            mpesa_merchant_provider_1.MpesaMerchantProvider,
            company_onboarding_service_1.CompanyOnboardingService,
            unified_payment_service_1.UnifiedPaymentService,
            exchange_rate_service_1.ExchangeRateService,
        ],
    })
], PaymentsModule);


/***/ }),
/* 100 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaymentsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const jwt_auth_guard_1 = __webpack_require__(16);
const payments_service_1 = __webpack_require__(101);
const payment_provider_service_1 = __webpack_require__(83);
const dto_1 = __webpack_require__(102);
const current_user_decorator_1 = __webpack_require__(104);
const user_entity_1 = __webpack_require__(14);
const payment_provider_interface_1 = __webpack_require__(84);
const mpesa_provider_1 = __webpack_require__(87);
const rate_limit_decorator_1 = __webpack_require__(21);
let PaymentsController = class PaymentsController {
    constructor(paymentsService, paymentProviderService, mpesaProvider) {
        this.paymentsService = paymentsService;
        this.paymentProviderService = paymentProviderService;
        this.mpesaProvider = mpesaProvider;
    }
    async createPaymentIntent(user, body) {
        const paymentIntent = await this.paymentProviderService.createPaymentIntent({
            amount: body.amount,
            currency: body.currency || 'USD',
            bookingId: body.bookingId,
            userId: user.id,
            description: `Payment for booking ${body.bookingId}`,
            metadata: {
                paymentMethod: body.paymentMethod,
            },
        });
        return {
            success: true,
            message: 'Payment intent created successfully',
            data: {
                paymentIntentId: paymentIntent.id,
                clientSecret: paymentIntent.clientSecret,
                status: paymentIntent.status,
                requiresAction: paymentIntent.requiresAction,
                nextAction: paymentIntent.nextAction,
            },
        };
    }
    async confirmPayment(user, body) {
        const payment = await this.paymentProviderService.confirmPayment({
            paymentIntentId: body.paymentIntentId,
            paymentMethodId: body.paymentMethodId,
        });
        return {
            success: true,
            message: 'Payment confirmed successfully',
            data: payment,
        };
    }
    async getPaymentStatus(paymentIntentId) {
        const payment = await this.paymentProviderService.getPaymentStatus(paymentIntentId);
        return {
            success: true,
            data: payment,
        };
    }
    async getPaymentProviders() {
        const providers = this.paymentProviderService.getSupportedProviders();
        const providerInfo = providers.map(type => this.paymentProviderService.getProviderInfo(type));
        return {
            success: true,
            data: {
                providers: providerInfo,
                defaultProvider: payment_provider_interface_1.PaymentProviderType.PAYSTACK,
            },
        };
    }
    async createRefund(paymentIntentId, body) {
        const refund = await this.paymentProviderService.createRefund(paymentIntentId, body.amount, body.reason);
        return {
            success: true,
            message: 'Refund created successfully',
            data: refund,
        };
    }
    async create(user, createPaymentDto) {
        const payment = await this.paymentsService.createFromBooking(user.id, createPaymentDto);
        return {
            success: true,
            message: 'Payment created successfully',
            data: payment,
        };
    }
    async findUserPayments(user) {
        const payments = await this.paymentsService.findByUser(user.id);
        return {
            success: true,
            data: payments,
        };
    }
    async findByBooking(bookingId) {
        const payments = await this.paymentsService.findByBooking(bookingId);
        return {
            success: true,
            data: payments,
        };
    }
    async getStats(companyId) {
        const stats = await this.paymentsService.getPaymentStats(companyId);
        return {
            success: true,
            data: stats,
        };
    }
    async findOne(id) {
        const payment = await this.paymentsService.findOne(id);
        return {
            success: true,
            data: payment,
        };
    }
    async updateStatus(id, updateData) {
        const payment = await this.paymentsService.updateStatus(id, updateData.status, updateData.transactionId);
        return {
            success: true,
            message: 'Payment status updated successfully',
            data: payment,
        };
    }
    async updateGatewayResponse(id, gatewayResponse) {
        const payment = await this.paymentsService.updateGatewayResponse(id, gatewayResponse);
        return {
            success: true,
            message: 'Gateway response updated successfully',
            data: payment,
        };
    }
    async refund(id) {
        const payment = await this.paymentsService.processRefund(id);
        return {
            success: true,
            message: 'Refund processed successfully',
            data: payment,
        };
    }
    async initiateMpesaPayment(user, body) {
        const paymentIntent = await this.paymentProviderService.createPaymentIntent({
            amount: body.amount,
            currency: 'KES',
            bookingId: body.bookingId,
            userId: user.id,
            description: body.description || `Payment for booking ${body.bookingId}`,
            metadata: {
                phoneNumber: body.phoneNumber,
            },
        }, payment_provider_interface_1.PaymentProviderType.MPESA);
        return {
            success: true,
            message: 'M-Pesa STK Push initiated successfully',
            data: {
                paymentIntentId: paymentIntent.id,
                status: paymentIntent.status,
                requiresAction: paymentIntent.requiresAction,
                nextAction: paymentIntent.nextAction,
            },
        };
    }
};
exports.PaymentsController = PaymentsController;
__decorate([
    (0, common_1.Post)('create-intent'),
    (0, rate_limit_decorator_1.RateLimit)(rate_limit_decorator_1.RateLimitConfigs.PAYMENT),
    (0, swagger_1.ApiOperation)({ summary: 'Create a payment intent for booking' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.CREATED, description: 'Payment intent created successfully' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'Invalid payment data' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _d : Object, Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "createPaymentIntent", null);
__decorate([
    (0, common_1.Post)('confirm'),
    (0, rate_limit_decorator_1.RateLimit)(rate_limit_decorator_1.RateLimitConfigs.PAYMENT),
    (0, swagger_1.ApiOperation)({ summary: 'Confirm a payment intent' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Payment confirmed successfully' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'Payment confirmation failed' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_e = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _e : Object, Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "confirmPayment", null);
__decorate([
    (0, common_1.Get)('status/:paymentIntentId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get payment status' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Payment status retrieved successfully' }),
    __param(0, (0, common_1.Param)('paymentIntentId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "getPaymentStatus", null);
__decorate([
    (0, common_1.Get)('providers'),
    (0, swagger_1.ApiOperation)({ summary: 'Get available payment providers' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Payment providers retrieved successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "getPaymentProviders", null);
__decorate([
    (0, common_1.Post)('refund/:paymentIntentId'),
    (0, swagger_1.ApiOperation)({ summary: 'Create a refund' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Refund created successfully' }),
    __param(0, (0, common_1.Param)('paymentIntentId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "createRefund", null);
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new payment (Legacy)' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.CREATED, description: 'Payment created successfully' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'Invalid payment data' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_f = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _f : Object, typeof (_g = typeof dto_1.CreatePaymentDto !== "undefined" && dto_1.CreatePaymentDto) === "function" ? _g : Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all payments for current user' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Payments retrieved successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_h = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _h : Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "findUserPayments", null);
__decorate([
    (0, common_1.Get)('booking/:bookingId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get payments for a specific booking' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Booking payments retrieved successfully' }),
    __param(0, (0, common_1.Param)('bookingId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "findByBooking", null);
__decorate([
    (0, common_1.Get)('stats'),
    (0, swagger_1.ApiOperation)({ summary: 'Get payment statistics' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Payment stats retrieved successfully' }),
    __param(0, (0, common_1.Query)('companyId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "getStats", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, swagger_1.ApiOperation)({ summary: 'Get payment by ID' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Payment retrieved successfully' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: 'Payment not found' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "findOne", null);
__decorate([
    (0, common_1.Put)(':id/status'),
    (0, swagger_1.ApiOperation)({ summary: 'Update payment status' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Payment status updated successfully' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: 'Payment not found' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "updateStatus", null);
__decorate([
    (0, common_1.Put)(':id/gateway-response'),
    (0, swagger_1.ApiOperation)({ summary: 'Update payment gateway response' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Gateway response updated successfully' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "updateGatewayResponse", null);
__decorate([
    (0, common_1.Put)(':id/refund'),
    (0, swagger_1.ApiOperation)({ summary: 'Process payment refund (Legacy)' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Refund processed successfully' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'Payment cannot be refunded' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "refund", null);
__decorate([
    (0, common_1.Post)('mpesa/stk-push'),
    (0, swagger_1.ApiOperation)({ summary: 'Initiate M-Pesa STK Push payment' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.CREATED, description: 'STK Push initiated successfully' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'STK Push failed' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_j = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _j : Object, Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "initiateMpesaPayment", null);
exports.PaymentsController = PaymentsController = __decorate([
    (0, swagger_1.ApiTags)('payments'),
    (0, swagger_1.ApiBearerAuth)(),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, common_1.Controller)('payments'),
    __metadata("design:paramtypes", [typeof (_a = typeof payments_service_1.PaymentsService !== "undefined" && payments_service_1.PaymentsService) === "function" ? _a : Object, typeof (_b = typeof payment_provider_service_1.PaymentProviderService !== "undefined" && payment_provider_service_1.PaymentProviderService) === "function" ? _b : Object, typeof (_c = typeof mpesa_provider_1.MpesaProvider !== "undefined" && mpesa_provider_1.MpesaProvider) === "function" ? _c : Object])
], PaymentsController);


/***/ }),
/* 101 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaymentsService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const payment_entity_1 = __webpack_require__(76);
const booking_entity_1 = __webpack_require__(29);
let PaymentsService = class PaymentsService {
    constructor(paymentRepository, bookingRepository) {
        this.paymentRepository = paymentRepository;
        this.bookingRepository = bookingRepository;
    }
    async create(userId, companyId, createPaymentDto) {
        const paymentId = `payment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const companyAmount = createPaymentDto.totalAmount - createPaymentDto.platformFee;
        if (companyAmount < 0) {
            throw new common_1.BadRequestException('Platform fee cannot exceed total amount');
        }
        const payment = this.paymentRepository.create({
            id: paymentId,
            userId,
            companyId,
            companyAmount,
            currency: createPaymentDto.currency || 'USD',
            ...createPaymentDto,
        });
        return await this.paymentRepository.save(payment);
    }
    async createFromBooking(userId, createPaymentDto) {
        const booking = await this.bookingRepository.findOne({
            where: { id: parseInt(createPaymentDto.bookingId) },
            select: ['id', 'companyId']
        });
        if (!booking) {
            throw new common_1.NotFoundException('Booking not found');
        }
        return this.create(userId, booking.companyId, createPaymentDto);
    }
    async findAll() {
        return await this.paymentRepository.find({
            relations: ['user', 'company'],
            order: { createdAt: 'DESC' },
        });
    }
    async findByUser(userId) {
        return await this.paymentRepository.find({
            where: { userId },
            relations: ['user', 'company'],
            order: { createdAt: 'DESC' },
        });
    }
    async findByBooking(bookingId) {
        return await this.paymentRepository.find({
            where: { bookingId },
            relations: ['user', 'company'],
            order: { createdAt: 'DESC' },
        });
    }
    async findOne(id) {
        const payment = await this.paymentRepository.findOne({
            where: { id },
            relations: ['user', 'company'],
        });
        if (!payment) {
            throw new common_1.NotFoundException(`Payment with ID ${id} not found`);
        }
        return payment;
    }
    async updateStatus(id, status, transactionId) {
        const payment = await this.findOne(id);
        payment.paymentStatus = status;
        if (transactionId) {
            payment.transactionId = transactionId;
        }
        return await this.paymentRepository.save(payment);
    }
    async updateGatewayResponse(id, gatewayResponse) {
        const payment = await this.findOne(id);
        payment.paymentGatewayResponse = gatewayResponse;
        return await this.paymentRepository.save(payment);
    }
    async processRefund(id) {
        const payment = await this.findOne(id);
        if (!payment.canBeRefunded) {
            throw new common_1.BadRequestException('Payment cannot be refunded');
        }
        payment.paymentStatus = payment_entity_1.PaymentStatus.REFUNDED;
        return await this.paymentRepository.save(payment);
    }
    async getPaymentStats(companyId) {
        const queryBuilder = this.paymentRepository.createQueryBuilder('payment');
        if (companyId) {
            queryBuilder.where('payment.companyId = :companyId', { companyId });
        }
        const [totalPayments, completedPayments, pendingPayments, failedPayments, refundedPayments, totalRevenue,] = await Promise.all([
            queryBuilder.getCount(),
            queryBuilder.clone().andWhere('payment.paymentStatus = :status', { status: payment_entity_1.PaymentStatus.COMPLETED }).getCount(),
            queryBuilder.clone().andWhere('payment.paymentStatus = :status', { status: payment_entity_1.PaymentStatus.PENDING }).getCount(),
            queryBuilder.clone().andWhere('payment.paymentStatus = :status', { status: payment_entity_1.PaymentStatus.FAILED }).getCount(),
            queryBuilder.clone().andWhere('payment.paymentStatus = :status', { status: payment_entity_1.PaymentStatus.REFUNDED }).getCount(),
            queryBuilder
                .clone()
                .select('SUM(payment.totalAmount)', 'total')
                .andWhere('payment.paymentStatus = :status', { status: payment_entity_1.PaymentStatus.COMPLETED })
                .getRawOne(),
        ]);
        return {
            totalPayments,
            completedPayments,
            pendingPayments,
            failedPayments,
            refundedPayments,
            totalRevenue: parseFloat(totalRevenue?.total || '0'),
            successRate: totalPayments > 0 ? (completedPayments / totalPayments) * 100 : 0,
        };
    }
};
exports.PaymentsService = PaymentsService;
exports.PaymentsService = PaymentsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(payment_entity_1.Payment)),
    __param(1, (0, typeorm_1.InjectRepository)(booking_entity_1.Booking)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object])
], PaymentsService);


/***/ }),
/* 102 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(103), exports);


/***/ }),
/* 103 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatePaymentDto = void 0;
const class_validator_1 = __webpack_require__(19);
const swagger_1 = __webpack_require__(3);
const payment_entity_1 = __webpack_require__(76);
class CreatePaymentDto {
}
exports.CreatePaymentDto = CreatePaymentDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Booking ID for the payment' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePaymentDto.prototype, "bookingId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: payment_entity_1.PaymentMethod, description: 'Payment method used' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(payment_entity_1.PaymentMethod),
    __metadata("design:type", typeof (_a = typeof payment_entity_1.PaymentMethod !== "undefined" && payment_entity_1.PaymentMethod) === "function" ? _a : Object)
], CreatePaymentDto.prototype, "paymentMethod", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total amount to be paid', minimum: 0 }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], CreatePaymentDto.prototype, "totalAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Platform fee amount', minimum: 0 }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], CreatePaymentDto.prototype, "platformFee", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Currency code', default: 'USD' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePaymentDto.prototype, "currency", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Transaction ID from payment gateway', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePaymentDto.prototype, "transactionId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Payment gateway response data', required: false }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], CreatePaymentDto.prototype, "paymentGatewayResponse", void 0);


/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CurrentUser = void 0;
const common_1 = __webpack_require__(2);
exports.CurrentUser = (0, common_1.createParamDecorator)((data, ctx) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
});


/***/ }),
/* 105 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MpesaCallbackController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const mpesa_provider_1 = __webpack_require__(87);
const payments_service_1 = __webpack_require__(101);
const payment_entity_1 = __webpack_require__(76);
let MpesaCallbackController = class MpesaCallbackController {
    constructor(mpesaProvider, paymentsService) {
        this.mpesaProvider = mpesaProvider;
        this.paymentsService = paymentsService;
    }
    async mpesaCallback(callbackData) {
        try {
            const paymentResult = await this.mpesaProvider.processCallback(callbackData);
            if (paymentResult.status === 'succeeded') {
                await this.paymentsService.updateStatus(paymentResult.id, payment_entity_1.PaymentStatus.COMPLETED, paymentResult.transactionId);
            }
            else if (paymentResult.status === 'failed') {
                await this.paymentsService.updateStatus(paymentResult.id, payment_entity_1.PaymentStatus.FAILED);
            }
            return {
                success: true,
                message: 'M-Pesa callback processed successfully',
                data: paymentResult,
            };
        }
        catch (error) {
            return {
                success: false,
                message: 'Failed to process M-Pesa callback',
                error: error.message,
            };
        }
    }
};
exports.MpesaCallbackController = MpesaCallbackController;
__decorate([
    (0, common_1.Post)('callback'),
    (0, common_1.HttpCode)(200),
    (0, swagger_1.ApiOperation)({ summary: 'M-Pesa payment callback' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Callback processed successfully' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof mpesa_provider_1.MpesaCallbackData !== "undefined" && mpesa_provider_1.MpesaCallbackData) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], MpesaCallbackController.prototype, "mpesaCallback", null);
exports.MpesaCallbackController = MpesaCallbackController = __decorate([
    (0, swagger_1.ApiTags)('mpesa-callbacks'),
    (0, common_1.Controller)('mpesa-callbacks'),
    __metadata("design:paramtypes", [typeof (_a = typeof mpesa_provider_1.MpesaProvider !== "undefined" && mpesa_provider_1.MpesaProvider) === "function" ? _a : Object, typeof (_b = typeof payments_service_1.PaymentsService !== "undefined" && payments_service_1.PaymentsService) === "function" ? _b : Object])
], MpesaCallbackController);


/***/ }),
/* 106 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var StripeConnectProvider_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StripeConnectProvider = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(5);
const stripe_1 = __webpack_require__(86);
let StripeConnectProvider = StripeConnectProvider_1 = class StripeConnectProvider {
    constructor(configService) {
        this.configService = configService;
        this.logger = new common_1.Logger(StripeConnectProvider_1.name);
        this.config = {
            secretKey: this.configService.get('STRIPE_SECRET_KEY'),
            publishableKey: this.configService.get('STRIPE_PUBLISHABLE_KEY'),
            webhookSecret: this.configService.get('STRIPE_WEBHOOK_SECRET'),
            clientId: this.configService.get('STRIPE_CONNECT_CLIENT_ID'),
        };
        if (!this.config.secretKey) {
            throw new Error('STRIPE_SECRET_KEY is required');
        }
        this.stripe = new stripe_1.default(this.config.secretKey, {
            apiVersion: '2023-10-16',
        });
    }
    async createConnectAccount(dto) {
        try {
            this.logger.log(`Creating Stripe Connect account for company ${dto.companyId}`);
            const account = await this.stripe.accounts.create({
                type: 'express',
                country: dto.country,
                email: dto.email,
                business_type: 'company',
                company: {
                    name: dto.companyName,
                    phone: dto.phone,
                },
                capabilities: {
                    card_payments: { requested: true },
                    transfers: { requested: true },
                },
                business_profile: {
                    url: `https://yourplatform.com/company/${dto.companyId}`,
                    mcc: '4511',
                },
                tos_acceptance: {
                    date: Math.floor(Date.now() / 1000),
                    ip: '127.0.0.1',
                },
            });
            const accountLink = await this.stripe.accountLinks.create({
                account: account.id,
                refresh_url: `${this.configService.get('FRONTEND_URL')}/company/onboarding/refresh`,
                return_url: `${this.configService.get('FRONTEND_URL')}/company/onboarding/complete`,
                type: 'account_onboarding',
            });
            this.logger.log(`Stripe Connect account created: ${account.id}`);
            return {
                accountId: account.id,
                onboardingUrl: accountLink.url,
                dashboardUrl: account.dashboard_url,
                requirements: account.requirements,
                capabilities: account.capabilities,
            };
        }
        catch (error) {
            this.logger.error('Failed to create Stripe Connect account', error);
            throw new common_1.HttpException(`Failed to create Stripe Connect account: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async getConnectAccount(accountId) {
        try {
            const account = await this.stripe.accounts.retrieve(accountId);
            return account;
        }
        catch (error) {
            this.logger.error(`Failed to retrieve Stripe Connect account ${accountId}`, error);
            throw new common_1.HttpException(`Failed to retrieve Stripe Connect account: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async createSplitPayment(request) {
        try {
            this.logger.log(`Creating split payment: ${request.amount} ${request.currency} for company ${request.companyAccountId}`);
            const paymentIntent = await this.stripe.paymentIntents.create({
                amount: request.amount,
                currency: request.currency.toLowerCase(),
                application_fee_amount: request.platformFeeAmount,
                transfer_data: {
                    destination: request.companyAccountId,
                },
                description: request.description,
                metadata: request.metadata,
                customer: request.customerId,
                payment_method: request.paymentMethodId,
                automatic_payment_methods: {
                    enabled: true,
                },
                confirm: false,
            });
            const companyAmount = request.amount - request.platformFeeAmount;
            this.logger.log(`Split payment created: ${paymentIntent.id}`);
            return {
                paymentIntentId: paymentIntent.id,
                clientSecret: paymentIntent.client_secret,
                status: paymentIntent.status,
                amount: request.amount,
                platformFee: request.platformFeeAmount,
                companyAmount: companyAmount,
                requiresAction: paymentIntent.status === 'requires_action',
                nextAction: paymentIntent.next_action,
            };
        }
        catch (error) {
            this.logger.error('Failed to create split payment', error);
            throw new common_1.HttpException(`Failed to create split payment: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async confirmSplitPayment(paymentIntentId, paymentMethodId) {
        try {
            this.logger.log(`Confirming split payment: ${paymentIntentId}`);
            const paymentIntent = await this.stripe.paymentIntents.retrieve(paymentIntentId);
            if (paymentIntent.status === 'requires_confirmation') {
                await this.stripe.paymentIntents.confirm(paymentIntentId, {
                    payment_method: paymentMethodId,
                });
            }
            const updatedPaymentIntent = await this.stripe.paymentIntents.retrieve(paymentIntentId);
            this.logger.log(`Split payment confirmed: ${paymentIntentId} - Status: ${updatedPaymentIntent.status}`);
            return {
                id: updatedPaymentIntent.id,
                status: updatedPaymentIntent.status,
                amount: updatedPaymentIntent.amount,
                currency: updatedPaymentIntent.currency,
                applicationFee: updatedPaymentIntent.application_fee_amount,
                transferData: updatedPaymentIntent.transfer_data,
                charges: updatedPaymentIntent.charges,
            };
        }
        catch (error) {
            this.logger.error('Failed to confirm split payment', error);
            throw new common_1.HttpException(`Failed to confirm split payment: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async getAccountBalance(accountId) {
        try {
            const balance = await this.stripe.balance.retrieve({
                stripeAccount: accountId,
            });
            return {
                available: balance.available,
                pending: balance.pending,
                instantAvailable: balance.instant_available,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get account balance for ${accountId}`, error);
            throw new common_1.HttpException(`Failed to get account balance: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async createTransfer(accountId, amount, currency, description) {
        try {
            this.logger.log(`Creating transfer: ${amount} ${currency} to account ${accountId}`);
            const transfer = await this.stripe.transfers.create({
                amount: amount,
                currency: currency.toLowerCase(),
                destination: accountId,
                description: description,
            });
            this.logger.log(`Transfer created: ${transfer.id}`);
            return transfer;
        }
        catch (error) {
            this.logger.error('Failed to create transfer', error);
            throw new common_1.HttpException(`Failed to create transfer: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async getAccountPayouts(accountId, limit = 10) {
        try {
            const payouts = await this.stripe.payouts.list({
                limit: limit,
            }, {
                stripeAccount: accountId,
            });
            return payouts.data;
        }
        catch (error) {
            this.logger.error(`Failed to get payouts for account ${accountId}`, error);
            throw new common_1.HttpException(`Failed to get payouts: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async createAccountLink(accountId, refreshUrl, returnUrl) {
        try {
            const accountLink = await this.stripe.accountLinks.create({
                account: accountId,
                refresh_url: refreshUrl,
                return_url: returnUrl,
                type: 'account_onboarding',
            });
            return accountLink.url;
        }
        catch (error) {
            this.logger.error(`Failed to create account link for ${accountId}`, error);
            throw new common_1.HttpException(`Failed to create account link: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async handleWebhook(payload, signature) {
        try {
            const event = this.stripe.webhooks.constructEvent(payload, signature, this.config.webhookSecret);
            this.logger.log(`Webhook received: ${event.type}`);
            switch (event.type) {
                case 'account.updated':
                    return this.handleAccountUpdated(event.data.object);
                case 'payment_intent.succeeded':
                    return this.handlePaymentSucceeded(event.data.object);
                case 'payment_intent.payment_failed':
                    return this.handlePaymentFailed(event.data.object);
                case 'transfer.created':
                    return this.handleTransferCreated(event.data.object);
                case 'payout.paid':
                    return this.handlePayoutPaid(event.data.object);
                default:
                    this.logger.log(`Unhandled webhook event: ${event.type}`);
                    return null;
            }
        }
        catch (error) {
            this.logger.error('Webhook signature verification failed', error);
            throw new common_1.HttpException('Webhook signature verification failed', common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async handleAccountUpdated(account) {
        this.logger.log(`Account updated: ${account.id} - Status: ${account.charges_enabled}`);
    }
    async handlePaymentSucceeded(paymentIntent) {
        this.logger.log(`Payment succeeded: ${paymentIntent.id} - Amount: ${paymentIntent.amount}`);
    }
    async handlePaymentFailed(paymentIntent) {
        this.logger.log(`Payment failed: ${paymentIntent.id}`);
    }
    async handleTransferCreated(transfer) {
        this.logger.log(`Transfer created: ${transfer.id} - Amount: ${transfer.amount}`);
    }
    async handlePayoutPaid(payout) {
        this.logger.log(`Payout paid: ${payout.id} - Amount: ${payout.amount}`);
    }
};
exports.StripeConnectProvider = StripeConnectProvider;
exports.StripeConnectProvider = StripeConnectProvider = StripeConnectProvider_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], StripeConnectProvider);


/***/ }),
/* 107 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var MpesaMerchantProvider_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MpesaMerchantProvider = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(5);
const axios_1 = __webpack_require__(108);
let MpesaMerchantProvider = MpesaMerchantProvider_1 = class MpesaMerchantProvider {
    constructor(configService) {
        this.configService = configService;
        this.logger = new common_1.Logger(MpesaMerchantProvider_1.name);
        this.config = {
            consumerKey: this.configService.get('MPESA_CONSUMER_KEY'),
            consumerSecret: this.configService.get('MPESA_CONSUMER_SECRET'),
            passkey: this.configService.get('MPESA_PASSKEY'),
            businessShortCode: this.configService.get('MPESA_BUSINESS_SHORTCODE'),
            environment: this.configService.get('MPESA_ENVIRONMENT'),
            callbackUrl: this.configService.get('MPESA_CALLBACK_URL'),
        };
        this.baseUrl = this.config.environment === 'production'
            ? 'https://api.safaricom.co.ke'
            : 'https://sandbox.safaricom.co.ke';
        if (!this.config.consumerKey || !this.config.consumerSecret) {
            throw new Error('MPESA_CONSUMER_KEY and MPESA_CONSUMER_SECRET are required');
        }
    }
    async createMerchantAccount(dto) {
        try {
            this.logger.log(`Creating M-Pesa merchant account for company ${dto.companyId}`);
            const accessToken = await this.getAccessToken();
            const merchantResponse = await this.registerMerchant(dto, accessToken);
            const shortCode = await this.generateBusinessShortCode(merchantResponse.merchantId, accessToken);
            this.logger.log(`M-Pesa merchant account created: ${merchantResponse.merchantId}`);
            return {
                merchantId: merchantResponse.merchantId,
                businessShortCode: shortCode,
                status: 'pending',
                verificationStatus: 'pending',
                requirements: merchantResponse.requirements,
            };
        }
        catch (error) {
            this.logger.error('Failed to create M-Pesa merchant account', error);
            throw new common_1.HttpException(`Failed to create M-Pesa merchant account: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async createSplitPayment(request) {
        try {
            this.logger.log(`Creating M-Pesa split payment: ${request.amount} KES for company ${request.metadata.companyId}`);
            const accessToken = await this.getAccessToken();
            const timestamp = this.generateTimestamp();
            const password = this.generatePassword(timestamp);
            const stkPushData = {
                BusinessShortCode: request.businessShortCode,
                Password: password,
                Timestamp: timestamp,
                TransactionType: 'CustomerPayBillOnline',
                Amount: request.amount,
                PartyA: request.phoneNumber,
                PartyB: request.businessShortCode,
                PhoneNumber: request.phoneNumber,
                CallBackURL: `${this.config.callbackUrl}/mpesa/split-callback`,
                AccountReference: request.accountReference,
                TransactionDesc: request.transactionDesc,
                Metadata: {
                    companyId: request.metadata.companyId,
                    platformFee: request.metadata.platformFee,
                    companyAmount: request.metadata.companyAmount,
                    bookingId: request.metadata.bookingId,
                },
            };
            const response = await axios_1.default.post(`${this.baseUrl}/mpesa/stkpush/v1/processrequest`, stkPushData, {
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                },
            });
            const responseData = response.data;
            if (responseData.ResponseCode !== '0') {
                throw new Error(`STK Push failed: ${responseData.ResponseDescription}`);
            }
            this.logger.log(`M-Pesa split payment initiated: ${responseData.CheckoutRequestID}`);
            return {
                checkoutRequestId: responseData.CheckoutRequestID,
                merchantRequestId: responseData.MerchantRequestID,
                responseCode: responseData.ResponseCode,
                responseDescription: responseData.ResponseDescription,
                customerMessage: responseData.CustomerMessage,
                amount: request.amount,
                platformFee: request.metadata.platformFee,
                companyAmount: request.metadata.companyAmount,
                requiresAction: true,
            };
        }
        catch (error) {
            this.logger.error('Failed to create M-Pesa split payment', error);
            throw new common_1.HttpException(`Failed to create M-Pesa split payment: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async checkPaymentStatus(checkoutRequestId) {
        try {
            const accessToken = await this.getAccessToken();
            const timestamp = this.generateTimestamp();
            const password = this.generatePassword(timestamp);
            const queryData = {
                BusinessShortCode: this.config.businessShortCode,
                Password: password,
                Timestamp: timestamp,
                CheckoutRequestID: checkoutRequestId,
            };
            const response = await axios_1.default.post(`${this.baseUrl}/mpesa/stkpushquery/v1/query`, queryData, {
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                },
            });
            const responseData = response.data;
            return {
                checkoutRequestId: responseData.CheckoutRequestID,
                resultCode: responseData.ResultCode,
                resultDesc: responseData.ResultDesc,
                amount: responseData.Amount,
                mpesaReceiptNumber: responseData.MpesaReceiptNumber,
                transactionDate: responseData.TransactionDate,
                phoneNumber: responseData.PhoneNumber,
            };
        }
        catch (error) {
            this.logger.error(`Failed to check payment status for ${checkoutRequestId}`, error);
            throw new common_1.HttpException(`Failed to check payment status: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async processSplitPayment(transactionId, platformAccount, companyAccount, platformAmount, companyAmount) {
        try {
            this.logger.log(`Processing split payment: Platform ${platformAmount}, Company ${companyAmount}`);
            const accessToken = await this.getAccessToken();
            const platformTransfer = await this.transferToAccount(platformAccount, platformAmount, `Platform fee for transaction ${transactionId}`, accessToken);
            const companyTransfer = await this.transferToAccount(companyAccount, companyAmount, `Company payout for transaction ${transactionId}`, accessToken);
            return {
                platformTransfer,
                companyTransfer,
                transactionId,
                totalAmount: platformAmount + companyAmount,
            };
        }
        catch (error) {
            this.logger.error('Failed to process split payment', error);
            throw new common_1.HttpException(`Failed to process split payment: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async getMerchantBalance(merchantId) {
        try {
            const accessToken = await this.getAccessToken();
            const response = await axios_1.default.get(`${this.baseUrl}/mpesa/accountbalance/v1/query`, {
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                },
                params: {
                    BusinessShortCode: merchantId,
                },
            });
            return response.data;
        }
        catch (error) {
            this.logger.error(`Failed to get merchant balance for ${merchantId}`, error);
            throw new common_1.HttpException(`Failed to get merchant balance: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async getMerchantTransactions(merchantId, fromDate, toDate) {
        try {
            const accessToken = await this.getAccessToken();
            const response = await axios_1.default.get(`${this.baseUrl}/mpesa/transactionstatus/v1/query`, {
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                },
                params: {
                    BusinessShortCode: merchantId,
                    FromDate: fromDate,
                    ToDate: toDate,
                },
            });
            return response.data.Transactions || [];
        }
        catch (error) {
            this.logger.error(`Failed to get merchant transactions for ${merchantId}`, error);
            throw new common_1.HttpException(`Failed to get merchant transactions: ${error.message}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async getAccessToken() {
        try {
            const auth = Buffer.from(`${this.config.consumerKey}:${this.config.consumerSecret}`).toString('base64');
            const response = await axios_1.default.get(`${this.baseUrl}/oauth/v1/generate?grant_type=client_credentials`, {
                headers: {
                    'Authorization': `Basic ${auth}`,
                },
            });
            return response.data.access_token;
        }
        catch (error) {
            this.logger.error('Failed to get M-Pesa access token', error);
            throw new Error('Failed to authenticate with M-Pesa API');
        }
    }
    async registerMerchant(dto, accessToken) {
        const merchantId = `MERCHANT_${Date.now()}_${dto.companyId}`;
        return {
            merchantId,
            requirements: {
                businessRegistration: 'pending',
                bankAccount: 'pending',
                kycDocuments: 'pending',
            },
        };
    }
    async generateBusinessShortCode(merchantId, accessToken) {
        return `BUSINESS_${Date.now().toString().slice(-6)}`;
    }
    async transferToAccount(accountId, amount, description, accessToken) {
        const transferId = `TRANSFER_${Date.now()}_${accountId}`;
        return {
            transferId,
            accountId,
            amount,
            description,
            status: 'completed',
            timestamp: new Date().toISOString(),
        };
    }
    generateTimestamp() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hour = String(now.getHours()).padStart(2, '0');
        const minute = String(now.getMinutes()).padStart(2, '0');
        const second = String(now.getSeconds()).padStart(2, '0');
        return `${year}${month}${day}${hour}${minute}${second}`;
    }
    generatePassword(timestamp) {
        const businessShortCode = this.config.businessShortCode;
        const passkey = this.config.passkey;
        const passwordString = `${businessShortCode}${passkey}${timestamp}`;
        return Buffer.from(passwordString).toString('base64');
    }
    async handleWebhook(payload) {
        try {
            this.logger.log(`M-Pesa webhook received: ${payload.ResultCode}`);
            switch (payload.ResultCode) {
                case '0':
                    return this.handleSuccessfulPayment(payload);
                case '1':
                    return this.handleInsufficientFunds(payload);
                case '2':
                    return this.handleLessThanMinimum(payload);
                case '3':
                    return this.handleMoreThanMaximum(payload);
                case '4':
                    return this.handleWouldExceedDailyLimit(payload);
                case '5':
                    return this.handleWouldExceedMinimumLimit(payload);
                case '6':
                    return this.handleUnresolvedPrimaryParty(payload);
                case '7':
                    return this.handleUnresolvedReceiverParty(payload);
                case '8':
                    return this.handleWouldExceedMaxBalance(payload);
                case '11':
                    return this.handleDebitAccountInvalid(payload);
                case '12':
                    return this.handleCreditAccountInvalid(payload);
                case '13':
                    return this.handleUnresolvedDebitAccount(payload);
                case '14':
                    return this.handleUnresolvedCreditAccount(payload);
                case '15':
                    return this.handleDuplicateDetected(payload);
                case '16':
                    return this.handleInternalFailure(payload);
                case '17':
                    return this.handleUnresolvedInitiator(payload);
                case '18':
                    return this.handleTrafficBlockingCondition(payload);
                default:
                    this.logger.log(`Unhandled M-Pesa result code: ${payload.ResultCode}`);
                    return null;
            }
        }
        catch (error) {
            this.logger.error('M-Pesa webhook processing failed', error);
            throw new common_1.HttpException('M-Pesa webhook processing failed', common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async handleSuccessfulPayment(payload) {
        this.logger.log(`Payment successful: ${payload.CheckoutRequestID} - Amount: ${payload.Amount}`);
    }
    async handleInsufficientFunds(payload) {
        this.logger.log(`Insufficient funds: ${payload.CheckoutRequestID}`);
    }
    async handleLessThanMinimum(payload) {
        this.logger.log(`Amount less than minimum: ${payload.CheckoutRequestID}`);
    }
    async handleMoreThanMaximum(payload) {
        this.logger.log(`Amount more than maximum: ${payload.CheckoutRequestID}`);
    }
    async handleWouldExceedDailyLimit(payload) {
        this.logger.log(`Would exceed daily limit: ${payload.CheckoutRequestID}`);
    }
    async handleWouldExceedMinimumLimit(payload) {
        this.logger.log(`Would exceed minimum limit: ${payload.CheckoutRequestID}`);
    }
    async handleUnresolvedPrimaryParty(payload) {
        this.logger.log(`Unresolved primary party: ${payload.CheckoutRequestID}`);
    }
    async handleUnresolvedReceiverParty(payload) {
        this.logger.log(`Unresolved receiver party: ${payload.CheckoutRequestID}`);
    }
    async handleWouldExceedMaxBalance(payload) {
        this.logger.log(`Would exceed max balance: ${payload.CheckoutRequestID}`);
    }
    async handleDebitAccountInvalid(payload) {
        this.logger.log(`Debit account invalid: ${payload.CheckoutRequestID}`);
    }
    async handleCreditAccountInvalid(payload) {
        this.logger.log(`Credit account invalid: ${payload.CheckoutRequestID}`);
    }
    async handleUnresolvedDebitAccount(payload) {
        this.logger.log(`Unresolved debit account: ${payload.CheckoutRequestID}`);
    }
    async handleUnresolvedCreditAccount(payload) {
        this.logger.log(`Unresolved credit account: ${payload.CheckoutRequestID}`);
    }
    async handleDuplicateDetected(payload) {
        this.logger.log(`Duplicate detected: ${payload.CheckoutRequestID}`);
    }
    async handleInternalFailure(payload) {
        this.logger.log(`Internal failure: ${payload.CheckoutRequestID}`);
    }
    async handleUnresolvedInitiator(payload) {
        this.logger.log(`Unresolved initiator: ${payload.CheckoutRequestID}`);
    }
    async handleTrafficBlockingCondition(payload) {
        this.logger.log(`Traffic blocking condition: ${payload.CheckoutRequestID}`);
    }
};
exports.MpesaMerchantProvider = MpesaMerchantProvider;
exports.MpesaMerchantProvider = MpesaMerchantProvider = MpesaMerchantProvider_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], MpesaMerchantProvider);


/***/ }),
/* 108 */
/***/ ((module) => {

module.exports = require("axios");

/***/ }),
/* 109 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var CompanyOnboardingService_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompanyOnboardingService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const company_payment_account_entity_1 = __webpack_require__(91);
const charters_company_entity_1 = __webpack_require__(31);
const stripe_connect_provider_1 = __webpack_require__(106);
const mpesa_merchant_provider_1 = __webpack_require__(107);
let CompanyOnboardingService = CompanyOnboardingService_1 = class CompanyOnboardingService {
    constructor(companyPaymentAccountRepository, companyRepository, stripeConnectProvider, mpesaMerchantProvider) {
        this.companyPaymentAccountRepository = companyPaymentAccountRepository;
        this.companyRepository = companyRepository;
        this.stripeConnectProvider = stripeConnectProvider;
        this.mpesaMerchantProvider = mpesaMerchantProvider;
        this.logger = new common_1.Logger(CompanyOnboardingService_1.name);
    }
    async onboardCompany(dto) {
        this.logger.log(`Starting onboarding for company ${dto.companyId} with ${dto.paymentProvider}`);
        const company = await this.companyRepository.findOne({
            where: { id: dto.companyId },
        });
        if (!company) {
            throw new common_1.NotFoundException(`Company with ID ${dto.companyId} not found`);
        }
        const existingAccount = await this.companyPaymentAccountRepository.findOne({
            where: {
                companyId: dto.companyId,
                paymentProvider: dto.paymentProvider,
                isActive: true,
            },
        });
        if (existingAccount) {
            throw new common_1.BadRequestException(`Company ${dto.companyId} already has an active ${dto.paymentProvider} account`);
        }
        switch (dto.paymentProvider) {
            case company_payment_account_entity_1.PaymentProvider.STRIPE:
                return await this.onboardStripeAccount(dto, company);
            case company_payment_account_entity_1.PaymentProvider.MPESA:
                return await this.onboardMpesaAccount(dto, company);
            default:
                throw new common_1.BadRequestException(`Unsupported payment provider: ${dto.paymentProvider}`);
        }
    }
    async onboardStripeAccount(dto, company) {
        try {
            const stripeAccountDto = {
                companyId: dto.companyId,
                email: company.email,
                country: dto.country,
                businessType: 'airline_charter',
                companyName: company.companyName,
                phone: company.mobileNumber,
            };
            const stripeResponse = await this.stripeConnectProvider.createConnectAccount(stripeAccountDto);
            const paymentAccount = this.companyPaymentAccountRepository.create({
                companyId: dto.companyId,
                paymentProvider: company_payment_account_entity_1.PaymentProvider.STRIPE,
                accountType: dto.accountType || company_payment_account_entity_1.AccountType.EXPRESS,
                accountId: stripeResponse.accountId,
                accountStatus: company_payment_account_entity_1.AccountStatus.PENDING,
                verificationStatus: 'pending',
                country: dto.country,
                currency: dto.currency || 'USD',
                capabilities: stripeResponse.capabilities,
                requirements: stripeResponse.requirements,
                onboardingUrl: stripeResponse.onboardingUrl,
                dashboardUrl: stripeResponse.dashboardUrl,
                isActive: true,
            });
            const savedAccount = await this.companyPaymentAccountRepository.save(paymentAccount);
            this.logger.log(`Stripe account created for company ${dto.companyId}: ${stripeResponse.accountId}`);
            return {
                accountId: savedAccount.accountId,
                status: savedAccount.accountStatus,
                verificationStatus: savedAccount.verificationStatus,
                requirements: savedAccount.requirements,
                capabilities: savedAccount.capabilities,
                onboardingUrl: savedAccount.onboardingUrl,
                dashboardUrl: savedAccount.dashboardUrl,
                isComplete: this.isOnboardingComplete(savedAccount),
            };
        }
        catch (error) {
            this.logger.error(`Failed to onboard Stripe account for company ${dto.companyId}`, error);
            throw error;
        }
    }
    async onboardMpesaAccount(dto, company) {
        try {
            const mpesaAccountDto = {
                companyId: dto.companyId,
                businessName: company.companyName,
                phoneNumber: company.mobileNumber,
                businessType: 'airline_charter',
                documents: [],
                bankAccount: {
                    accountNumber: '',
                    bankCode: '',
                    accountName: company.companyName,
                },
            };
            const mpesaResponse = await this.mpesaMerchantProvider.createMerchantAccount(mpesaAccountDto);
            const paymentAccount = this.companyPaymentAccountRepository.create({
                companyId: dto.companyId,
                paymentProvider: company_payment_account_entity_1.PaymentProvider.MPESA,
                accountType: dto.accountType || company_payment_account_entity_1.AccountType.EXPRESS,
                accountId: mpesaResponse.merchantId,
                accountStatus: company_payment_account_entity_1.AccountStatus.PENDING,
                verificationStatus: 'pending',
                country: dto.country,
                currency: dto.currency || 'KES',
                capabilities: {
                    stkPush: true,
                    accountBalance: true,
                    transactions: true,
                },
                requirements: mpesaResponse.requirements,
                businessProfile: {
                    businessName: company.companyName,
                    phoneNumber: company.mobileNumber,
                    businessType: 'airline_charter',
                },
                metadata: {
                    businessShortCode: mpesaResponse.businessShortCode,
                },
                isActive: true,
            });
            const savedAccount = await this.companyPaymentAccountRepository.save(paymentAccount);
            this.logger.log(`M-Pesa merchant account created for company ${dto.companyId}: ${mpesaResponse.merchantId}`);
            return {
                accountId: savedAccount.accountId,
                status: savedAccount.accountStatus,
                verificationStatus: savedAccount.verificationStatus,
                requirements: savedAccount.requirements,
                capabilities: savedAccount.capabilities,
                isComplete: this.isOnboardingComplete(savedAccount),
            };
        }
        catch (error) {
            this.logger.error(`Failed to onboard M-Pesa account for company ${dto.companyId}`, error);
            throw error;
        }
    }
    async getOnboardingStatus(companyId, paymentProvider) {
        const account = await this.companyPaymentAccountRepository.findOne({
            where: {
                companyId,
                paymentProvider,
                isActive: true,
            },
        });
        if (!account) {
            return null;
        }
        if (paymentProvider === company_payment_account_entity_1.PaymentProvider.STRIPE) {
            try {
                const stripeAccount = await this.stripeConnectProvider.getConnectAccount(account.accountId);
                account.accountStatus = this.mapStripeStatus(stripeAccount.charges_enabled);
                account.verificationStatus = this.mapStripeVerificationStatus(stripeAccount.requirements);
                account.capabilities = stripeAccount.capabilities;
                account.requirements = stripeAccount.requirements;
                await this.companyPaymentAccountRepository.save(account);
            }
            catch (error) {
                this.logger.error(`Failed to get updated status from Stripe for account ${account.accountId}`, error);
            }
        }
        if (paymentProvider === company_payment_account_entity_1.PaymentProvider.MPESA) {
            try {
                const mpesaBalance = await this.mpesaMerchantProvider.getMerchantBalance(account.accountId);
                account.accountStatus = mpesaBalance ? company_payment_account_entity_1.AccountStatus.ACTIVE : company_payment_account_entity_1.AccountStatus.PENDING;
                account.verificationStatus = 'verified';
                await this.companyPaymentAccountRepository.save(account);
            }
            catch (error) {
                this.logger.error(`Failed to get updated status from M-Pesa for account ${account.accountId}`, error);
            }
        }
        return {
            accountId: account.accountId,
            status: account.accountStatus,
            verificationStatus: account.verificationStatus,
            requirements: account.requirements,
            capabilities: account.capabilities,
            onboardingUrl: account.onboardingUrl,
            dashboardUrl: account.dashboardUrl,
            isComplete: this.isOnboardingComplete(account),
        };
    }
    async refreshOnboardingLink(companyId, paymentProvider) {
        const account = await this.companyPaymentAccountRepository.findOne({
            where: {
                companyId,
                paymentProvider,
                isActive: true,
            },
        });
        if (!account) {
            throw new common_1.NotFoundException(`No active ${paymentProvider} account found for company ${companyId}`);
        }
        if (paymentProvider === company_payment_account_entity_1.PaymentProvider.STRIPE) {
            const refreshUrl = `${process.env.FRONTEND_URL}/company/onboarding/refresh`;
            const returnUrl = `${process.env.FRONTEND_URL}/company/onboarding/complete`;
            const onboardingUrl = await this.stripeConnectProvider.createAccountLink(account.accountId, refreshUrl, returnUrl);
            account.onboardingUrl = onboardingUrl;
            await this.companyPaymentAccountRepository.save(account);
            return onboardingUrl;
        }
        if (paymentProvider === company_payment_account_entity_1.PaymentProvider.MPESA) {
            const dashboardUrl = `${process.env.FRONTEND_URL}/company/mpesa-dashboard/${account.accountId}`;
            account.dashboardUrl = dashboardUrl;
            await this.companyPaymentAccountRepository.save(account);
            return dashboardUrl;
        }
        throw new common_1.BadRequestException(`Refresh not supported for ${paymentProvider}`);
    }
    async getCompanyPaymentAccounts(companyId) {
        return await this.companyPaymentAccountRepository.find({
            where: {
                companyId,
                isActive: true,
            },
            order: { createdAt: 'DESC' },
        });
    }
    async deactivateAccount(accountId) {
        const account = await this.companyPaymentAccountRepository.findOne({
            where: { accountId },
        });
        if (!account) {
            throw new common_1.NotFoundException(`Payment account ${accountId} not found`);
        }
        account.isActive = false;
        account.accountStatus = company_payment_account_entity_1.AccountStatus.SUSPENDED;
        await this.companyPaymentAccountRepository.save(account);
        this.logger.log(`Payment account ${accountId} deactivated`);
    }
    isOnboardingComplete(account) {
        if (account.paymentProvider === company_payment_account_entity_1.PaymentProvider.STRIPE) {
            return account.accountStatus === company_payment_account_entity_1.AccountStatus.ACTIVE &&
                account.verificationStatus === 'verified';
        }
        return account.accountStatus === company_payment_account_entity_1.AccountStatus.ACTIVE;
    }
    mapStripeStatus(chargesEnabled) {
        return chargesEnabled ? company_payment_account_entity_1.AccountStatus.ACTIVE : company_payment_account_entity_1.AccountStatus.PENDING;
    }
    mapStripeVerificationStatus(requirements) {
        if (!requirements)
            return 'pending';
        const currentlyDue = requirements.currently_due || [];
        const eventuallyDue = requirements.eventually_due || [];
        if (currentlyDue.length === 0 && eventuallyDue.length === 0) {
            return 'verified';
        }
        else if (currentlyDue.length > 0) {
            return 'pending';
        }
        else {
            return 'partially_verified';
        }
    }
};
exports.CompanyOnboardingService = CompanyOnboardingService;
exports.CompanyOnboardingService = CompanyOnboardingService = CompanyOnboardingService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(company_payment_account_entity_1.CompanyPaymentAccount)),
    __param(1, (0, typeorm_1.InjectRepository)(charters_company_entity_1.ChartersCompany)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof stripe_connect_provider_1.StripeConnectProvider !== "undefined" && stripe_connect_provider_1.StripeConnectProvider) === "function" ? _c : Object, typeof (_d = typeof mpesa_merchant_provider_1.MpesaMerchantProvider !== "undefined" && mpesa_merchant_provider_1.MpesaMerchantProvider) === "function" ? _d : Object])
], CompanyOnboardingService);


/***/ }),
/* 110 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var UnifiedPaymentService_1;
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnifiedPaymentService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const transaction_ledger_entity_1 = __webpack_require__(90);
const company_payment_account_entity_1 = __webpack_require__(91);
const company_payment_account_entity_2 = __webpack_require__(91);
const stripe_connect_provider_1 = __webpack_require__(106);
const mpesa_merchant_provider_1 = __webpack_require__(107);
const dynamic_commission_service_1 = __webpack_require__(111);
const platform_commission_entity_1 = __webpack_require__(112);
const exchange_rate_service_1 = __webpack_require__(89);
let UnifiedPaymentService = UnifiedPaymentService_1 = class UnifiedPaymentService {
    constructor(transactionLedgerRepository, companyPaymentAccountRepository, stripeConnectProvider, mpesaMerchantProvider, dynamicCommissionService, exchangeRateService) {
        this.transactionLedgerRepository = transactionLedgerRepository;
        this.companyPaymentAccountRepository = companyPaymentAccountRepository;
        this.stripeConnectProvider = stripeConnectProvider;
        this.mpesaMerchantProvider = mpesaMerchantProvider;
        this.dynamicCommissionService = dynamicCommissionService;
        this.exchangeRateService = exchangeRateService;
        this.logger = new common_1.Logger(UnifiedPaymentService_1.name);
    }
    async processPayment(request) {
        this.logger.log(`Processing unified payment: ${request.amount} ${request.currency} for booking ${request.bookingId}`);
        const providerSelection = await this.selectPaymentProvider(request);
        const commission = await this.dynamicCommissionService.calculateCommission({
            companyId: request.companyId,
            bookingType: platform_commission_entity_1.BookingType.CHARTER_DEAL,
            totalAmount: request.amount,
            currency: request.currency,
        });
        const companyAccount = await this.getCompanyPaymentAccount(request.companyId, providerSelection.provider);
        if (!companyAccount) {
            throw new common_1.BadRequestException(`No active ${providerSelection.provider} account found for company ${request.companyId}`);
        }
        const transactionId = this.generateTransactionId();
        const ledgerEntry = await this.createLedgerEntry({
            transactionId,
            parentTransactionId: null,
            companyId: request.companyId,
            userId: request.userId,
            bookingId: request.bookingId,
            transactionType: transaction_ledger_entity_1.TransactionType.PAYMENT_RECEIVED,
            paymentProvider: providerSelection.provider,
            amount: request.amount,
            currency: request.currency,
            baseAmount: request.amount * (request.currency === transaction_ledger_entity_1.Currency.USD ? 1 : await this.getExchangeRate(request.currency)),
            netAmount: request.amount,
            description: request.description,
            metadata: {
                ...request.metadata,
                providerSelection: providerSelection,
                commissionCalculation: commission,
            },
            ipAddress: request.ipAddress,
            userAgent: request.userAgent,
        });
        try {
            let paymentResult;
            if (providerSelection.provider === company_payment_account_entity_1.PaymentProvider.STRIPE) {
                paymentResult = await this.processStripePayment(request, companyAccount, commission);
            }
            else if (providerSelection.provider === company_payment_account_entity_1.PaymentProvider.MPESA) {
                paymentResult = await this.processMpesaPayment(request, companyAccount, commission);
            }
            else if (providerSelection.provider === company_payment_account_entity_1.PaymentProvider.PAYSTACK) {
                paymentResult = await this.processPaystackPayment(request, companyAccount, commission);
            }
            else {
                throw new common_1.BadRequestException(`Unsupported payment provider: ${providerSelection.provider}`);
            }
            await this.updateLedgerEntry(transactionId, {
                status: paymentResult.requiresAction ? transaction_ledger_entity_1.TransactionStatus.PROCESSING : transaction_ledger_entity_1.TransactionStatus.COMPLETED,
                providerTransactionId: paymentResult.providerTransactionId,
                providerMetadata: paymentResult.providerData,
                processedAt: new Date(),
            });
            await this.createSplitLedgerEntries(transactionId, commission, providerSelection.provider);
            return {
                transactionId,
                provider: providerSelection.provider,
                status: paymentResult.requiresAction ? transaction_ledger_entity_1.TransactionStatus.PROCESSING : transaction_ledger_entity_1.TransactionStatus.COMPLETED,
                amount: request.amount,
                currency: request.currency,
                platformFee: commission.platformCommission,
                companyAmount: commission.companyAmount,
                requiresAction: paymentResult.requiresAction,
                nextAction: paymentResult.nextAction,
                providerData: paymentResult.providerData,
            };
        }
        catch (error) {
            await this.updateLedgerEntry(transactionId, {
                status: transaction_ledger_entity_1.TransactionStatus.FAILED,
                errorMessage: error.message,
            });
            throw error;
        }
    }
    async confirmPayment(transactionId, paymentMethodId) {
        const ledgerEntry = await this.getTransactionById(transactionId);
        if (!ledgerEntry) {
            throw new common_1.NotFoundException(`Transaction ${transactionId} not found`);
        }
        if (ledgerEntry.status !== transaction_ledger_entity_1.TransactionStatus.PROCESSING) {
            throw new common_1.BadRequestException(`Transaction ${transactionId} is not in processing status`);
        }
        try {
            let confirmationResult;
            if (ledgerEntry.paymentProvider === company_payment_account_entity_1.PaymentProvider.STRIPE) {
                confirmationResult = await this.stripeConnectProvider.confirmSplitPayment(ledgerEntry.providerTransactionId, paymentMethodId);
            }
            else {
                throw new common_1.BadRequestException(`Payment confirmation not supported for ${ledgerEntry.paymentProvider}`);
            }
            await this.updateLedgerEntry(transactionId, {
                status: transaction_ledger_entity_1.TransactionStatus.COMPLETED,
                settledAt: new Date(),
                providerMetadata: {
                    ...ledgerEntry.providerMetadata,
                    confirmation: confirmationResult,
                },
            });
            return {
                transactionId,
                provider: ledgerEntry.paymentProvider,
                status: transaction_ledger_entity_1.TransactionStatus.COMPLETED,
                amount: ledgerEntry.amount,
                currency: ledgerEntry.currency,
                platformFee: ledgerEntry.metadata?.commissionCalculation?.platformCommission || 0,
                companyAmount: ledgerEntry.metadata?.commissionCalculation?.companyAmount || 0,
                requiresAction: false,
            };
        }
        catch (error) {
            await this.updateLedgerEntry(transactionId, {
                status: transaction_ledger_entity_1.TransactionStatus.FAILED,
                errorMessage: error.message,
            });
            throw error;
        }
    }
    async getTransactionById(transactionId) {
        return await this.transactionLedgerRepository.findOne({
            where: { transactionId },
            relations: ['company'],
        });
    }
    async getTransactionsByCompany(companyId, filters = {}, page = 1, limit = 20) {
        const query = this.transactionLedgerRepository.createQueryBuilder('transaction')
            .where('transaction.companyId = :companyId', { companyId })
            .leftJoinAndSelect('transaction.company', 'company');
        if (filters.startDate && filters.endDate) {
            query.andWhere('transaction.createdAt BETWEEN :startDate AND :endDate', {
                startDate: filters.startDate,
                endDate: filters.endDate,
            });
        }
        if (filters.status) {
            query.andWhere('transaction.status = :status', { status: filters.status });
        }
        if (filters.type) {
            query.andWhere('transaction.transactionType = :type', { type: filters.type });
        }
        if (filters.provider) {
            query.andWhere('transaction.paymentProvider = :provider', { provider: filters.provider });
        }
        const total = await query.getCount();
        const transactions = await query
            .orderBy('transaction.createdAt', 'DESC')
            .offset((page - 1) * limit)
            .limit(limit)
            .getMany();
        return { transactions, total };
    }
    async getTransactionSummary(companyId, startDate, endDate, currency = transaction_ledger_entity_1.Currency.USD) {
        const query = this.transactionLedgerRepository.createQueryBuilder('transaction')
            .where('transaction.companyId = :companyId', { companyId })
            .andWhere('transaction.createdAt BETWEEN :startDate AND :endDate', { startDate, endDate })
            .andWhere('transaction.status = :status', { status: transaction_ledger_entity_1.TransactionStatus.COMPLETED });
        const transactions = await query.getMany();
        const summary = {
            totalTransactions: transactions.length,
            totalAmount: 0,
            totalFees: 0,
            totalPayouts: 0,
            currency,
            period: { start: startDate, end: endDate },
        };
        for (const transaction of transactions) {
            if (transaction.transactionType === transaction_ledger_entity_1.TransactionType.PAYMENT_RECEIVED) {
                summary.totalAmount += transaction.baseAmount;
            }
            else if (transaction.transactionType === transaction_ledger_entity_1.TransactionType.PLATFORM_FEE) {
                summary.totalFees += transaction.baseAmount;
            }
            else if (transaction.transactionType === transaction_ledger_entity_1.TransactionType.COMPANY_PAYOUT) {
                summary.totalPayouts += transaction.baseAmount;
            }
        }
        return summary;
    }
    async getReconciliationReport(startDate, endDate, provider) {
        const query = this.transactionLedgerRepository.createQueryBuilder('transaction')
            .where('transaction.createdAt BETWEEN :startDate AND :endDate', { startDate, endDate })
            .andWhere('transaction.status = :status', { status: transaction_ledger_entity_1.TransactionStatus.COMPLETED });
        if (provider) {
            query.andWhere('transaction.paymentProvider = :provider', { provider });
        }
        const transactions = await query.getMany();
        const report = {
            period: { start: startDate, end: endDate },
            provider: provider || 'all',
            totalTransactions: transactions.length,
            totalAmount: 0,
            totalFees: 0,
            totalPayouts: 0,
            byType: {},
            byProvider: {},
            byStatus: {},
        };
        for (const transaction of transactions) {
            if (!report.byType[transaction.transactionType]) {
                report.byType[transaction.transactionType] = { count: 0, amount: 0 };
            }
            report.byType[transaction.transactionType].count++;
            report.byType[transaction.transactionType].amount += transaction.baseAmount;
            if (!report.byProvider[transaction.paymentProvider]) {
                report.byProvider[transaction.paymentProvider] = { count: 0, amount: 0 };
            }
            report.byProvider[transaction.paymentProvider].count++;
            report.byProvider[transaction.paymentProvider].amount += transaction.baseAmount;
            if (!report.byStatus[transaction.status]) {
                report.byStatus[transaction.status] = { count: 0, amount: 0 };
            }
            report.byStatus[transaction.status].count++;
            report.byStatus[transaction.status].amount += transaction.baseAmount;
            if (transaction.transactionType === transaction_ledger_entity_1.TransactionType.PAYMENT_RECEIVED) {
                report.totalAmount += transaction.baseAmount;
            }
            else if (transaction.transactionType === transaction_ledger_entity_1.TransactionType.PLATFORM_FEE) {
                report.totalFees += transaction.baseAmount;
            }
            else if (transaction.transactionType === transaction_ledger_entity_1.TransactionType.COMPANY_PAYOUT) {
                report.totalPayouts += transaction.baseAmount;
            }
        }
        return report;
    }
    async selectPaymentProvider(request) {
        const providers = [];
        providers.push({
            provider: company_payment_account_entity_1.PaymentProvider.PAYSTACK,
            reason: 'Paystack is the default payment provider',
            priority: 1,
        });
        if (request.currency === transaction_ledger_entity_1.Currency.KES) {
            providers.push({
                provider: company_payment_account_entity_1.PaymentProvider.MPESA,
                reason: 'Currency is KES, M-Pesa is preferred',
                priority: 2,
            });
        }
        if (request.paymentMethod === 'mpesa') {
            providers.push({
                provider: company_payment_account_entity_1.PaymentProvider.MPESA,
                reason: 'User selected M-Pesa payment method',
                priority: 2,
            });
        }
        else if (request.paymentMethod === 'card') {
            providers.push({
                provider: company_payment_account_entity_1.PaymentProvider.PAYSTACK,
                reason: 'User selected card payment method, using Paystack',
                priority: 2,
            });
        }
        const stripeAccount = await this.getCompanyPaymentAccount(request.companyId, company_payment_account_entity_1.PaymentProvider.STRIPE);
        const mpesaAccount = await this.getCompanyPaymentAccount(request.companyId, company_payment_account_entity_1.PaymentProvider.MPESA);
        const paystackAccount = await this.getCompanyPaymentAccount(request.companyId, company_payment_account_entity_1.PaymentProvider.PAYSTACK);
        if (paystackAccount && paystackAccount.accountStatus === 'active') {
            providers.push({
                provider: company_payment_account_entity_1.PaymentProvider.PAYSTACK,
                reason: 'Company has active Paystack account',
                priority: 3,
            });
        }
        if (stripeAccount && stripeAccount.accountStatus === 'active') {
            providers.push({
                provider: company_payment_account_entity_1.PaymentProvider.STRIPE,
                reason: 'Company has active Stripe account',
                priority: 4,
            });
        }
        if (mpesaAccount && mpesaAccount.accountStatus === 'active') {
            providers.push({
                provider: company_payment_account_entity_1.PaymentProvider.MPESA,
                reason: 'Company has active M-Pesa account',
                priority: 4,
            });
        }
        if ([transaction_ledger_entity_1.Currency.USD, transaction_ledger_entity_1.Currency.EUR, transaction_ledger_entity_1.Currency.GBP].includes(request.currency)) {
            providers.push({
                provider: company_payment_account_entity_1.PaymentProvider.PAYSTACK,
                reason: 'Default provider for USD/EUR/GBP',
                priority: 5,
            });
        }
        providers.sort((a, b) => a.priority - b.priority);
        if (providers.length === 0) {
            throw new common_1.BadRequestException('No suitable payment provider found');
        }
        return providers[0];
    }
    async getCompanyPaymentAccount(companyId, provider) {
        return await this.companyPaymentAccountRepository.findOne({
            where: {
                companyId,
                paymentProvider: provider,
                isActive: true,
                accountStatus: company_payment_account_entity_1.AccountStatus.ACTIVE,
            },
        });
    }
    async processStripePayment(request, companyAccount, commission) {
        const stripeRequest = {
            amount: Math.round(request.amount * 100),
            currency: request.currency.toLowerCase(),
            companyAccountId: companyAccount.accountId,
            platformFeeAmount: Math.round(commission.platformCommission * 100),
            description: request.description,
            metadata: {
                bookingId: request.bookingId,
                userId: request.userId,
                companyId: request.companyId,
            },
        };
        return await this.stripeConnectProvider.createSplitPayment(stripeRequest);
    }
    async processMpesaPayment(request, companyAccount, commission) {
        const mpesaRequest = {
            amount: Math.round(request.amount),
            phoneNumber: request.metadata?.phoneNumber || '',
            businessShortCode: companyAccount.metadata?.businessShortCode || '',
            accountReference: request.bookingId,
            transactionDesc: request.description,
            metadata: {
                companyId: request.companyId,
                platformFee: Math.round(commission.platformCommission),
                companyAmount: Math.round(commission.companyAmount),
                bookingId: request.bookingId,
            },
        };
        return await this.mpesaMerchantProvider.createSplitPayment(mpesaRequest);
    }
    async processPaystackPayment(request, companyAccount, commission) {
        return {
            providerTransactionId: `paystack_${Date.now()}`,
            requiresAction: true,
            nextAction: {
                type: 'redirect_to_url',
                redirect_to_url: {
                    url: 'https://paystack.com/pay/mock_reference'
                }
            },
            providerData: {
                paystackReference: `paystack_${Date.now()}`,
                subaccount: companyAccount.accountId,
                splitAmounts: {
                    platformFee: commission.platformCommission,
                    companyAmount: commission.companyAmount
                }
            }
        };
    }
    async createLedgerEntry(data) {
        const entry = this.transactionLedgerRepository.create(data);
        return await this.transactionLedgerRepository.save(entry);
    }
    async updateLedgerEntry(transactionId, updates) {
        await this.transactionLedgerRepository.update({ transactionId }, updates);
    }
    async createSplitLedgerEntries(parentTransactionId, commission, provider) {
        await this.createLedgerEntry({
            transactionId: `${parentTransactionId}_FEE`,
            parentTransactionId,
            companyId: null,
            transactionType: transaction_ledger_entity_1.TransactionType.PLATFORM_FEE,
            paymentProvider: provider,
            amount: commission.platformCommission,
            currency: commission.currency,
            baseAmount: commission.platformCommission,
            netAmount: commission.platformCommission,
            description: `Platform fee for transaction ${parentTransactionId}`,
            status: transaction_ledger_entity_1.TransactionStatus.COMPLETED,
            processedAt: new Date(),
        });
        await this.createLedgerEntry({
            transactionId: `${parentTransactionId}_PAYOUT`,
            parentTransactionId,
            companyId: commission.companyId,
            transactionType: transaction_ledger_entity_1.TransactionType.COMPANY_PAYOUT,
            paymentProvider: provider,
            amount: commission.companyAmount,
            currency: commission.currency,
            baseAmount: commission.companyAmount,
            netAmount: commission.companyAmount,
            description: `Company payout for transaction ${parentTransactionId}`,
            status: transaction_ledger_entity_1.TransactionStatus.COMPLETED,
            processedAt: new Date(),
        });
    }
    generateTransactionId() {
        return `TXN_${Date.now()}_${Math.random().toString(36).substr(2, 9).toUpperCase()}`;
    }
    async getExchangeRate(currency) {
        try {
            const exchangeRate = await this.exchangeRateService.getExchangeRate(currency, transaction_ledger_entity_1.Currency.USD);
            return exchangeRate.rate;
        }
        catch (error) {
            this.logger.error(`Failed to get exchange rate for ${currency}: ${error.message}`);
            const fallbackRates = {
                [transaction_ledger_entity_1.Currency.KES]: 0.0077,
                [transaction_ledger_entity_1.Currency.EUR]: 1.09,
                [transaction_ledger_entity_1.Currency.GBP]: 1.27,
                [transaction_ledger_entity_1.Currency.USD]: 1.0,
            };
            return fallbackRates[currency] || 1.0;
        }
    }
};
exports.UnifiedPaymentService = UnifiedPaymentService;
exports.UnifiedPaymentService = UnifiedPaymentService = UnifiedPaymentService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(transaction_ledger_entity_1.TransactionLedger)),
    __param(1, (0, typeorm_1.InjectRepository)(company_payment_account_entity_2.CompanyPaymentAccount)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof stripe_connect_provider_1.StripeConnectProvider !== "undefined" && stripe_connect_provider_1.StripeConnectProvider) === "function" ? _c : Object, typeof (_d = typeof mpesa_merchant_provider_1.MpesaMerchantProvider !== "undefined" && mpesa_merchant_provider_1.MpesaMerchantProvider) === "function" ? _d : Object, typeof (_e = typeof dynamic_commission_service_1.DynamicCommissionService !== "undefined" && dynamic_commission_service_1.DynamicCommissionService) === "function" ? _e : Object, typeof (_f = typeof exchange_rate_service_1.ExchangeRateService !== "undefined" && exchange_rate_service_1.ExchangeRateService) === "function" ? _f : Object])
], UnifiedPaymentService);


/***/ }),
/* 111 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var DynamicCommissionService_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicCommissionService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const platform_commission_entity_1 = __webpack_require__(112);
const commission_tier_entity_1 = __webpack_require__(113);
const company_commission_entity_1 = __webpack_require__(114);
const commission_history_entity_1 = __webpack_require__(115);
let DynamicCommissionService = DynamicCommissionService_1 = class DynamicCommissionService {
    constructor(platformCommissionRepository, commissionTierRepository, companyCommissionRepository, commissionHistoryRepository) {
        this.platformCommissionRepository = platformCommissionRepository;
        this.commissionTierRepository = commissionTierRepository;
        this.companyCommissionRepository = companyCommissionRepository;
        this.commissionHistoryRepository = commissionHistoryRepository;
        this.logger = new common_1.Logger(DynamicCommissionService_1.name);
    }
    async calculateCommission(request) {
        const { companyId, bookingType, totalAmount, currency, tierType, effectiveDate } = request;
        const effectiveDateToUse = effectiveDate || new Date();
        this.logger.log(`Calculating commission for company ${companyId}, booking type: ${bookingType}, amount: ${totalAmount} ${currency}`);
        const companyCommission = await this.getCompanyCommission(companyId, bookingType, effectiveDateToUse);
        if (companyCommission) {
            return this.calculateWithCompanyCommission(companyCommission, totalAmount, currency);
        }
        if (tierType) {
            const tierCommission = await this.getTierCommission(tierType, bookingType, effectiveDateToUse);
            if (tierCommission) {
                return this.calculateWithTierCommission(tierCommission, totalAmount, currency);
            }
        }
        const platformCommission = await this.getPlatformCommission(bookingType, effectiveDateToUse);
        if (!platformCommission) {
            throw new Error(`No commission configuration found for booking type: ${bookingType}`);
        }
        return this.calculateWithPlatformCommission(platformCommission, totalAmount, currency);
    }
    async getCompanyCommission(companyId, bookingType, effectiveDate) {
        return await this.companyCommissionRepository.findOne({
            where: {
                companyId,
                isActive: true,
                effectiveFrom: (0, typeorm_2.LessThanOrEqual)(effectiveDate),
                effectiveTo: (0, typeorm_2.MoreThanOrEqual)(effectiveDate),
                platformCommission: {
                    bookingType,
                    isActive: true,
                },
            },
            relations: ['platformCommission'],
            order: { effectiveFrom: 'DESC' },
        });
    }
    async getTierCommission(tierType, bookingType, effectiveDate) {
        return await this.commissionTierRepository.findOne({
            where: {
                tierType,
                isActive: true,
                effectiveFrom: (0, typeorm_2.LessThanOrEqual)(effectiveDate),
                effectiveTo: (0, typeorm_2.MoreThanOrEqual)(effectiveDate),
                platformCommission: {
                    bookingType,
                    isActive: true,
                },
            },
            relations: ['platformCommission'],
            order: { effectiveFrom: 'DESC' },
        });
    }
    async getPlatformCommission(bookingType, effectiveDate) {
        return await this.platformCommissionRepository.findOne({
            where: {
                bookingType,
                isActive: true,
                effectiveFrom: (0, typeorm_2.LessThanOrEqual)(effectiveDate),
                effectiveTo: (0, typeorm_2.MoreThanOrEqual)(effectiveDate),
            },
            order: { effectiveFrom: 'DESC' },
        });
    }
    calculateWithCompanyCommission(companyCommission, totalAmount, currency) {
        const { percentageRate, fixedAmount, minCommission, maxCommission } = companyCommission;
        const commissionType = companyCommission.platformCommission.commissionType;
        let platformCommission = 0;
        let appliedRate = 0;
        if (commissionType === platform_commission_entity_1.CommissionType.PERCENTAGE && percentageRate) {
            appliedRate = percentageRate;
            platformCommission = (totalAmount * percentageRate) / 100;
        }
        else if (commissionType === platform_commission_entity_1.CommissionType.FIXED_AMOUNT && fixedAmount) {
            platformCommission = fixedAmount;
            appliedRate = (fixedAmount / totalAmount) * 100;
        }
        else if (commissionType === platform_commission_entity_1.CommissionType.HYBRID) {
            const percentageAmount = percentageRate ? (totalAmount * percentageRate) / 100 : 0;
            const fixedAmountValue = fixedAmount || 0;
            platformCommission = percentageAmount + fixedAmountValue;
            appliedRate = (platformCommission / totalAmount) * 100;
        }
        if (minCommission && platformCommission < minCommission) {
            platformCommission = minCommission;
            appliedRate = (minCommission / totalAmount) * 100;
        }
        if (maxCommission && platformCommission > maxCommission) {
            platformCommission = maxCommission;
            appliedRate = (maxCommission / totalAmount) * 100;
        }
        return {
            platformCommission,
            companyAmount: totalAmount - platformCommission,
            commissionRate: appliedRate,
            commissionType,
            currency,
            calculationDetails: {
                baseRate: percentageRate || 0,
                appliedRate,
                minCommission,
                maxCommission,
                fixedAmount,
            },
        };
    }
    calculateWithTierCommission(tierCommission, totalAmount, currency) {
        const { percentageRate, fixedAmount, minCommission, maxCommission } = tierCommission;
        const commissionType = tierCommission.platformCommission.commissionType;
        let platformCommission = 0;
        let appliedRate = 0;
        if (commissionType === platform_commission_entity_1.CommissionType.PERCENTAGE && percentageRate) {
            appliedRate = percentageRate;
            platformCommission = (totalAmount * percentageRate) / 100;
        }
        else if (commissionType === platform_commission_entity_1.CommissionType.FIXED_AMOUNT && fixedAmount) {
            platformCommission = fixedAmount;
            appliedRate = (fixedAmount / totalAmount) * 100;
        }
        else if (commissionType === platform_commission_entity_1.CommissionType.HYBRID) {
            const percentageAmount = percentageRate ? (totalAmount * percentageRate) / 100 : 0;
            const fixedAmountValue = fixedAmount || 0;
            platformCommission = percentageAmount + fixedAmountValue;
            appliedRate = (platformCommission / totalAmount) * 100;
        }
        if (minCommission && platformCommission < minCommission) {
            platformCommission = minCommission;
            appliedRate = (minCommission / totalAmount) * 100;
        }
        if (maxCommission && platformCommission > maxCommission) {
            platformCommission = maxCommission;
            appliedRate = (maxCommission / totalAmount) * 100;
        }
        return {
            platformCommission,
            companyAmount: totalAmount - platformCommission,
            commissionRate: appliedRate,
            commissionType,
            tierType: tierCommission.tierType,
            currency,
            calculationDetails: {
                baseRate: percentageRate || 0,
                appliedRate,
                minCommission,
                maxCommission,
                fixedAmount,
            },
        };
    }
    calculateWithPlatformCommission(platformCommission, totalAmount, currency) {
        const { percentageRate, fixedAmount, minCommission, maxCommission, commissionType } = platformCommission;
        let platformCommissionAmount = 0;
        let appliedRate = 0;
        if (commissionType === platform_commission_entity_1.CommissionType.PERCENTAGE && percentageRate) {
            appliedRate = percentageRate;
            platformCommissionAmount = (totalAmount * percentageRate) / 100;
        }
        else if (commissionType === platform_commission_entity_1.CommissionType.FIXED_AMOUNT && fixedAmount) {
            platformCommissionAmount = fixedAmount;
            appliedRate = (fixedAmount / totalAmount) * 100;
        }
        else if (commissionType === platform_commission_entity_1.CommissionType.HYBRID) {
            const percentageAmount = percentageRate ? (totalAmount * percentageRate) / 100 : 0;
            const fixedAmountValue = fixedAmount || 0;
            platformCommissionAmount = percentageAmount + fixedAmountValue;
            appliedRate = (platformCommissionAmount / totalAmount) * 100;
        }
        if (minCommission && platformCommissionAmount < minCommission) {
            platformCommissionAmount = minCommission;
            appliedRate = (minCommission / totalAmount) * 100;
        }
        if (maxCommission && platformCommissionAmount > maxCommission) {
            platformCommissionAmount = maxCommission;
            appliedRate = (maxCommission / totalAmount) * 100;
        }
        return {
            platformCommission: platformCommissionAmount,
            companyAmount: totalAmount - platformCommissionAmount,
            commissionRate: appliedRate,
            commissionType,
            currency,
            calculationDetails: {
                baseRate: percentageRate || 0,
                appliedRate,
                minCommission,
                maxCommission,
                fixedAmount,
            },
        };
    }
    async logCommissionChange(entityType, entityId, changeType, oldValues, newValues, changedBy, changeReason, ipAddress, userAgent) {
        const history = this.commissionHistoryRepository.create({
            entityType,
            entityId,
            changeType,
            oldValues,
            newValues,
            changedBy,
            changeReason,
            ipAddress,
            userAgent,
        });
        await this.commissionHistoryRepository.save(history);
        this.logger.log(`Commission change logged: ${changeType} for ${entityType} ${entityId} by ${changedBy}`);
    }
};
exports.DynamicCommissionService = DynamicCommissionService;
exports.DynamicCommissionService = DynamicCommissionService = DynamicCommissionService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(platform_commission_entity_1.PlatformCommission)),
    __param(1, (0, typeorm_1.InjectRepository)(commission_tier_entity_1.CommissionTier)),
    __param(2, (0, typeorm_1.InjectRepository)(company_commission_entity_1.CompanyCommission)),
    __param(3, (0, typeorm_1.InjectRepository)(commission_history_entity_1.CommissionHistory)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object, typeof (_d = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _d : Object])
], DynamicCommissionService);


/***/ }),
/* 112 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlatformCommission = exports.BookingType = exports.CommissionType = void 0;
const typeorm_1 = __webpack_require__(13);
const commission_tier_entity_1 = __webpack_require__(113);
const company_commission_entity_1 = __webpack_require__(114);
var CommissionType;
(function (CommissionType) {
    CommissionType["PERCENTAGE"] = "percentage";
    CommissionType["FIXED_AMOUNT"] = "fixed_amount";
    CommissionType["HYBRID"] = "hybrid";
})(CommissionType || (exports.CommissionType = CommissionType = {}));
var BookingType;
(function (BookingType) {
    BookingType["CHARTER_DEAL"] = "charter_deal";
    BookingType["DIRECT_CHARTER"] = "direct_charter";
})(BookingType || (exports.BookingType = BookingType = {}));
let PlatformCommission = class PlatformCommission {
};
exports.PlatformCommission = PlatformCommission;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], PlatformCommission.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'commissionType', type: 'enum', enum: CommissionType, default: CommissionType.PERCENTAGE }),
    __metadata("design:type", String)
], PlatformCommission.prototype, "commissionType", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'bookingType', type: 'enum', enum: BookingType }),
    __metadata("design:type", String)
], PlatformCommission.prototype, "bookingType", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'percentageRate', type: 'decimal', precision: 5, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], PlatformCommission.prototype, "percentageRate", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'fixedAmount', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], PlatformCommission.prototype, "fixedAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'currency', type: 'varchar', length: 3, default: 'USD' }),
    __metadata("design:type", String)
], PlatformCommission.prototype, "currency", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'minCommission', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], PlatformCommission.prototype, "minCommission", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'maxCommission', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], PlatformCommission.prototype, "maxCommission", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'isActive', type: 'boolean', default: true }),
    __metadata("design:type", Boolean)
], PlatformCommission.prototype, "isActive", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'effectiveFrom', type: 'datetime' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], PlatformCommission.prototype, "effectiveFrom", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'effectiveTo', type: 'datetime', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], PlatformCommission.prototype, "effectiveTo", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'description', type: 'text', nullable: true }),
    __metadata("design:type", String)
], PlatformCommission.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'createdBy', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], PlatformCommission.prototype, "createdBy", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], PlatformCommission.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], PlatformCommission.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => commission_tier_entity_1.CommissionTier, tier => tier.platformCommission),
    __metadata("design:type", Array)
], PlatformCommission.prototype, "tiers", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => company_commission_entity_1.CompanyCommission, companyCommission => companyCommission.platformCommission),
    __metadata("design:type", Array)
], PlatformCommission.prototype, "companyCommissions", void 0);
exports.PlatformCommission = PlatformCommission = __decorate([
    (0, typeorm_1.Entity)('platform_commissions')
], PlatformCommission);


/***/ }),
/* 113 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommissionTier = exports.TierType = void 0;
const typeorm_1 = __webpack_require__(13);
const platform_commission_entity_1 = __webpack_require__(112);
var TierType;
(function (TierType) {
    TierType["STANDARD"] = "standard";
    TierType["PREMIUM"] = "premium";
    TierType["PROMOTIONAL"] = "promotional";
    TierType["REGIONAL"] = "regional";
    TierType["VIP"] = "vip";
})(TierType || (exports.TierType = TierType = {}));
let CommissionTier = class CommissionTier {
};
exports.CommissionTier = CommissionTier;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], CommissionTier.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'tierType', type: 'enum', enum: TierType }),
    __metadata("design:type", String)
], CommissionTier.prototype, "tierType", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'tierName', type: 'varchar', length: 100 }),
    __metadata("design:type", String)
], CommissionTier.prototype, "tierName", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'percentageRate', type: 'decimal', precision: 5, scale: 2 }),
    __metadata("design:type", Number)
], CommissionTier.prototype, "percentageRate", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'fixedAmount', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], CommissionTier.prototype, "fixedAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'currency', type: 'varchar', length: 3, default: 'USD' }),
    __metadata("design:type", String)
], CommissionTier.prototype, "currency", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'minCommission', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], CommissionTier.prototype, "minCommission", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'maxCommission', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], CommissionTier.prototype, "maxCommission", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'isActive', type: 'boolean', default: true }),
    __metadata("design:type", Boolean)
], CommissionTier.prototype, "isActive", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'effectiveFrom', type: 'datetime' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], CommissionTier.prototype, "effectiveFrom", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'effectiveTo', type: 'datetime', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], CommissionTier.prototype, "effectiveTo", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'description', type: 'text', nullable: true }),
    __metadata("design:type", String)
], CommissionTier.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'platformCommissionId', type: 'int' }),
    __metadata("design:type", Number)
], CommissionTier.prototype, "platformCommissionId", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], CommissionTier.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], CommissionTier.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => platform_commission_entity_1.PlatformCommission, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'platformCommissionId' }),
    __metadata("design:type", typeof (_e = typeof platform_commission_entity_1.PlatformCommission !== "undefined" && platform_commission_entity_1.PlatformCommission) === "function" ? _e : Object)
], CommissionTier.prototype, "platformCommission", void 0);
exports.CommissionTier = CommissionTier = __decorate([
    (0, typeorm_1.Entity)('commission_tiers')
], CommissionTier);


/***/ }),
/* 114 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompanyCommission = void 0;
const typeorm_1 = __webpack_require__(13);
const platform_commission_entity_1 = __webpack_require__(112);
const charters_company_entity_1 = __webpack_require__(31);
let CompanyCommission = class CompanyCommission {
};
exports.CompanyCommission = CompanyCommission;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], CompanyCommission.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'companyId', type: 'int' }),
    __metadata("design:type", Number)
], CompanyCommission.prototype, "companyId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'platformCommissionId', type: 'int' }),
    __metadata("design:type", Number)
], CompanyCommission.prototype, "platformCommissionId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'percentageRate', type: 'decimal', precision: 5, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], CompanyCommission.prototype, "percentageRate", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'fixedAmount', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], CompanyCommission.prototype, "fixedAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'currency', type: 'varchar', length: 3, default: 'USD' }),
    __metadata("design:type", String)
], CompanyCommission.prototype, "currency", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'minCommission', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], CompanyCommission.prototype, "minCommission", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'maxCommission', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], CompanyCommission.prototype, "maxCommission", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'isActive', type: 'boolean', default: true }),
    __metadata("design:type", Boolean)
], CompanyCommission.prototype, "isActive", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'effectiveFrom', type: 'datetime' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], CompanyCommission.prototype, "effectiveFrom", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'effectiveTo', type: 'datetime', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], CompanyCommission.prototype, "effectiveTo", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'description', type: 'text', nullable: true }),
    __metadata("design:type", String)
], CompanyCommission.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'createdBy', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], CompanyCommission.prototype, "createdBy", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], CompanyCommission.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], CompanyCommission.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => charters_company_entity_1.ChartersCompany, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'companyId' }),
    __metadata("design:type", typeof (_e = typeof charters_company_entity_1.ChartersCompany !== "undefined" && charters_company_entity_1.ChartersCompany) === "function" ? _e : Object)
], CompanyCommission.prototype, "company", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => platform_commission_entity_1.PlatformCommission, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'platformCommissionId' }),
    __metadata("design:type", typeof (_f = typeof platform_commission_entity_1.PlatformCommission !== "undefined" && platform_commission_entity_1.PlatformCommission) === "function" ? _f : Object)
], CompanyCommission.prototype, "platformCommission", void 0);
exports.CompanyCommission = CompanyCommission = __decorate([
    (0, typeorm_1.Entity)('company_commissions')
], CompanyCommission);


/***/ }),
/* 115 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommissionHistory = exports.CommissionEntityType = exports.CommissionChangeType = void 0;
const typeorm_1 = __webpack_require__(13);
const platform_commission_entity_1 = __webpack_require__(112);
const commission_tier_entity_1 = __webpack_require__(113);
const company_commission_entity_1 = __webpack_require__(114);
var CommissionChangeType;
(function (CommissionChangeType) {
    CommissionChangeType["CREATED"] = "created";
    CommissionChangeType["UPDATED"] = "updated";
    CommissionChangeType["DEACTIVATED"] = "deactivated";
    CommissionChangeType["ACTIVATED"] = "activated";
    CommissionChangeType["DELETED"] = "deleted";
})(CommissionChangeType || (exports.CommissionChangeType = CommissionChangeType = {}));
var CommissionEntityType;
(function (CommissionEntityType) {
    CommissionEntityType["PLATFORM"] = "platform";
    CommissionEntityType["TIER"] = "tier";
    CommissionEntityType["COMPANY"] = "company";
})(CommissionEntityType || (exports.CommissionEntityType = CommissionEntityType = {}));
let CommissionHistory = class CommissionHistory {
};
exports.CommissionHistory = CommissionHistory;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], CommissionHistory.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'entityType', type: 'enum', enum: CommissionEntityType }),
    __metadata("design:type", String)
], CommissionHistory.prototype, "entityType", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'entityId', type: 'int' }),
    __metadata("design:type", Number)
], CommissionHistory.prototype, "entityId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'changeType', type: 'enum', enum: CommissionChangeType }),
    __metadata("design:type", String)
], CommissionHistory.prototype, "changeType", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'oldValues', type: 'json', nullable: true }),
    __metadata("design:type", Object)
], CommissionHistory.prototype, "oldValues", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'newValues', type: 'json', nullable: true }),
    __metadata("design:type", Object)
], CommissionHistory.prototype, "newValues", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'changedBy', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], CommissionHistory.prototype, "changedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'changeReason', type: 'text', nullable: true }),
    __metadata("design:type", String)
], CommissionHistory.prototype, "changeReason", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'ipAddress', type: 'varchar', length: 45, nullable: true }),
    __metadata("design:type", String)
], CommissionHistory.prototype, "ipAddress", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'userAgent', type: 'text', nullable: true }),
    __metadata("design:type", String)
], CommissionHistory.prototype, "userAgent", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], CommissionHistory.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => platform_commission_entity_1.PlatformCommission, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'entityId' }),
    __metadata("design:type", typeof (_b = typeof platform_commission_entity_1.PlatformCommission !== "undefined" && platform_commission_entity_1.PlatformCommission) === "function" ? _b : Object)
], CommissionHistory.prototype, "platformCommission", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => commission_tier_entity_1.CommissionTier, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'entityId' }),
    __metadata("design:type", typeof (_c = typeof commission_tier_entity_1.CommissionTier !== "undefined" && commission_tier_entity_1.CommissionTier) === "function" ? _c : Object)
], CommissionHistory.prototype, "commissionTier", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => company_commission_entity_1.CompanyCommission, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'entityId' }),
    __metadata("design:type", typeof (_d = typeof company_commission_entity_1.CompanyCommission !== "undefined" && company_commission_entity_1.CompanyCommission) === "function" ? _d : Object)
], CommissionHistory.prototype, "companyCommission", void 0);
exports.CommissionHistory = CommissionHistory = __decorate([
    (0, typeorm_1.Entity)('commission_history')
], CommissionHistory);


/***/ }),
/* 116 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StripeConnectController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const jwt_auth_guard_1 = __webpack_require__(16);
const roles_guard_1 = __webpack_require__(61);
const roles_decorator_1 = __webpack_require__(62);
const company_onboarding_service_1 = __webpack_require__(109);
const stripe_connect_provider_1 = __webpack_require__(106);
const company_payment_account_entity_1 = __webpack_require__(91);
const express_1 = __webpack_require__(117);
let StripeConnectController = class StripeConnectController {
    constructor(companyOnboardingService, stripeConnectProvider) {
        this.companyOnboardingService = companyOnboardingService;
        this.stripeConnectProvider = stripeConnectProvider;
    }
    async onboardCompany(dto) {
        const result = await this.companyOnboardingService.onboardCompany(dto);
        return {
            success: true,
            message: 'Company onboarding initiated successfully',
            data: result,
        };
    }
    async getOnboardingStatus(companyId, provider = company_payment_account_entity_1.PaymentProvider.STRIPE) {
        const status = await this.companyOnboardingService.getOnboardingStatus(companyId, provider);
        return {
            success: true,
            data: status,
        };
    }
    async refreshOnboardingLink(companyId, provider = company_payment_account_entity_1.PaymentProvider.STRIPE) {
        const onboardingUrl = await this.companyOnboardingService.refreshOnboardingLink(companyId, provider);
        return {
            success: true,
            message: 'Onboarding link refreshed successfully',
            data: { onboardingUrl },
        };
    }
    async getCompanyPaymentAccounts(companyId) {
        const accounts = await this.companyOnboardingService.getCompanyPaymentAccounts(companyId);
        return {
            success: true,
            data: accounts,
        };
    }
    async createSplitPayment(request) {
        const result = await this.stripeConnectProvider.createSplitPayment(request);
        return {
            success: true,
            message: 'Split payment created successfully',
            data: result,
        };
    }
    async confirmSplitPayment(paymentIntentId, body) {
        const result = await this.stripeConnectProvider.confirmSplitPayment(paymentIntentId, body.paymentMethodId);
        return {
            success: true,
            message: 'Payment confirmed successfully',
            data: result,
        };
    }
    async getAccountBalance(accountId) {
        const balance = await this.stripeConnectProvider.getAccountBalance(accountId);
        return {
            success: true,
            data: balance,
        };
    }
    async getAccountPayouts(accountId, limit = 10) {
        const payouts = await this.stripeConnectProvider.getAccountPayouts(accountId, limit);
        return {
            success: true,
            data: payouts,
        };
    }
    async handleWebhook(req, res) {
        const signature = req.headers['stripe-signature'];
        const payload = req.body;
        if (!signature) {
            return res.status(400).json({ error: 'Missing stripe-signature header' });
        }
        try {
            const result = await this.stripeConnectProvider.handleWebhook(payload, signature);
            return res.status(200).json({ received: true, result });
        }
        catch (error) {
            return res.status(400).json({ error: error.message });
        }
    }
    async deactivateAccount(accountId) {
        await this.companyOnboardingService.deactivateAccount(accountId);
        return {
            success: true,
            message: 'Account deactivated successfully',
        };
    }
};
exports.StripeConnectController = StripeConnectController;
__decorate([
    (0, common_1.Post)('onboard'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Onboard a company to Stripe Connect' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Company onboarded successfully' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                companyId: { type: 'number' },
                paymentProvider: { type: 'string', enum: ['stripe', 'mpesa'] },
                accountType: { type: 'string', enum: ['express', 'custom', 'standard'] },
                country: { type: 'string' },
                currency: { type: 'string' },
            },
            required: ['companyId', 'paymentProvider', 'country'],
        },
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof company_onboarding_service_1.OnboardCompanyDto !== "undefined" && company_onboarding_service_1.OnboardCompanyDto) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], StripeConnectController.prototype, "onboardCompany", null);
__decorate([
    (0, common_1.Get)('onboarding-status/:companyId'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get company onboarding status' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Onboarding status retrieved successfully' }),
    __param(0, (0, common_1.Param)('companyId', common_1.ParseIntPipe)),
    __param(1, (0, common_1.Query)('provider')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, typeof (_d = typeof company_payment_account_entity_1.PaymentProvider !== "undefined" && company_payment_account_entity_1.PaymentProvider) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], StripeConnectController.prototype, "getOnboardingStatus", null);
__decorate([
    (0, common_1.Post)('refresh-onboarding/:companyId'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Refresh onboarding link for company' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Onboarding link refreshed successfully' }),
    __param(0, (0, common_1.Param)('companyId', common_1.ParseIntPipe)),
    __param(1, (0, common_1.Query)('provider')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, typeof (_e = typeof company_payment_account_entity_1.PaymentProvider !== "undefined" && company_payment_account_entity_1.PaymentProvider) === "function" ? _e : Object]),
    __metadata("design:returntype", Promise)
], StripeConnectController.prototype, "refreshOnboardingLink", null);
__decorate([
    (0, common_1.Get)('company-accounts/:companyId'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all payment accounts for a company' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Company payment accounts retrieved successfully' }),
    __param(0, (0, common_1.Param)('companyId', common_1.ParseIntPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], StripeConnectController.prototype, "getCompanyPaymentAccounts", null);
__decorate([
    (0, common_1.Post)('split-payment'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Create a split payment with platform fee' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Split payment created successfully' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                amount: { type: 'number', description: 'Amount in cents' },
                currency: { type: 'string' },
                companyAccountId: { type: 'string' },
                platformFeeAmount: { type: 'number', description: 'Platform fee in cents' },
                description: { type: 'string' },
                metadata: { type: 'object' },
                customerId: { type: 'string' },
                paymentMethodId: { type: 'string' },
            },
            required: ['amount', 'currency', 'companyAccountId', 'platformFeeAmount', 'description'],
        },
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_f = typeof stripe_connect_provider_1.SplitPaymentRequest !== "undefined" && stripe_connect_provider_1.SplitPaymentRequest) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], StripeConnectController.prototype, "createSplitPayment", null);
__decorate([
    (0, common_1.Post)('confirm-payment/:paymentIntentId'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Confirm a split payment' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Payment confirmed successfully' }),
    __param(0, (0, common_1.Param)('paymentIntentId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], StripeConnectController.prototype, "confirmSplitPayment", null);
__decorate([
    (0, common_1.Get)('account-balance/:accountId'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get Stripe Connect account balance' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Account balance retrieved successfully' }),
    __param(0, (0, common_1.Param)('accountId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], StripeConnectController.prototype, "getAccountBalance", null);
__decorate([
    (0, common_1.Get)('account-payouts/:accountId'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get account payouts' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Account payouts retrieved successfully' }),
    __param(0, (0, common_1.Param)('accountId')),
    __param(1, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", Promise)
], StripeConnectController.prototype, "getAccountPayouts", null);
__decorate([
    (0, common_1.Post)('webhook'),
    (0, swagger_1.ApiOperation)({ summary: 'Handle Stripe webhooks' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Webhook processed successfully' }),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_g = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _g : Object, typeof (_h = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _h : Object]),
    __metadata("design:returntype", Promise)
], StripeConnectController.prototype, "handleWebhook", null);
__decorate([
    (0, common_1.Post)('deactivate-account/:accountId'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Deactivate a payment account' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Account deactivated successfully' }),
    __param(0, (0, common_1.Param)('accountId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], StripeConnectController.prototype, "deactivateAccount", null);
exports.StripeConnectController = StripeConnectController = __decorate([
    (0, swagger_1.ApiTags)('Stripe Connect'),
    (0, swagger_1.ApiBearerAuth)(),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, common_1.Controller)('stripe-connect'),
    __metadata("design:paramtypes", [typeof (_a = typeof company_onboarding_service_1.CompanyOnboardingService !== "undefined" && company_onboarding_service_1.CompanyOnboardingService) === "function" ? _a : Object, typeof (_b = typeof stripe_connect_provider_1.StripeConnectProvider !== "undefined" && stripe_connect_provider_1.StripeConnectProvider) === "function" ? _b : Object])
], StripeConnectController);


/***/ }),
/* 117 */
/***/ ((module) => {

module.exports = require("express");

/***/ }),
/* 118 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var MpesaMerchantController_1;
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MpesaMerchantController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const jwt_auth_guard_1 = __webpack_require__(16);
const roles_guard_1 = __webpack_require__(61);
const roles_decorator_1 = __webpack_require__(62);
const mpesa_merchant_provider_1 = __webpack_require__(107);
const express_1 = __webpack_require__(117);
let MpesaMerchantController = MpesaMerchantController_1 = class MpesaMerchantController {
    constructor(mpesaMerchantProvider) {
        this.mpesaMerchantProvider = mpesaMerchantProvider;
        this.logger = new common_1.Logger(MpesaMerchantController_1.name);
    }
    async createSplitPayment(request) {
        const result = await this.mpesaMerchantProvider.createSplitPayment(request);
        return {
            success: true,
            message: 'M-Pesa split payment initiated successfully',
            data: result,
        };
    }
    async checkPaymentStatus(checkoutRequestId) {
        const status = await this.mpesaMerchantProvider.checkPaymentStatus(checkoutRequestId);
        return {
            success: true,
            data: status,
        };
    }
    async processSplitPayment(transactionId, body) {
        const result = await this.mpesaMerchantProvider.processSplitPayment(transactionId, body.platformAccount, body.companyAccount, body.platformAmount, body.companyAmount);
        return {
            success: true,
            message: 'Split payment processed successfully',
            data: result,
        };
    }
    async getMerchantBalance(merchantId) {
        const balance = await this.mpesaMerchantProvider.getMerchantBalance(merchantId);
        return {
            success: true,
            data: balance,
        };
    }
    async getMerchantTransactions(merchantId, fromDate, toDate) {
        const transactions = await this.mpesaMerchantProvider.getMerchantTransactions(merchantId, fromDate, toDate);
        return {
            success: true,
            data: transactions,
        };
    }
    async handleWebhook(req, res) {
        const payload = req.body;
        try {
            const result = await this.mpesaMerchantProvider.handleWebhook(payload);
            return res.status(200).json({ received: true, result });
        }
        catch (error) {
            return res.status(400).json({ error: error.message });
        }
    }
    async handleSplitCallback(req, res) {
        const payload = req.body;
        try {
            const metadata = payload.CallbackMetadata?.Item?.find((item) => item.Name === 'Metadata')?.Value;
            if (metadata) {
                const companyId = metadata.companyId;
                const platformFee = metadata.platformFee;
                const companyAmount = metadata.companyAmount;
                const bookingId = metadata.bookingId;
                if (payload.ResultCode === '0') {
                    const splitResult = await this.mpesaMerchantProvider.processSplitPayment(payload.CheckoutRequestID, 'PLATFORM_ACCOUNT', `COMPANY_${companyId}`, platformFee, companyAmount);
                    return res.status(200).json({
                        success: true,
                        message: 'Split payment processed successfully',
                        data: splitResult,
                    });
                }
                else {
                    return res.status(200).json({
                        success: false,
                        message: 'Payment failed',
                        error: payload.ResultDesc,
                    });
                }
            }
            return res.status(200).json({ received: true });
        }
        catch (error) {
            this.logger.error('M-Pesa split callback processing failed', error);
            return res.status(400).json({ error: error.message });
        }
    }
};
exports.MpesaMerchantController = MpesaMerchantController;
__decorate([
    (0, common_1.Post)('split-payment'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Create M-Pesa split payment with STK Push' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Split payment initiated successfully' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                amount: { type: 'number', description: 'Amount in KES' },
                phoneNumber: { type: 'string' },
                businessShortCode: { type: 'string' },
                accountReference: { type: 'string' },
                transactionDesc: { type: 'string' },
                metadata: {
                    type: 'object',
                    properties: {
                        companyId: { type: 'number' },
                        platformFee: { type: 'number' },
                        companyAmount: { type: 'number' },
                        bookingId: { type: 'string' },
                    },
                },
            },
            required: ['amount', 'phoneNumber', 'businessShortCode', 'accountReference', 'transactionDesc', 'metadata'],
        },
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof mpesa_merchant_provider_1.SplitPaymentRequest !== "undefined" && mpesa_merchant_provider_1.SplitPaymentRequest) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], MpesaMerchantController.prototype, "createSplitPayment", null);
__decorate([
    (0, common_1.Get)('payment-status/:checkoutRequestId'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Check M-Pesa payment status' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Payment status retrieved successfully' }),
    __param(0, (0, common_1.Param)('checkoutRequestId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], MpesaMerchantController.prototype, "checkPaymentStatus", null);
__decorate([
    (0, common_1.Post)('process-split/:transactionId'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Process split payment after successful transaction' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Split payment processed successfully' }),
    __param(0, (0, common_1.Param)('transactionId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], MpesaMerchantController.prototype, "processSplitPayment", null);
__decorate([
    (0, common_1.Get)('merchant-balance/:merchantId'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get M-Pesa merchant account balance' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Merchant balance retrieved successfully' }),
    __param(0, (0, common_1.Param)('merchantId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], MpesaMerchantController.prototype, "getMerchantBalance", null);
__decorate([
    (0, common_1.Get)('merchant-transactions/:merchantId'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get M-Pesa merchant transactions' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Merchant transactions retrieved successfully' }),
    __param(0, (0, common_1.Param)('merchantId')),
    __param(1, (0, common_1.Query)('fromDate')),
    __param(2, (0, common_1.Query)('toDate')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], MpesaMerchantController.prototype, "getMerchantTransactions", null);
__decorate([
    (0, common_1.Post)('webhook'),
    (0, swagger_1.ApiOperation)({ summary: 'Handle M-Pesa webhooks' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Webhook processed successfully' }),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _c : Object, typeof (_d = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], MpesaMerchantController.prototype, "handleWebhook", null);
__decorate([
    (0, common_1.Post)('split-callback'),
    (0, swagger_1.ApiOperation)({ summary: 'Handle M-Pesa split payment callback' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Split payment callback processed successfully' }),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_e = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _e : Object, typeof (_f = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], MpesaMerchantController.prototype, "handleSplitCallback", null);
exports.MpesaMerchantController = MpesaMerchantController = MpesaMerchantController_1 = __decorate([
    (0, swagger_1.ApiTags)('M-Pesa Merchant'),
    (0, swagger_1.ApiBearerAuth)(),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, common_1.Controller)('mpesa-merchant'),
    __metadata("design:paramtypes", [typeof (_a = typeof mpesa_merchant_provider_1.MpesaMerchantProvider !== "undefined" && mpesa_merchant_provider_1.MpesaMerchantProvider) === "function" ? _a : Object])
], MpesaMerchantController);


/***/ }),
/* 119 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnifiedPaymentController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const jwt_auth_guard_1 = __webpack_require__(16);
const roles_guard_1 = __webpack_require__(61);
const roles_decorator_1 = __webpack_require__(62);
const unified_payment_service_1 = __webpack_require__(110);
const transaction_ledger_entity_1 = __webpack_require__(90);
const company_payment_account_entity_1 = __webpack_require__(91);
const express_1 = __webpack_require__(117);
let UnifiedPaymentController = class UnifiedPaymentController {
    constructor(unifiedPaymentService) {
        this.unifiedPaymentService = unifiedPaymentService;
    }
    async processPayment(request, req) {
        const enhancedRequest = {
            ...request,
            ipAddress: req.ip || req.connection.remoteAddress,
            userAgent: req.headers['user-agent'],
        };
        const result = await this.unifiedPaymentService.processPayment(enhancedRequest);
        return {
            success: true,
            message: 'Payment processed successfully',
            data: result,
        };
    }
    async confirmPayment(transactionId, body) {
        const result = await this.unifiedPaymentService.confirmPayment(transactionId, body.paymentMethodId);
        return {
            success: true,
            message: 'Payment confirmed successfully',
            data: result,
        };
    }
    async getTransaction(transactionId) {
        const transaction = await this.unifiedPaymentService.getTransactionById(transactionId);
        if (!transaction) {
            return {
                success: false,
                message: 'Transaction not found',
            };
        }
        return {
            success: true,
            data: transaction,
        };
    }
    async getCompanyTransactions(companyId, startDate, endDate, status, type, provider, page = '1', limit = '20') {
        const filters = {
            startDate: startDate ? new Date(startDate) : undefined,
            endDate: endDate ? new Date(endDate) : undefined,
            status,
            type,
            provider,
        };
        const result = await this.unifiedPaymentService.getTransactionsByCompany(companyId, filters, parseInt(page), parseInt(limit));
        return {
            success: true,
            data: result.transactions,
            pagination: {
                total: result.total,
                page: parseInt(page),
                limit: parseInt(limit),
                totalPages: Math.ceil(result.total / parseInt(limit)),
            },
        };
    }
    async getCompanySummary(companyId, startDate, endDate, currency = transaction_ledger_entity_1.Currency.USD) {
        const summary = await this.unifiedPaymentService.getTransactionSummary(companyId, new Date(startDate), new Date(endDate), currency);
        return {
            success: true,
            data: summary,
        };
    }
    async getReconciliationReport(startDate, endDate, provider) {
        const report = await this.unifiedPaymentService.getReconciliationReport(new Date(startDate), new Date(endDate), provider);
        return {
            success: true,
            data: report,
        };
    }
    async getAllTransactions(startDate, endDate, status, type, provider, companyId, userId, bookingId, page = '1', limit = '50') {
        return {
            success: true,
            message: 'Advanced ledger filtering will be implemented',
            data: [],
        };
    }
    async exportLedger(startDate, endDate, format = 'csv', provider, companyId) {
        return {
            success: true,
            message: 'Ledger export functionality will be implemented',
            data: {
                format,
                period: { startDate, endDate },
                provider,
                companyId,
            },
        };
    }
    async getDashboardStats(period = 'month') {
        const now = new Date();
        let startDate;
        switch (period) {
            case 'today':
                startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                break;
            case 'week':
                startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                break;
            case 'month':
                startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                break;
            case 'year':
                startDate = new Date(now.getFullYear(), 0, 1);
                break;
            default:
                startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        }
        const stats = {
            period,
            totalTransactions: 0,
            totalAmount: 0,
            totalFees: 0,
            totalPayouts: 0,
            byProvider: {},
            byStatus: {},
            byType: {},
        };
        return {
            success: true,
            data: stats,
        };
    }
};
exports.UnifiedPaymentController = UnifiedPaymentController;
__decorate([
    (0, common_1.Post)('process'),
    (0, roles_decorator_1.Roles)('user', 'admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Process payment with automatic provider selection' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Payment processed successfully' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                userId: { type: 'number' },
                companyId: { type: 'number' },
                bookingId: { type: 'string' },
                amount: { type: 'number' },
                currency: { type: 'string', enum: ['USD', 'KES', 'EUR', 'GBP'] },
                paymentMethod: { type: 'string', enum: ['card', 'mpesa', 'bank_transfer'] },
                description: { type: 'string' },
                metadata: { type: 'object' },
            },
            required: ['userId', 'companyId', 'bookingId', 'amount', 'currency', 'paymentMethod', 'description'],
        },
    }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof unified_payment_service_1.UnifiedPaymentRequest !== "undefined" && unified_payment_service_1.UnifiedPaymentRequest) === "function" ? _b : Object, typeof (_c = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], UnifiedPaymentController.prototype, "processPayment", null);
__decorate([
    (0, common_1.Post)('confirm/:transactionId'),
    (0, roles_decorator_1.Roles)('user', 'admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Confirm a pending payment' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Payment confirmed successfully' }),
    __param(0, (0, common_1.Param)('transactionId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], UnifiedPaymentController.prototype, "confirmPayment", null);
__decorate([
    (0, common_1.Get)('transaction/:transactionId'),
    (0, roles_decorator_1.Roles)('user', 'admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get transaction details by ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Transaction details retrieved successfully' }),
    __param(0, (0, common_1.Param)('transactionId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], UnifiedPaymentController.prototype, "getTransaction", null);
__decorate([
    (0, common_1.Get)('company/:companyId/transactions'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get company transactions with filters' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Company transactions retrieved successfully' }),
    __param(0, (0, common_1.Param)('companyId', common_1.ParseIntPipe)),
    __param(1, (0, common_1.Query)('startDate')),
    __param(2, (0, common_1.Query)('endDate')),
    __param(3, (0, common_1.Query)('status')),
    __param(4, (0, common_1.Query)('type')),
    __param(5, (0, common_1.Query)('provider')),
    __param(6, (0, common_1.Query)('page')),
    __param(7, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, String, String, typeof (_d = typeof transaction_ledger_entity_1.TransactionStatus !== "undefined" && transaction_ledger_entity_1.TransactionStatus) === "function" ? _d : Object, typeof (_e = typeof transaction_ledger_entity_1.TransactionType !== "undefined" && transaction_ledger_entity_1.TransactionType) === "function" ? _e : Object, typeof (_f = typeof company_payment_account_entity_1.PaymentProvider !== "undefined" && company_payment_account_entity_1.PaymentProvider) === "function" ? _f : Object, String, String]),
    __metadata("design:returntype", Promise)
], UnifiedPaymentController.prototype, "getCompanyTransactions", null);
__decorate([
    (0, common_1.Get)('company/:companyId/summary'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get company transaction summary' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Transaction summary retrieved successfully' }),
    __param(0, (0, common_1.Param)('companyId', common_1.ParseIntPipe)),
    __param(1, (0, common_1.Query)('startDate')),
    __param(2, (0, common_1.Query)('endDate')),
    __param(3, (0, common_1.Query)('currency')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, String, String, typeof (_g = typeof transaction_ledger_entity_1.Currency !== "undefined" && transaction_ledger_entity_1.Currency) === "function" ? _g : Object]),
    __metadata("design:returntype", Promise)
], UnifiedPaymentController.prototype, "getCompanySummary", null);
__decorate([
    (0, common_1.Get)('reconciliation-report'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get reconciliation report' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Reconciliation report retrieved successfully' }),
    __param(0, (0, common_1.Query)('startDate')),
    __param(1, (0, common_1.Query)('endDate')),
    __param(2, (0, common_1.Query)('provider')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, typeof (_h = typeof company_payment_account_entity_1.PaymentProvider !== "undefined" && company_payment_account_entity_1.PaymentProvider) === "function" ? _h : Object]),
    __metadata("design:returntype", Promise)
], UnifiedPaymentController.prototype, "getReconciliationReport", null);
__decorate([
    (0, common_1.Get)('ledger/transactions'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all transactions with advanced filtering' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Transactions retrieved successfully' }),
    __param(0, (0, common_1.Query)('startDate')),
    __param(1, (0, common_1.Query)('endDate')),
    __param(2, (0, common_1.Query)('status')),
    __param(3, (0, common_1.Query)('type')),
    __param(4, (0, common_1.Query)('provider')),
    __param(5, (0, common_1.Query)('companyId')),
    __param(6, (0, common_1.Query)('userId')),
    __param(7, (0, common_1.Query)('bookingId')),
    __param(8, (0, common_1.Query)('page')),
    __param(9, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, typeof (_j = typeof transaction_ledger_entity_1.TransactionStatus !== "undefined" && transaction_ledger_entity_1.TransactionStatus) === "function" ? _j : Object, typeof (_k = typeof transaction_ledger_entity_1.TransactionType !== "undefined" && transaction_ledger_entity_1.TransactionType) === "function" ? _k : Object, typeof (_l = typeof company_payment_account_entity_1.PaymentProvider !== "undefined" && company_payment_account_entity_1.PaymentProvider) === "function" ? _l : Object, String, String, String, String, String]),
    __metadata("design:returntype", Promise)
], UnifiedPaymentController.prototype, "getAllTransactions", null);
__decorate([
    (0, common_1.Get)('ledger/export'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Export transaction ledger to CSV/Excel' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Ledger exported successfully' }),
    __param(0, (0, common_1.Query)('startDate')),
    __param(1, (0, common_1.Query)('endDate')),
    __param(2, (0, common_1.Query)('format')),
    __param(3, (0, common_1.Query)('provider')),
    __param(4, (0, common_1.Query)('companyId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, typeof (_m = typeof company_payment_account_entity_1.PaymentProvider !== "undefined" && company_payment_account_entity_1.PaymentProvider) === "function" ? _m : Object, String]),
    __metadata("design:returntype", Promise)
], UnifiedPaymentController.prototype, "exportLedger", null);
__decorate([
    (0, common_1.Get)('dashboard/stats'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get payment dashboard statistics' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Dashboard stats retrieved successfully' }),
    __param(0, (0, common_1.Query)('period')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], UnifiedPaymentController.prototype, "getDashboardStats", null);
exports.UnifiedPaymentController = UnifiedPaymentController = __decorate([
    (0, swagger_1.ApiTags)('Unified Payments'),
    (0, swagger_1.ApiBearerAuth)(),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, common_1.Controller)('unified-payments'),
    __metadata("design:paramtypes", [typeof (_a = typeof unified_payment_service_1.UnifiedPaymentService !== "undefined" && unified_payment_service_1.UnifiedPaymentService) === "function" ? _a : Object])
], UnifiedPaymentController);


/***/ }),
/* 120 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PaystackController_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaystackController = void 0;
const common_1 = __webpack_require__(2);
const paystack_provider_1 = __webpack_require__(88);
const payment_provider_service_1 = __webpack_require__(83);
const payment_provider_interface_1 = __webpack_require__(84);
const config_1 = __webpack_require__(5);
let PaystackController = PaystackController_1 = class PaystackController {
    constructor(paystackProvider, paymentProviderService, configService) {
        this.paystackProvider = paystackProvider;
        this.paymentProviderService = paymentProviderService;
        this.configService = configService;
        this.logger = new common_1.Logger(PaystackController_1.name);
    }
    async initializePayment(request) {
        try {
            this.logger.log(`Initializing Paystack payment for booking: ${request.bookingId}`);
            const paymentRequest = {
                amount: request.amount,
                currency: request.currency,
                bookingId: request.bookingId,
                userId: request.userId,
                description: request.description || `Payment for booking ${request.bookingId}`,
                metadata: {
                    ...request.metadata,
                    customerEmail: request.email,
                    companyId: request.companyId,
                },
            };
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Payment initialization timeout')), 30000);
            });
            const result = await Promise.race([
                this.paymentProviderService.createPaymentIntent(paymentRequest, payment_provider_interface_1.PaymentProviderType.PAYSTACK),
                timeoutPromise
            ]);
            return {
                success: true,
                data: result,
                message: 'Payment initialized successfully',
            };
        }
        catch (error) {
            this.logger.error(`Paystack payment initialization failed: ${error.message}`, error.stack);
            throw new common_1.BadRequestException(`Payment initialization failed: ${error.message}`);
        }
    }
    async verifyPayment(reference) {
        try {
            this.logger.log(`Verifying Paystack payment: ${reference}`);
            const result = await this.paymentProviderService.getPaymentStatus(reference, payment_provider_interface_1.PaymentProviderType.PAYSTACK);
            this.logger.log(`Payment verification result: ${JSON.stringify({
                reference,
                status: result.status,
                amount: result.amount,
                currency: result.currency
            })}`);
            return {
                success: true,
                data: result,
                message: result.status === 'succeeded'
                    ? 'Payment verification completed successfully'
                    : `Payment verification completed with status: ${result.status}`,
            };
        }
        catch (error) {
            this.logger.error(`Paystack payment verification failed: ${error.message}`, error.stack);
            throw new common_1.BadRequestException(`Payment verification failed: ${error.message}`);
        }
    }
    async handleWebhook(event, signature) {
        try {
            this.logger.log(`Received Paystack webhook: ${event.event}`);
            if (!this.verifyWebhookSignature(event, signature)) {
                this.logger.error('Invalid Paystack webhook signature');
                throw new common_1.BadRequestException('Invalid webhook signature');
            }
            const processed = await this.paystackProvider.handleWebhook(event, signature);
            if (processed) {
                return { success: true, message: 'Webhook processed successfully' };
            }
            else {
                throw new common_1.BadRequestException('Webhook processing failed');
            }
        }
        catch (error) {
            this.logger.error(`Paystack webhook processing failed: ${error.message}`, error.stack);
            throw new common_1.BadRequestException(`Webhook processing failed: ${error.message}`);
        }
    }
    async createSubaccount(request) {
        try {
            this.logger.log(`Creating Paystack subaccount for company: ${request.companyId}`);
            const subaccountData = {
                companyName: request.companyName,
                email: request.email,
                mobileNumber: request.phone,
                bankCode: request.bankCode,
                accountNumber: request.accountNumber,
                commissionRate: request.commissionRate || 0,
            };
            const result = await this.paystackProvider.createVendorSubaccount(request.companyId, subaccountData);
            return {
                success: true,
                data: result,
                message: 'Subaccount created successfully',
            };
        }
        catch (error) {
            this.logger.error(`Paystack subaccount creation failed: ${error.message}`, error.stack);
            throw new common_1.BadRequestException(`Subaccount creation failed: ${error.message}`);
        }
    }
    async getProviderInfo() {
        try {
            const publicKey = this.configService.get('PAYSTACK_PUBLIC_KEY');
            if (!publicKey) {
                throw new common_1.BadRequestException('Paystack public key not configured');
            }
            return {
                success: true,
                data: {
                    name: this.paystackProvider.name,
                    publicKey: publicKey,
                    supportedCurrencies: this.paystackProvider.supportedCurrencies,
                    supportedPaymentMethods: this.paystackProvider.supportedPaymentMethods,
                },
                message: 'Paystack provider information retrieved',
            };
        }
        catch (error) {
            this.logger.error(`Failed to get provider info: ${error.message}`, error.stack);
            throw new common_1.BadRequestException(`Failed to get provider info: ${error.message}`);
        }
    }
    verifyWebhookSignature(event, signature) {
        try {
            if (process.env.NODE_ENV === 'development') {
                this.logger.warn('Skipping webhook signature verification in development mode');
                return true;
            }
            const webhookSecret = process.env.PAYSTACK_WEBHOOK_SECRET;
            if (!webhookSecret) {
                this.logger.error('PAYSTACK_WEBHOOK_SECRET not configured');
                return false;
            }
            if (!signature) {
                this.logger.error('No webhook signature provided');
                return false;
            }
            const crypto = __webpack_require__(93);
            const expectedSignature = crypto
                .createHmac('sha512', webhookSecret)
                .update(JSON.stringify(event))
                .digest('hex');
            const isValid = crypto.timingSafeEqual(Buffer.from(signature, 'hex'), Buffer.from(expectedSignature, 'hex'));
            if (!isValid) {
                this.logger.error('Invalid webhook signature');
                return false;
            }
            return true;
        }
        catch (error) {
            this.logger.error(`Webhook signature verification failed: ${error.message}`);
            return false;
        }
    }
};
exports.PaystackController = PaystackController;
__decorate([
    (0, common_1.Post)('initialize'),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PaystackController.prototype, "initializePayment", null);
__decorate([
    (0, common_1.Get)('verify/:reference'),
    __param(0, (0, common_1.Param)('reference')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PaystackController.prototype, "verifyPayment", null);
__decorate([
    (0, common_1.Post)('webhook'),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, common_1.Headers)('x-paystack-signature')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", Promise)
], PaystackController.prototype, "handleWebhook", null);
__decorate([
    (0, common_1.Post)('subaccount'),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PaystackController.prototype, "createSubaccount", null);
__decorate([
    (0, common_1.Get)('info'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PaystackController.prototype, "getProviderInfo", null);
exports.PaystackController = PaystackController = PaystackController_1 = __decorate([
    (0, common_1.Controller)('payments/paystack'),
    __metadata("design:paramtypes", [typeof (_a = typeof paystack_provider_1.PaystackProvider !== "undefined" && paystack_provider_1.PaystackProvider) === "function" ? _a : Object, typeof (_b = typeof payment_provider_service_1.PaymentProviderService !== "undefined" && payment_provider_service_1.PaymentProviderService) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object])
], PaystackController);


/***/ }),
/* 121 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ExchangeRateController_1;
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExchangeRateController = void 0;
const common_1 = __webpack_require__(2);
const exchange_rate_service_1 = __webpack_require__(89);
const transaction_ledger_entity_1 = __webpack_require__(90);
let ExchangeRateController = ExchangeRateController_1 = class ExchangeRateController {
    constructor(exchangeRateService) {
        this.exchangeRateService = exchangeRateService;
        this.logger = new common_1.Logger(ExchangeRateController_1.name);
    }
    async getExchangeRate(from, to) {
        try {
            this.logger.log(`Getting exchange rate: ${from} to ${to}`);
            const exchangeRate = await this.exchangeRateService.getExchangeRate(from, to);
            return {
                success: true,
                data: {
                    from: exchangeRate.from,
                    to: exchangeRate.to,
                    rate: exchangeRate.rate,
                    timestamp: exchangeRate.timestamp,
                    source: exchangeRate.source,
                },
                message: `Exchange rate: 1 ${from} = ${exchangeRate.rate} ${to}`,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get exchange rate: ${error.message}`, error.stack);
            return {
                success: false,
                error: error.message,
                message: 'Failed to get exchange rate',
            };
        }
    }
    async convertCurrency(amount, from, to) {
        try {
            this.logger.log(`Converting ${amount} ${from} to ${to}`);
            const conversion = await this.exchangeRateService.convertCurrency({
                amount,
                from,
                to,
            });
            return {
                success: true,
                data: {
                    originalAmount: conversion.originalAmount,
                    convertedAmount: conversion.convertedAmount,
                    from: conversion.from,
                    to: conversion.to,
                    rate: conversion.rate,
                    timestamp: conversion.timestamp,
                },
                message: `${amount} ${from} = ${conversion.convertedAmount} ${to}`,
            };
        }
        catch (error) {
            this.logger.error(`Failed to convert currency: ${error.message}`, error.stack);
            return {
                success: false,
                error: error.message,
                message: 'Failed to convert currency',
            };
        }
    }
    async getUSDToKESRate() {
        try {
            const rate = await this.exchangeRateService.getUSDToKESRate();
            return {
                success: true,
                data: {
                    from: 'USD',
                    to: 'KES',
                    rate,
                    timestamp: new Date(),
                },
                message: `1 USD = ${rate} KES`,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get USD to KES rate: ${error.message}`, error.stack);
            return {
                success: false,
                error: error.message,
                message: 'Failed to get USD to KES rate',
            };
        }
    }
    async getKESToUSDRate() {
        try {
            const rate = await this.exchangeRateService.getKESToUSDRate();
            return {
                success: true,
                data: {
                    from: 'KES',
                    to: 'USD',
                    rate,
                    timestamp: new Date(),
                },
                message: `1 KES = ${rate} USD`,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get KES to USD rate: ${error.message}`, error.stack);
            return {
                success: false,
                error: error.message,
                message: 'Failed to get KES to USD rate',
            };
        }
    }
    async getCacheStats() {
        try {
            const stats = this.exchangeRateService.getCacheStats();
            return {
                success: true,
                data: stats,
                message: 'Cache statistics retrieved',
            };
        }
        catch (error) {
            this.logger.error(`Failed to get cache stats: ${error.message}`, error.stack);
            return {
                success: false,
                error: error.message,
                message: 'Failed to get cache statistics',
            };
        }
    }
    async clearCache() {
        try {
            this.exchangeRateService.clearCache();
            return {
                success: true,
                message: 'Cache cleared successfully',
            };
        }
        catch (error) {
            this.logger.error(`Failed to clear cache: ${error.message}`, error.stack);
            return {
                success: false,
                error: error.message,
                message: 'Failed to clear cache',
            };
        }
    }
};
exports.ExchangeRateController = ExchangeRateController;
__decorate([
    (0, common_1.Get)(),
    __param(0, (0, common_1.Query)('from')),
    __param(1, (0, common_1.Query)('to')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof transaction_ledger_entity_1.Currency !== "undefined" && transaction_ledger_entity_1.Currency) === "function" ? _b : Object, typeof (_c = typeof transaction_ledger_entity_1.Currency !== "undefined" && transaction_ledger_entity_1.Currency) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], ExchangeRateController.prototype, "getExchangeRate", null);
__decorate([
    (0, common_1.Get)('convert'),
    __param(0, (0, common_1.Query)('amount')),
    __param(1, (0, common_1.Query)('from')),
    __param(2, (0, common_1.Query)('to')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, typeof (_d = typeof transaction_ledger_entity_1.Currency !== "undefined" && transaction_ledger_entity_1.Currency) === "function" ? _d : Object, typeof (_e = typeof transaction_ledger_entity_1.Currency !== "undefined" && transaction_ledger_entity_1.Currency) === "function" ? _e : Object]),
    __metadata("design:returntype", Promise)
], ExchangeRateController.prototype, "convertCurrency", null);
__decorate([
    (0, common_1.Get)('usd-to-kes'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ExchangeRateController.prototype, "getUSDToKESRate", null);
__decorate([
    (0, common_1.Get)('kes-to-usd'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ExchangeRateController.prototype, "getKESToUSDRate", null);
__decorate([
    (0, common_1.Get)('cache/stats'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ExchangeRateController.prototype, "getCacheStats", null);
__decorate([
    (0, common_1.Get)('cache/clear'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ExchangeRateController.prototype, "clearCache", null);
exports.ExchangeRateController = ExchangeRateController = ExchangeRateController_1 = __decorate([
    (0, common_1.Controller)('payments/exchange-rate'),
    __metadata("design:paramtypes", [typeof (_a = typeof exchange_rate_service_1.ExchangeRateService !== "undefined" && exchange_rate_service_1.ExchangeRateService) === "function" ? _a : Object])
], ExchangeRateController);


/***/ }),
/* 122 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommissionModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const platform_commission_entity_1 = __webpack_require__(112);
const commission_tier_entity_1 = __webpack_require__(113);
const company_commission_entity_1 = __webpack_require__(114);
const commission_history_entity_1 = __webpack_require__(115);
const dynamic_commission_service_1 = __webpack_require__(111);
const commission_management_service_1 = __webpack_require__(123);
const commission_controller_1 = __webpack_require__(124);
let CommissionModule = class CommissionModule {
};
exports.CommissionModule = CommissionModule;
exports.CommissionModule = CommissionModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([
                platform_commission_entity_1.PlatformCommission,
                commission_tier_entity_1.CommissionTier,
                company_commission_entity_1.CompanyCommission,
                commission_history_entity_1.CommissionHistory,
            ]),
        ],
        controllers: [commission_controller_1.CommissionController],
        providers: [
            dynamic_commission_service_1.DynamicCommissionService,
            commission_management_service_1.CommissionManagementService,
        ],
        exports: [
            dynamic_commission_service_1.DynamicCommissionService,
            commission_management_service_1.CommissionManagementService,
        ],
    })
], CommissionModule);


/***/ }),
/* 123 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var CommissionManagementService_1;
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommissionManagementService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const platform_commission_entity_1 = __webpack_require__(112);
const commission_tier_entity_1 = __webpack_require__(113);
const company_commission_entity_1 = __webpack_require__(114);
const commission_history_entity_1 = __webpack_require__(115);
const dynamic_commission_service_1 = __webpack_require__(111);
const typeorm_3 = __webpack_require__(13);
let CommissionManagementService = CommissionManagementService_1 = class CommissionManagementService {
    constructor(platformCommissionRepository, commissionTierRepository, companyCommissionRepository, commissionHistoryRepository, dynamicCommissionService) {
        this.platformCommissionRepository = platformCommissionRepository;
        this.commissionTierRepository = commissionTierRepository;
        this.companyCommissionRepository = companyCommissionRepository;
        this.commissionHistoryRepository = commissionHistoryRepository;
        this.dynamicCommissionService = dynamicCommissionService;
        this.logger = new common_1.Logger(CommissionManagementService_1.name);
    }
    async createPlatformCommission(dto) {
        this.validateCommissionType(dto.commissionType, dto.percentageRate, dto.fixedAmount);
        const commission = this.platformCommissionRepository.create(dto);
        const savedCommission = await this.platformCommissionRepository.save(commission);
        await this.dynamicCommissionService.logCommissionChange(commission_history_entity_1.CommissionEntityType.PLATFORM, savedCommission.id, commission_history_entity_1.CommissionChangeType.CREATED, null, savedCommission, dto.createdBy, 'Platform commission created');
        this.logger.log(`Platform commission created: ${savedCommission.id} for ${dto.bookingType}`);
        return savedCommission;
    }
    async updatePlatformCommission(id, updates, updatedBy, reason) {
        const commission = await this.platformCommissionRepository.findOne({ where: { id } });
        if (!commission) {
            throw new common_1.NotFoundException(`Platform commission with ID ${id} not found`);
        }
        if (updates.commissionType) {
            this.validateCommissionType(updates.commissionType, updates.percentageRate, updates.fixedAmount);
        }
        const oldValues = { ...commission };
        Object.assign(commission, updates);
        const updatedCommission = await this.platformCommissionRepository.save(commission);
        await this.dynamicCommissionService.logCommissionChange(commission_history_entity_1.CommissionEntityType.PLATFORM, id, commission_history_entity_1.CommissionChangeType.UPDATED, oldValues, updatedCommission, updatedBy, reason);
        this.logger.log(`Platform commission updated: ${id} by ${updatedBy}`);
        return updatedCommission;
    }
    async getPlatformCommissions(bookingType) {
        const query = this.platformCommissionRepository.createQueryBuilder('pc');
        if (bookingType) {
            query.where('pc.bookingType = :bookingType', { bookingType });
        }
        return await query.orderBy('pc.effectiveFrom', 'DESC').getMany();
    }
    async getActivePlatformCommission(bookingType) {
        return await this.platformCommissionRepository.findOne({
            where: {
                bookingType,
                isActive: true,
                effectiveFrom: (0, typeorm_3.LessThanOrEqual)(new Date()),
                effectiveTo: (0, typeorm_3.MoreThanOrEqual)(new Date()),
            },
            order: { effectiveFrom: 'DESC' },
        });
    }
    async createCommissionTier(dto) {
        const platformCommission = await this.platformCommissionRepository.findOne({
            where: { id: dto.platformCommissionId },
        });
        if (!platformCommission) {
            throw new common_1.NotFoundException(`Platform commission with ID ${dto.platformCommissionId} not found`);
        }
        const tier = this.commissionTierRepository.create(dto);
        const savedTier = await this.commissionTierRepository.save(tier);
        this.logger.log(`Commission tier created: ${savedTier.id} - ${dto.tierName}`);
        return savedTier;
    }
    async getCommissionTiers(platformCommissionId) {
        const query = this.commissionTierRepository.createQueryBuilder('tier');
        if (platformCommissionId) {
            query.where('tier.platformCommissionId = :platformCommissionId', { platformCommissionId });
        }
        return await query
            .leftJoinAndSelect('tier.platformCommission', 'pc')
            .orderBy('tier.effectiveFrom', 'DESC')
            .getMany();
    }
    async createCompanyCommission(dto) {
        const platformCommission = await this.platformCommissionRepository.findOne({
            where: { id: dto.platformCommissionId },
        });
        if (!platformCommission) {
            throw new common_1.NotFoundException(`Platform commission with ID ${dto.platformCommissionId} not found`);
        }
        const companyCommission = this.companyCommissionRepository.create(dto);
        const savedCompanyCommission = await this.companyCommissionRepository.save(companyCommission);
        await this.dynamicCommissionService.logCommissionChange(commission_history_entity_1.CommissionEntityType.COMPANY, savedCompanyCommission.id, commission_history_entity_1.CommissionChangeType.CREATED, null, savedCompanyCommission, dto.createdBy, 'Company commission created');
        this.logger.log(`Company commission created: ${savedCompanyCommission.id} for company ${dto.companyId}`);
        return savedCompanyCommission;
    }
    async getCompanyCommissions(companyId) {
        const query = this.companyCommissionRepository.createQueryBuilder('cc');
        if (companyId) {
            query.where('cc.companyId = :companyId', { companyId });
        }
        return await query
            .leftJoinAndSelect('cc.platformCommission', 'pc')
            .leftJoinAndSelect('cc.company', 'company')
            .orderBy('cc.effectiveFrom', 'DESC')
            .getMany();
    }
    async getActiveCompanyCommission(companyId, bookingType) {
        return await this.companyCommissionRepository.findOne({
            where: {
                companyId,
                isActive: true,
                effectiveFrom: (0, typeorm_3.LessThanOrEqual)(new Date()),
                effectiveTo: (0, typeorm_3.MoreThanOrEqual)(new Date()),
                platformCommission: {
                    bookingType,
                    isActive: true,
                },
            },
            relations: ['platformCommission'],
            order: { effectiveFrom: 'DESC' },
        });
    }
    async getCommissionHistory(entityType, entityId, limit = 50) {
        const query = this.commissionHistoryRepository.createQueryBuilder('history');
        if (entityType) {
            query.andWhere('history.entityType = :entityType', { entityType });
        }
        if (entityId) {
            query.andWhere('history.entityId = :entityId', { entityId });
        }
        return await query
            .orderBy('history.createdAt', 'DESC')
            .limit(limit)
            .getMany();
    }
    validateCommissionType(commissionType, percentageRate, fixedAmount) {
        switch (commissionType) {
            case platform_commission_entity_1.CommissionType.PERCENTAGE:
                if (!percentageRate || percentageRate <= 0) {
                    throw new common_1.BadRequestException('Percentage rate is required and must be greater than 0 for percentage commission type');
                }
                if (percentageRate > 100) {
                    throw new common_1.BadRequestException('Percentage rate cannot exceed 100%');
                }
                break;
            case platform_commission_entity_1.CommissionType.FIXED_AMOUNT:
                if (!fixedAmount || fixedAmount <= 0) {
                    throw new common_1.BadRequestException('Fixed amount is required and must be greater than 0 for fixed amount commission type');
                }
                break;
            case platform_commission_entity_1.CommissionType.HYBRID:
                if ((!percentageRate || percentageRate <= 0) && (!fixedAmount || fixedAmount <= 0)) {
                    throw new common_1.BadRequestException('Either percentage rate or fixed amount (or both) must be provided for hybrid commission type');
                }
                if (percentageRate && percentageRate > 100) {
                    throw new common_1.BadRequestException('Percentage rate cannot exceed 100%');
                }
                break;
            default:
                throw new common_1.BadRequestException(`Unsupported commission type: ${commissionType}`);
        }
    }
};
exports.CommissionManagementService = CommissionManagementService;
exports.CommissionManagementService = CommissionManagementService = CommissionManagementService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(platform_commission_entity_1.PlatformCommission)),
    __param(1, (0, typeorm_1.InjectRepository)(commission_tier_entity_1.CommissionTier)),
    __param(2, (0, typeorm_1.InjectRepository)(company_commission_entity_1.CompanyCommission)),
    __param(3, (0, typeorm_1.InjectRepository)(commission_history_entity_1.CommissionHistory)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object, typeof (_d = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _d : Object, typeof (_e = typeof dynamic_commission_service_1.DynamicCommissionService !== "undefined" && dynamic_commission_service_1.DynamicCommissionService) === "function" ? _e : Object])
], CommissionManagementService);


/***/ }),
/* 124 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommissionController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const jwt_auth_guard_1 = __webpack_require__(16);
const roles_guard_1 = __webpack_require__(61);
const roles_decorator_1 = __webpack_require__(62);
const dynamic_commission_service_1 = __webpack_require__(111);
const commission_management_service_1 = __webpack_require__(123);
const platform_commission_entity_1 = __webpack_require__(112);
let CommissionController = class CommissionController {
    constructor(dynamicCommissionService, commissionManagementService) {
        this.dynamicCommissionService = dynamicCommissionService;
        this.commissionManagementService = commissionManagementService;
    }
    async calculateCommission(request) {
        const result = await this.dynamicCommissionService.calculateCommission(request);
        return {
            success: true,
            data: result,
        };
    }
    async createPlatformCommission(dto) {
        const commission = await this.commissionManagementService.createPlatformCommission(dto);
        return {
            success: true,
            message: 'Platform commission created successfully',
            data: commission,
        };
    }
    async getPlatformCommissions(bookingType) {
        const commissions = await this.commissionManagementService.getPlatformCommissions(bookingType);
        return {
            success: true,
            data: commissions,
        };
    }
    async getActivePlatformCommission(bookingType) {
        const commission = await this.commissionManagementService.getActivePlatformCommission(bookingType);
        return {
            success: true,
            data: commission,
        };
    }
    async createCommissionTier(dto) {
        const tier = await this.commissionManagementService.createCommissionTier(dto);
        return {
            success: true,
            message: 'Commission tier created successfully',
            data: tier,
        };
    }
    async getCommissionTiers(platformCommissionId) {
        const tiers = await this.commissionManagementService.getCommissionTiers(platformCommissionId);
        return {
            success: true,
            data: tiers,
        };
    }
    async createCompanyCommission(dto) {
        const commission = await this.commissionManagementService.createCompanyCommission(dto);
        return {
            success: true,
            message: 'Company commission created successfully',
            data: commission,
        };
    }
    async getCompanyCommissions(companyId) {
        const commissions = await this.commissionManagementService.getCompanyCommissions(companyId);
        return {
            success: true,
            data: commissions,
        };
    }
    async getActiveCompanyCommission(companyId, bookingType) {
        const commission = await this.commissionManagementService.getActiveCompanyCommission(companyId, bookingType);
        return {
            success: true,
            data: commission,
        };
    }
    async getCommissionHistory(entityType, entityId, limit = 50) {
        const history = await this.commissionManagementService.getCommissionHistory(entityType, entityId, limit);
        return {
            success: true,
            data: history,
        };
    }
};
exports.CommissionController = CommissionController;
__decorate([
    (0, common_1.Post)('calculate'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Calculate commission for a booking' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Commission calculated successfully' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof dynamic_commission_service_1.CommissionCalculationRequest !== "undefined" && dynamic_commission_service_1.CommissionCalculationRequest) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], CommissionController.prototype, "calculateCommission", null);
__decorate([
    (0, common_1.Post)('platform'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Create platform commission configuration' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Platform commission created successfully' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof commission_management_service_1.CreatePlatformCommissionDto !== "undefined" && commission_management_service_1.CreatePlatformCommissionDto) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], CommissionController.prototype, "createPlatformCommission", null);
__decorate([
    (0, common_1.Get)('platform'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get platform commission configurations' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Platform commissions retrieved successfully' }),
    __param(0, (0, common_1.Query)('bookingType')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_e = typeof platform_commission_entity_1.BookingType !== "undefined" && platform_commission_entity_1.BookingType) === "function" ? _e : Object]),
    __metadata("design:returntype", Promise)
], CommissionController.prototype, "getPlatformCommissions", null);
__decorate([
    (0, common_1.Get)('platform/active/:bookingType'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get active platform commission for booking type' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Active platform commission retrieved successfully' }),
    __param(0, (0, common_1.Param)('bookingType')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_f = typeof platform_commission_entity_1.BookingType !== "undefined" && platform_commission_entity_1.BookingType) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], CommissionController.prototype, "getActivePlatformCommission", null);
__decorate([
    (0, common_1.Post)('tier'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Create commission tier' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Commission tier created successfully' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_g = typeof commission_management_service_1.CreateCommissionTierDto !== "undefined" && commission_management_service_1.CreateCommissionTierDto) === "function" ? _g : Object]),
    __metadata("design:returntype", Promise)
], CommissionController.prototype, "createCommissionTier", null);
__decorate([
    (0, common_1.Get)('tier'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get commission tiers' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Commission tiers retrieved successfully' }),
    __param(0, (0, common_1.Query)('platformCommissionId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], CommissionController.prototype, "getCommissionTiers", null);
__decorate([
    (0, common_1.Post)('company'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Create company-specific commission' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Company commission created successfully' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_h = typeof commission_management_service_1.CreateCompanyCommissionDto !== "undefined" && commission_management_service_1.CreateCompanyCommissionDto) === "function" ? _h : Object]),
    __metadata("design:returntype", Promise)
], CommissionController.prototype, "createCompanyCommission", null);
__decorate([
    (0, common_1.Get)('company'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get company commission configurations' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Company commissions retrieved successfully' }),
    __param(0, (0, common_1.Query)('companyId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], CommissionController.prototype, "getCompanyCommissions", null);
__decorate([
    (0, common_1.Get)('company/active/:companyId/:bookingType'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get active company commission' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Active company commission retrieved successfully' }),
    __param(0, (0, common_1.Param)('companyId', common_1.ParseIntPipe)),
    __param(1, (0, common_1.Param)('bookingType')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, typeof (_j = typeof platform_commission_entity_1.BookingType !== "undefined" && platform_commission_entity_1.BookingType) === "function" ? _j : Object]),
    __metadata("design:returntype", Promise)
], CommissionController.prototype, "getActiveCompanyCommission", null);
__decorate([
    (0, common_1.Get)('history'),
    (0, roles_decorator_1.Roles)('admin', 'superadmin'),
    (0, swagger_1.ApiOperation)({ summary: 'Get commission change history' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Commission history retrieved successfully' }),
    __param(0, (0, common_1.Query)('entityType')),
    __param(1, (0, common_1.Query)('entityId')),
    __param(2, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number, Number]),
    __metadata("design:returntype", Promise)
], CommissionController.prototype, "getCommissionHistory", null);
exports.CommissionController = CommissionController = __decorate([
    (0, swagger_1.ApiTags)('Commission Management'),
    (0, swagger_1.ApiBearerAuth)(),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, common_1.Controller)('commission'),
    __metadata("design:paramtypes", [typeof (_a = typeof dynamic_commission_service_1.DynamicCommissionService !== "undefined" && dynamic_commission_service_1.DynamicCommissionService) === "function" ? _a : Object, typeof (_b = typeof commission_management_service_1.CommissionManagementService !== "undefined" && commission_management_service_1.CommissionManagementService) === "function" ? _b : Object])
], CommissionController);


/***/ }),
/* 125 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailModule = void 0;
const common_1 = __webpack_require__(2);
const email_service_1 = __webpack_require__(81);
let EmailModule = class EmailModule {
};
exports.EmailModule = EmailModule;
exports.EmailModule = EmailModule = __decorate([
    (0, common_1.Module)({
        providers: [email_service_1.EmailService],
        exports: [email_service_1.EmailService],
    })
], EmailModule);


/***/ }),
/* 126 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TripsModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const trips_controller_1 = __webpack_require__(127);
const trips_service_1 = __webpack_require__(128);
const trip_scheduler_service_1 = __webpack_require__(129);
const user_trips_entity_1 = __webpack_require__(77);
const booking_entity_1 = __webpack_require__(29);
const charter_deal_entity_1 = __webpack_require__(30);
const charters_company_entity_1 = __webpack_require__(31);
const aircraft_entity_1 = __webpack_require__(35);
let TripsModule = class TripsModule {
};
exports.TripsModule = TripsModule;
exports.TripsModule = TripsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([
                user_trips_entity_1.UserTrip,
                booking_entity_1.Booking,
                charter_deal_entity_1.CharterDeal,
                charters_company_entity_1.ChartersCompany,
                aircraft_entity_1.Aircraft,
            ]),
        ],
        controllers: [trips_controller_1.TripsController],
        providers: [trips_service_1.TripsService, trip_scheduler_service_1.TripSchedulerService],
        exports: [trips_service_1.TripsService, trip_scheduler_service_1.TripSchedulerService],
    })
], TripsModule);


/***/ }),
/* 127 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TripsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const jwt_auth_guard_1 = __webpack_require__(16);
const trips_service_1 = __webpack_require__(128);
const user_trips_entity_1 = __webpack_require__(77);
let TripsController = class TripsController {
    constructor(tripsService) {
        this.tripsService = tripsService;
    }
    async getPendingBookings(req) {
        const userId = req.user.sub;
        const pendingBookings = await this.tripsService.getPendingBookings(userId);
        return {
            success: true,
            message: 'Pending bookings retrieved successfully',
            data: pendingBookings,
        };
    }
    async getTripHistory(req) {
        const userId = req.user.sub;
        const tripHistory = await this.tripsService.getUserTripHistory(userId);
        return {
            success: true,
            message: 'Trip history retrieved successfully',
            data: tripHistory,
        };
    }
    async getTripsByStatus(status, req) {
        const userId = req.user.sub;
        if (!Object.values(user_trips_entity_1.UserTripStatus).includes(status)) {
            throw new common_1.BadRequestException('Invalid trip status');
        }
        const trips = await this.tripsService.getTripsByStatus(userId, status);
        return {
            success: true,
            message: `${status} trips retrieved successfully`,
            data: trips,
        };
    }
    async getTripById(id, req) {
        const userId = req.user.sub;
        const trip = await this.tripsService.getTripById(id, userId);
        return {
            success: true,
            message: 'Trip retrieved successfully',
            data: trip,
        };
    }
    async updateTripStatus(id, body, req) {
        const userId = req.user.sub;
        if (!Object.values(user_trips_entity_1.UserTripStatus).includes(body.status)) {
            throw new common_1.BadRequestException('Invalid trip status');
        }
        const updatedTrip = await this.tripsService.updateTripStatus(id, userId, body.status);
        return {
            success: true,
            message: 'Trip status updated successfully',
            data: updatedTrip,
        };
    }
    async addTripReview(id, reviewData, req) {
        const userId = req.user.sub;
        if (!reviewData.rating || !reviewData.review) {
            throw new common_1.BadRequestException('Rating and review are required');
        }
        const updatedTrip = await this.tripsService.addTripReview(id, userId, reviewData);
        return {
            success: true,
            message: 'Review added successfully',
            data: updatedTrip,
        };
    }
    async getTripStats(req) {
        const userId = req.user.sub;
        const stats = await this.tripsService.getTripStats(userId);
        return {
            success: true,
            message: 'Trip statistics retrieved successfully',
            data: stats,
        };
    }
    async getMyTripHistory(req) {
        const userId = req.user.sub;
        const tripHistory = await this.tripsService.getUserTripHistory(userId);
        return {
            success: true,
            message: 'Trip history retrieved successfully',
            data: tripHistory,
        };
    }
};
exports.TripsController = TripsController;
__decorate([
    (0, common_1.Get)('pending'),
    (0, swagger_1.ApiOperation)({ summary: 'Get pending bookings (bookings without user trips)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Pending bookings retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'string' },
                            bookingId: { type: 'string' },
                            status: { type: 'string', enum: ['pending'] },
                            booking: { type: 'object' },
                        },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TripsController.prototype, "getPendingBookings", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get user trip history' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Trip history retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'string' },
                            bookingId: { type: 'string' },
                            status: { type: 'string', enum: ['upcoming', 'completed', 'cancelled'] },
                            rating: { type: 'number', nullable: true },
                            review: { type: 'string', nullable: true },
                            reviewDate: { type: 'string', format: 'date-time', nullable: true },
                            photos: { type: 'string', nullable: true },
                            videos: { type: 'string', nullable: true },
                            createdAt: { type: 'string', format: 'date-time' },
                            completedAt: { type: 'string', format: 'date-time', nullable: true },
                            cancelledAt: { type: 'string', format: 'date-time', nullable: true },
                            booking: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string' },
                                    referenceNumber: { type: 'string' },
                                    totalPrice: { type: 'number' },
                                    bookingStatus: { type: 'string' },
                                    paymentStatus: { type: 'string' },
                                    createdAt: { type: 'string', format: 'date-time' },
                                    deal: {
                                        type: 'object',
                                        properties: {
                                            id: { type: 'number' },
                                            date: { type: 'string', format: 'date' },
                                            time: { type: 'string' },
                                            pricePerSeat: { type: 'number' },
                                            company: {
                                                type: 'object',
                                                properties: {
                                                    id: { type: 'number' },
                                                    name: { type: 'string' },
                                                    logo: { type: 'string', nullable: true },
                                                },
                                            },
                                            route: {
                                                type: 'object',
                                                properties: {
                                                    origin: { type: 'string' },
                                                    destination: { type: 'string' },
                                                    duration: { type: 'string' },
                                                },
                                            },
                                            aircraft: {
                                                type: 'object',
                                                properties: {
                                                    id: { type: 'number' },
                                                    name: { type: 'string' },
                                                    type: { type: 'string' },
                                                    capacity: { type: 'number' },
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TripsController.prototype, "getTripHistory", null);
__decorate([
    (0, common_1.Get)('status/:status'),
    (0, swagger_1.ApiOperation)({ summary: 'Get trips by status (upcoming, completed, cancelled)' }),
    (0, swagger_1.ApiParam)({ name: 'status', enum: user_trips_entity_1.UserTripStatus, description: 'Trip status' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Trips retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'string' },
                            bookingId: { type: 'string' },
                            status: { type: 'string' },
                            rating: { type: 'number', nullable: true },
                            review: { type: 'string', nullable: true },
                            createdAt: { type: 'string', format: 'date-time' },
                            booking: { type: 'object' },
                        },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid status' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Param)('status')),
    __param(1, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TripsController.prototype, "getTripsByStatus", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, swagger_1.ApiOperation)({ summary: 'Get specific trip by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Trip ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Trip retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: { type: 'object' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Trip not found' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TripsController.prototype, "getTripById", null);
__decorate([
    (0, common_1.Put)(':id/status'),
    (0, swagger_1.ApiOperation)({ summary: 'Update trip status' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Trip ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Trip status updated successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: { type: 'object' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid status' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Trip not found' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], TripsController.prototype, "updateTripStatus", null);
__decorate([
    (0, common_1.Post)(':id/review'),
    (0, swagger_1.ApiOperation)({ summary: 'Add or update trip review and rating' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Trip ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Review added successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: { type: 'object' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid review data' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Trip not found' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], TripsController.prototype, "addTripReview", null);
__decorate([
    (0, common_1.Get)('stats/overview'),
    (0, swagger_1.ApiOperation)({ summary: 'Get trip statistics for user' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Trip statistics retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'object',
                    properties: {
                        total: { type: 'number' },
                        upcoming: { type: 'number' },
                        completed: { type: 'number' },
                        cancelled: { type: 'number' },
                        averageRating: { type: 'number' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TripsController.prototype, "getTripStats", null);
__decorate([
    (0, common_1.Get)('me/trip-history'),
    (0, swagger_1.ApiOperation)({ summary: 'Get current user trip history (legacy endpoint)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Trip history retrieved successfully',
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TripsController.prototype, "getMyTripHistory", null);
exports.TripsController = TripsController = __decorate([
    (0, swagger_1.ApiTags)('Trips'),
    (0, common_1.Controller)('trips'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof trips_service_1.TripsService !== "undefined" && trips_service_1.TripsService) === "function" ? _a : Object])
], TripsController);


/***/ }),
/* 128 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TripsService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const user_trips_entity_1 = __webpack_require__(77);
const booking_entity_1 = __webpack_require__(29);
const charter_deal_entity_1 = __webpack_require__(30);
const charters_company_entity_1 = __webpack_require__(31);
const aircraft_entity_1 = __webpack_require__(35);
let TripsService = class TripsService {
    constructor(userTripRepository, bookingRepository, charterDealRepository, companyRepository, aircraftRepository, dataSource) {
        this.userTripRepository = userTripRepository;
        this.bookingRepository = bookingRepository;
        this.charterDealRepository = charterDealRepository;
        this.companyRepository = companyRepository;
        this.aircraftRepository = aircraftRepository;
        this.dataSource = dataSource;
    }
    async getUserTripHistory(userId) {
        try {
            const bookings = await this.bookingRepository
                .createQueryBuilder('booking')
                .leftJoinAndSelect('booking.passengers', 'passengers')
                .leftJoinAndSelect('booking.deal', 'deal')
                .leftJoinAndSelect('deal.company', 'company')
                .leftJoinAndSelect('deal.aircraft', 'aircraft')
                .leftJoinAndSelect('booking.aircraft', 'directAircraft')
                .leftJoinAndSelect('directAircraft.company', 'directCompany')
                .where('booking.userId = :userId', { userId })
                .orderBy('booking.createdAt', 'DESC')
                .getMany();
            return bookings.map(booking => this.formatBookingAsTrip(booking));
        }
        catch (error) {
            console.error('Error fetching user trip history:', error);
            return [];
        }
    }
    async getTripsByStatus(userId, status) {
        try {
            const allTrips = await this.getUserTripHistory(userId);
            return allTrips.filter(trip => trip.status === status);
        }
        catch (error) {
            console.error('Error fetching trips by status:', error);
            return [];
        }
    }
    async getTripById(tripId, userId) {
        const userTrip = await this.userTripRepository
            .createQueryBuilder('userTrip')
            .leftJoinAndSelect('userTrip.booking', 'booking')
            .leftJoinAndSelect('booking.passengers', 'passengers')
            .leftJoinAndSelect('booking.deal', 'deal')
            .leftJoinAndSelect('deal.company', 'company')
            .leftJoinAndSelect('deal.aircraft', 'aircraft')
            .where('userTrip.id = :tripId', { tripId })
            .andWhere('userTrip.userId = :userId', { userId })
            .getOne();
        if (!userTrip) {
            throw new common_1.NotFoundException('Trip not found');
        }
        return this.formatTripResponse(userTrip);
    }
    async updateTripStatus(tripId, userId, status) {
        const userTrip = await this.userTripRepository.findOne({
            where: { id: tripId, userId },
        });
        if (!userTrip) {
            throw new common_1.NotFoundException('Trip not found');
        }
        userTrip.status = status;
        if (status === user_trips_entity_1.UserTripStatus.COMPLETED) {
            userTrip.completedAt = new Date();
        }
        else if (status === user_trips_entity_1.UserTripStatus.CANCELLED) {
            userTrip.cancelledAt = new Date();
        }
        const updatedTrip = await this.userTripRepository.save(userTrip);
        return this.getTripById(tripId, userId);
    }
    async addTripReview(tripId, userId, reviewData) {
        const userTrip = await this.userTripRepository.findOne({
            where: { id: tripId, userId },
        });
        if (!userTrip) {
            throw new common_1.NotFoundException('Trip not found');
        }
        if (reviewData.rating < 1 || reviewData.rating > 5) {
            throw new common_1.BadRequestException('Rating must be between 1 and 5');
        }
        userTrip.rating = reviewData.rating;
        userTrip.review = reviewData.review;
        userTrip.reviewDate = new Date();
        userTrip.photos = reviewData.photos;
        userTrip.videos = reviewData.videos;
        await this.userTripRepository.save(userTrip);
        return this.getTripById(tripId, userId);
    }
    async getTripStats(userId) {
        const userTrips = await this.userTripRepository
            .createQueryBuilder('userTrip')
            .leftJoinAndSelect('userTrip.booking', 'booking')
            .leftJoinAndSelect('booking.deal', 'deal')
            .where('userTrip.user_id = :userId', { userId })
            .getMany();
        const totalTrips = userTrips.length;
        let upcoming = 0;
        let completed = 0;
        let cancelled = 0;
        let totalRating = 0;
        let ratedTrips = 0;
        for (const trip of userTrips) {
            const calculatedStatus = trip.calculatedStatus;
            switch (calculatedStatus) {
                case user_trips_entity_1.UserTripStatus.UPCOMING:
                    upcoming++;
                    break;
                case user_trips_entity_1.UserTripStatus.COMPLETED:
                    completed++;
                    break;
                case user_trips_entity_1.UserTripStatus.CANCELLED:
                    cancelled++;
                    break;
            }
            if (trip.rating && trip.rating > 0) {
                totalRating += trip.rating;
                ratedTrips++;
            }
        }
        const averageRating = ratedTrips > 0 ? totalRating / ratedTrips : 0;
        return {
            total: totalTrips,
            upcoming,
            completed,
            cancelled,
            averageRating: parseFloat(averageRating.toFixed(2)),
        };
    }
    async getPendingBookings(userId) {
        const pendingBookings = await this.bookingRepository
            .createQueryBuilder('booking')
            .leftJoinAndSelect('booking.passengers', 'passengers')
            .leftJoinAndSelect('booking.deal', 'deal')
            .leftJoinAndSelect('deal.company', 'company')
            .leftJoinAndSelect('deal.aircraft', 'aircraft')
            .where('booking.userId = :userId', { userId })
            .andWhere('booking.bookingStatus IN (:...statuses)', {
            statuses: ['pending', 'priced']
        })
            .andWhere('booking.paymentStatus = :paymentStatus', {
            paymentStatus: 'pending'
        })
            .andWhere('NOT EXISTS (SELECT 1 FROM user_trips ut WHERE ut.booking_id = booking.id)')
            .orderBy('booking.createdAt', 'DESC')
            .getMany();
        return pendingBookings.map(booking => this.formatBookingAsTrip(booking));
    }
    formatBookingAsTrip(booking) {
        const deal = booking.deal;
        const company = deal?.company;
        const aircraft = deal?.aircraft;
        const directAircraft = booking.aircraft;
        const directCompany = directAircraft?.company;
        const calculatedStatus = this.calculateTripStatus(booking);
        return {
            id: `trip_${booking.id}`,
            userId: booking.userId,
            bookingId: booking.id,
            status: calculatedStatus,
            rating: null,
            review: null,
            reviewDate: null,
            photos: null,
            videos: null,
            createdAt: booking.createdAt,
            completedAt: calculatedStatus === 'completed' ? booking.departureDateTime : null,
            cancelledAt: calculatedStatus === 'cancelled' ? booking.updatedAt : null,
            booking: {
                id: booking.id,
                userId: booking.userId,
                companyId: booking.companyId,
                referenceNumber: booking.referenceNumber,
                totalPrice: booking.totalPrice,
                bookingStatus: booking.bookingStatus,
                paymentStatus: booking.paymentStatus,
                createdAt: booking.createdAt,
                departureDateTime: booking.departureDateTime,
                passengers: booking.passengers || [],
                deal: deal ? {
                    id: deal.id,
                    date: deal.date,
                    time: deal.time,
                    pricePerSeat: deal.pricePerSeat,
                    company: company ? {
                        id: company.id,
                        name: company.name,
                        logo: company.logo,
                    } : null,
                    route: {
                        origin: deal.originName || booking.originName,
                        destination: deal.destinationName || booking.destinationName,
                        originLatitude: deal.originLatitude || booking.originLatitude,
                        originLongitude: deal.originLongitude || booking.originLongitude,
                        destinationLatitude: deal.destinationLatitude || booking.destinationLatitude,
                        destinationLongitude: deal.destinationLongitude || booking.destinationLongitude,
                    },
                    aircraft: aircraft ? {
                        id: aircraft.id,
                        name: aircraft.name,
                        type: aircraft.type,
                        capacity: aircraft.capacity,
                    } : null,
                } : null,
                directCharter: !deal ? {
                    aircraft: directAircraft ? {
                        id: directAircraft.id,
                        name: directAircraft.name,
                        type: directAircraft.type,
                        capacity: directAircraft.capacity,
                    } : null,
                    company: directCompany ? {
                        id: directCompany.id,
                        name: directCompany.name,
                        logo: directCompany.logo,
                    } : null,
                    route: {
                        origin: booking.originName,
                        destination: booking.destinationName,
                        originLatitude: booking.originLatitude,
                        originLongitude: booking.originLongitude,
                        destinationLatitude: booking.destinationLatitude,
                        destinationLongitude: booking.destinationLongitude,
                    },
                } : null,
            },
        };
    }
    async createUserTrip(bookingId, userId) {
        const userTrip = this.userTripRepository.create({
            id: `trip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            userId,
            bookingId,
            status: user_trips_entity_1.UserTripStatus.UPCOMING,
        });
        return await this.userTripRepository.save(userTrip);
    }
    calculateTripStatus(booking) {
        if (booking.bookingStatus === 'cancelled') {
            return 'cancelled';
        }
        if (booking.bookingStatus === 'pending' || booking.bookingStatus === 'priced') {
            return 'pending';
        }
        if (booking.bookingStatus === 'confirmed') {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const departureDate = new Date(booking.departureDateTime);
            departureDate.setHours(0, 0, 0, 0);
            if (departureDate < today) {
                return 'completed';
            }
            return 'upcoming';
        }
        return 'pending';
    }
    formatTripResponse(userTrip) {
        const booking = userTrip.booking;
        const deal = booking?.deal;
        const company = deal?.company;
        const aircraft = deal?.aircraft;
        return {
            id: userTrip.id,
            userId: userTrip.userId,
            bookingId: userTrip.bookingId,
            status: userTrip.calculatedStatus,
            rating: userTrip.rating,
            review: userTrip.review,
            reviewDate: userTrip.reviewDate,
            photos: userTrip.photos,
            videos: userTrip.videos,
            createdAt: userTrip.createdAt,
            completedAt: userTrip.completedAt,
            cancelledAt: userTrip.cancelledAt,
            booking: booking ? {
                id: booking.id,
                userId: booking.userId,
                companyId: booking.companyId,
                referenceNumber: booking.referenceNumber,
                totalPrice: booking.totalPrice,
                bookingStatus: booking.bookingStatus,
                paymentStatus: booking.paymentStatus,
                createdAt: booking.createdAt,
                passengers: booking.passengers || [],
                deal: deal ? {
                    id: deal.id,
                    date: deal.date,
                    time: deal.time,
                    pricePerSeat: deal.pricePerSeat,
                    company: company ? {
                        id: company.id,
                        name: company.name,
                        logo: company.logo,
                    } : null,
                    route: deal ? {
                        origin: deal.originName,
                        destination: deal.destinationName,
                        originLatitude: deal.originLatitude,
                        originLongitude: deal.originLongitude,
                        destinationLatitude: deal.destinationLatitude,
                        destinationLongitude: deal.destinationLongitude,
                    } : null,
                    aircraft: aircraft ? {
                        id: aircraft.id,
                        name: aircraft.name,
                        type: aircraft.type,
                        capacity: aircraft.capacity,
                    } : null,
                } : null,
            } : null,
        };
    }
};
exports.TripsService = TripsService;
exports.TripsService = TripsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(user_trips_entity_1.UserTrip)),
    __param(1, (0, typeorm_1.InjectRepository)(booking_entity_1.Booking)),
    __param(2, (0, typeorm_1.InjectRepository)(charter_deal_entity_1.CharterDeal)),
    __param(3, (0, typeorm_1.InjectRepository)(charters_company_entity_1.ChartersCompany)),
    __param(4, (0, typeorm_1.InjectRepository)(aircraft_entity_1.Aircraft)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object, typeof (_d = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _d : Object, typeof (_e = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _e : Object, typeof (_f = typeof typeorm_2.DataSource !== "undefined" && typeorm_2.DataSource) === "function" ? _f : Object])
], TripsService);


/***/ }),
/* 129 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var TripSchedulerService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TripSchedulerService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const schedule_1 = __webpack_require__(7);
const user_trips_entity_1 = __webpack_require__(77);
const booking_entity_1 = __webpack_require__(29);
let TripSchedulerService = TripSchedulerService_1 = class TripSchedulerService {
    constructor(userTripRepository, bookingRepository) {
        this.userTripRepository = userTripRepository;
        this.bookingRepository = bookingRepository;
        this.logger = new common_1.Logger(TripSchedulerService_1.name);
    }
    async updateTripStatuses() {
        this.logger.log('Starting daily trip status update...');
        try {
            const trips = await this.userTripRepository
                .createQueryBuilder('userTrip')
                .leftJoinAndSelect('userTrip.booking', 'booking')
                .leftJoinAndSelect('booking.deal', 'deal')
                .where('userTrip.status IN (:...statuses)', {
                statuses: [user_trips_entity_1.UserTripStatus.UPCOMING]
            })
                .getMany();
            let updatedCount = 0;
            const now = new Date();
            for (const trip of trips) {
                try {
                    if (trip.needsStatusUpdate) {
                        const newStatus = trip.calculatedStatus;
                        trip.status = newStatus;
                        if (newStatus === user_trips_entity_1.UserTripStatus.COMPLETED) {
                            trip.completedAt = now;
                        }
                        else if (newStatus === user_trips_entity_1.UserTripStatus.CANCELLED) {
                            trip.cancelledAt = now;
                        }
                        await this.userTripRepository.save(trip);
                        updatedCount++;
                        this.logger.log(`Updated trip ${trip.id} from ${trip.status} to ${newStatus}`);
                    }
                }
                catch (error) {
                    this.logger.error(`Failed to update trip ${trip.id}: ${error.message}`);
                }
            }
            this.logger.log(`Trip status update completed. Updated ${updatedCount} trips.`);
        }
        catch (error) {
            this.logger.error(`Failed to update trip statuses: ${error.message}`);
        }
    }
    async updateCancelledTrips() {
        this.logger.log('Checking for cancelled bookings...');
        try {
            const cancelledTrips = await this.userTripRepository
                .createQueryBuilder('userTrip')
                .leftJoinAndSelect('userTrip.booking', 'booking')
                .where('userTrip.status = :status', { status: user_trips_entity_1.UserTripStatus.UPCOMING })
                .andWhere('booking.bookingStatus = :bookingStatus', {
                bookingStatus: booking_entity_1.BookingStatus.CANCELLED
            })
                .getMany();
            let updatedCount = 0;
            for (const trip of cancelledTrips) {
                try {
                    trip.status = user_trips_entity_1.UserTripStatus.CANCELLED;
                    trip.cancelledAt = new Date();
                    await this.userTripRepository.save(trip);
                    updatedCount++;
                    this.logger.log(`Marked trip ${trip.id} as cancelled due to booking cancellation`);
                }
                catch (error) {
                    this.logger.error(`Failed to cancel trip ${trip.id}: ${error.message}`);
                }
            }
            if (updatedCount > 0) {
                this.logger.log(`Cancelled ${updatedCount} trips due to booking cancellations.`);
            }
        }
        catch (error) {
            this.logger.error(`Failed to update cancelled trips: ${error.message}`);
        }
    }
    async updateTripStatus(tripId) {
        try {
            const trip = await this.userTripRepository
                .createQueryBuilder('userTrip')
                .leftJoinAndSelect('userTrip.booking', 'booking')
                .leftJoinAndSelect('booking.deal', 'deal')
                .where('userTrip.id = :tripId', { tripId })
                .getOne();
            if (!trip) {
                this.logger.warn(`Trip ${tripId} not found`);
                return false;
            }
            if (trip.needsStatusUpdate) {
                const newStatus = trip.calculatedStatus;
                const oldStatus = trip.status;
                trip.status = newStatus;
                if (newStatus === user_trips_entity_1.UserTripStatus.COMPLETED) {
                    trip.completedAt = new Date();
                }
                else if (newStatus === user_trips_entity_1.UserTripStatus.CANCELLED) {
                    trip.cancelledAt = new Date();
                }
                await this.userTripRepository.save(trip);
                this.logger.log(`Manually updated trip ${tripId} from ${oldStatus} to ${newStatus}`);
                return true;
            }
            return false;
        }
        catch (error) {
            this.logger.error(`Failed to manually update trip ${tripId}: ${error.message}`);
            return false;
        }
    }
    async getStatusUpdateStats() {
        const trips = await this.userTripRepository
            .createQueryBuilder('userTrip')
            .leftJoinAndSelect('userTrip.booking', 'booking')
            .leftJoinAndSelect('booking.deal', 'deal')
            .getMany();
        const stats = {
            totalTrips: trips.length,
            needsUpdate: 0,
            upcomingTrips: 0,
            completedTrips: 0,
            cancelledTrips: 0,
        };
        for (const trip of trips) {
            if (trip.needsStatusUpdate) {
                stats.needsUpdate++;
            }
            const calculatedStatus = trip.calculatedStatus;
            switch (calculatedStatus) {
                case user_trips_entity_1.UserTripStatus.UPCOMING:
                    stats.upcomingTrips++;
                    break;
                case user_trips_entity_1.UserTripStatus.COMPLETED:
                    stats.completedTrips++;
                    break;
                case user_trips_entity_1.UserTripStatus.CANCELLED:
                    stats.cancelledTrips++;
                    break;
            }
        }
        return stats;
    }
};
exports.TripSchedulerService = TripSchedulerService;
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_DAY_AT_MIDNIGHT),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], TripSchedulerService.prototype, "updateTripStatuses", null);
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_HOUR),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], TripSchedulerService.prototype, "updateCancelledTrips", null);
exports.TripSchedulerService = TripSchedulerService = TripSchedulerService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(user_trips_entity_1.UserTrip)),
    __param(1, (0, typeorm_1.InjectRepository)(booking_entity_1.Booking)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object])
], TripSchedulerService);


/***/ }),
/* 130 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocationsModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const locations_controller_1 = __webpack_require__(131);
const locations_service_1 = __webpack_require__(132);
const location_entity_1 = __webpack_require__(133);
let LocationsModule = class LocationsModule {
};
exports.LocationsModule = LocationsModule;
exports.LocationsModule = LocationsModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([location_entity_1.Location])],
        controllers: [locations_controller_1.LocationsController],
        providers: [locations_service_1.LocationsService],
        exports: [locations_service_1.LocationsService],
    })
], LocationsModule);


/***/ }),
/* 131 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocationsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const jwt_auth_guard_1 = __webpack_require__(16);
const locations_service_1 = __webpack_require__(132);
const search_locations_dto_1 = __webpack_require__(134);
const location_entity_1 = __webpack_require__(133);
let LocationsController = class LocationsController {
    constructor(locationsService) {
        this.locationsService = locationsService;
    }
    async findAll(searchDto) {
        const locations = await this.locationsService.findAll(searchDto);
        return {
            success: true,
            message: 'Locations retrieved successfully',
            data: locations,
            count: locations.length,
        };
    }
    async searchLocations(query, limit = '10') {
        if (!query || query.trim().length === 0) {
            throw new common_1.BadRequestException('Search query is required');
        }
        const limitNum = parseInt(limit, 10) || 10;
        const locations = await this.locationsService.searchLocations(query, limitNum);
        return {
            success: true,
            message: 'Search results retrieved successfully',
            data: locations,
            count: locations.length,
        };
    }
    async getPopularLocations() {
        const locations = await this.locationsService.getPopularLocations();
        return {
            success: true,
            message: 'Popular locations retrieved successfully',
            data: locations,
            count: locations.length,
        };
    }
    async getLocationsByCountry(country) {
        const locations = await this.locationsService.getLocationsByCountry(country);
        return {
            success: true,
            message: `Locations in ${country} retrieved successfully`,
            data: locations,
            count: locations.length,
        };
    }
    async findById(id) {
        const location = await this.locationsService.findById(parseInt(id, 10));
        if (!location) {
            throw new common_1.BadRequestException('Location not found');
        }
        return {
            success: true,
            message: 'Location retrieved successfully',
            data: location,
        };
    }
    async findByCode(code) {
        const location = await this.locationsService.findByCode(code);
        if (!location) {
            throw new common_1.BadRequestException('Location not found');
        }
        return {
            success: true,
            message: 'Location retrieved successfully',
            data: location,
        };
    }
    async getRouteInfo(origin, destination, aircraftType = 'jet') {
        const routeInfo = await this.locationsService.getRouteInfo(origin, destination, aircraftType);
        if (!routeInfo) {
            throw new common_1.BadRequestException('Route information not available. Coordinates may be missing.');
        }
        return {
            success: true,
            message: 'Route information retrieved successfully',
            data: routeInfo,
        };
    }
};
exports.LocationsController = LocationsController;
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all locations with optional filtering' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Locations retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'number' },
                            name: { type: 'string' },
                            code: { type: 'string' },
                            country: { type: 'string' },
                            type: { type: 'string', enum: ['airport', 'city', 'region'] },
                            latitude: { type: 'number', nullable: true },
                            longitude: { type: 'number', nullable: true },
                            imageUrl: { type: 'string', nullable: true },
                            createdAt: { type: 'string', format: 'date-time' },
                            updatedAt: { type: 'string', format: 'date-time' },
                        },
                    },
                },
                count: { type: 'number' },
            },
        },
    }),
    (0, swagger_1.ApiQuery)({ name: 'q', required: false, type: String, description: 'Search query' }),
    (0, swagger_1.ApiQuery)({ name: 'type', required: false, enum: location_entity_1.LocationType, description: 'Location type filter' }),
    (0, swagger_1.ApiQuery)({ name: 'country', required: false, type: String, description: 'Country filter' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Limit results' }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof search_locations_dto_1.SearchLocationsDto !== "undefined" && search_locations_dto_1.SearchLocationsDto) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], LocationsController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search locations by query' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Search results retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'array',
                    items: { $ref: '#/components/schemas/Location' },
                },
                count: { type: 'number' },
            },
        },
    }),
    (0, swagger_1.ApiQuery)({ name: 'q', required: true, type: String, description: 'Search query' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Limit results (default: 10)' }),
    __param(0, (0, common_1.Query)('q')),
    __param(1, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], LocationsController.prototype, "searchLocations", null);
__decorate([
    (0, common_1.Get)('popular'),
    (0, swagger_1.ApiOperation)({ summary: 'Get popular locations (airports and major cities)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Popular locations retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'array',
                    items: { $ref: '#/components/schemas/Location' },
                },
                count: { type: 'number' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LocationsController.prototype, "getPopularLocations", null);
__decorate([
    (0, common_1.Get)('country/:country'),
    (0, swagger_1.ApiOperation)({ summary: 'Get locations by country' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Locations by country retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'array',
                    items: { $ref: '#/components/schemas/Location' },
                },
                count: { type: 'number' },
            },
        },
    }),
    (0, swagger_1.ApiParam)({ name: 'country', type: String, description: 'Country name' }),
    __param(0, (0, common_1.Param)('country')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], LocationsController.prototype, "getLocationsByCountry", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, swagger_1.ApiOperation)({ summary: 'Get location by ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Location retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: { $ref: '#/components/schemas/Location' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Location not found' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: Number, description: 'Location ID' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], LocationsController.prototype, "findById", null);
__decorate([
    (0, common_1.Get)('code/:code'),
    (0, swagger_1.ApiOperation)({ summary: 'Get location by code' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Location retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: { $ref: '#/components/schemas/Location' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Location not found' }),
    (0, swagger_1.ApiParam)({ name: 'code', type: String, description: 'Location code (e.g., NBO)' }),
    __param(0, (0, common_1.Param)('code')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], LocationsController.prototype, "findByCode", null);
__decorate([
    (0, common_1.Get)('route/:origin/:destination'),
    (0, swagger_1.ApiOperation)({ summary: 'Get route information between two locations' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Route information retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'object',
                    properties: {
                        distance: { type: 'number', description: 'Distance in kilometers' },
                        duration: { type: 'number', description: 'Flight duration in minutes' },
                        origin: { $ref: '#/components/schemas/Location' },
                        destination: { $ref: '#/components/schemas/Location' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Route not found or coordinates missing' }),
    (0, swagger_1.ApiParam)({ name: 'origin', type: String, description: 'Origin location code' }),
    (0, swagger_1.ApiParam)({ name: 'destination', type: String, description: 'Destination location code' }),
    (0, swagger_1.ApiQuery)({ name: 'aircraftType', required: false, enum: ['jet', 'helicopter', 'fixedWing'], description: 'Aircraft type for duration calculation' }),
    __param(0, (0, common_1.Param)('origin')),
    __param(1, (0, common_1.Param)('destination')),
    __param(2, (0, common_1.Query)('aircraftType')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], LocationsController.prototype, "getRouteInfo", null);
exports.LocationsController = LocationsController = __decorate([
    (0, swagger_1.ApiTags)('Locations'),
    (0, common_1.Controller)('locations'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof locations_service_1.LocationsService !== "undefined" && locations_service_1.LocationsService) === "function" ? _a : Object])
], LocationsController);


/***/ }),
/* 132 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocationsService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const location_entity_1 = __webpack_require__(133);
let LocationsService = class LocationsService {
    constructor(locationRepository) {
        this.locationRepository = locationRepository;
    }
    async findAll(searchDto) {
        const query = this.locationRepository.createQueryBuilder('location');
        if (searchDto?.q) {
            query.andWhere('(location.name LIKE :search OR location.code LIKE :search OR location.country LIKE :search)', { search: `%${searchDto.q}%` });
        }
        if (searchDto?.type) {
            query.andWhere('location.type = :type', { type: searchDto.type });
        }
        if (searchDto?.country) {
            query.andWhere('location.country LIKE :country', { country: `%${searchDto.country}%` });
        }
        const limit = searchDto?.limit || 20;
        return query.limit(limit).getMany();
    }
    async searchLocations(query, limit = 10) {
        return this.locationRepository.find({
            where: [
                { name: (0, typeorm_2.Like)(`%${query}%`) },
                { code: (0, typeorm_2.Like)(`%${query}%`) },
                { country: (0, typeorm_2.Like)(`%${query}%`) },
            ],
            take: limit,
            order: {
                name: 'ASC',
            },
        });
    }
    async findById(id) {
        return this.locationRepository.findOne({ where: { id } });
    }
    async findByCode(code) {
        return this.locationRepository.findOne({ where: { code } });
    }
    async getPopularLocations() {
        return this.locationRepository.find({
            where: [
                { type: location_entity_1.LocationType.AIRPORT },
                { type: location_entity_1.LocationType.CITY },
            ],
            order: {
                name: 'ASC',
            },
        });
    }
    async getLocationsByCountry(country) {
        return this.locationRepository.find({
            where: { country: (0, typeorm_2.Like)(`%${country}%`) },
            order: {
                name: 'ASC',
            },
        });
    }
    calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = this.toRadians(lat2 - lat1);
        const dLon = this.toRadians(lon2 - lon1);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(this.toRadians(lat1)) *
                Math.cos(this.toRadians(lat2)) *
                Math.sin(dLon / 2) *
                Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }
    calculateFlightDuration(distance, aircraftType = 'jet') {
        const speeds = {
            jet: 800,
            helicopter: 300,
            fixedWing: 500,
        };
        const speed = speeds[aircraftType];
        return Math.ceil(distance / speed * 60);
    }
    async getRouteInfo(originCode, destinationCode, aircraftType = 'jet') {
        const origin = await this.findByCode(originCode);
        const destination = await this.findByCode(destinationCode);
        if (!origin || !destination || !origin.latitude || !destination.latitude) {
            return null;
        }
        const distance = this.calculateDistance(origin.latitude, origin.longitude, destination.latitude, destination.longitude);
        const duration = this.calculateFlightDuration(distance, aircraftType);
        return {
            distance: Math.round(distance),
            duration,
            origin,
            destination,
        };
    }
    toRadians(degrees) {
        return degrees * (Math.PI / 180);
    }
};
exports.LocationsService = LocationsService;
exports.LocationsService = LocationsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(location_entity_1.Location)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], LocationsService);


/***/ }),
/* 133 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Location = exports.LocationType = void 0;
const typeorm_1 = __webpack_require__(13);
var LocationType;
(function (LocationType) {
    LocationType["AIRPORT"] = "airport";
    LocationType["CITY"] = "city";
    LocationType["REGION"] = "region";
})(LocationType || (exports.LocationType = LocationType = {}));
let Location = class Location {
};
exports.Location = Location;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], Location.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], Location.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 10, unique: true }),
    __metadata("design:type", String)
], Location.prototype, "code", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100 }),
    __metadata("design:type", String)
], Location.prototype, "country", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: LocationType,
        default: LocationType.CITY,
    }),
    __metadata("design:type", String)
], Location.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'decimal', precision: 10, scale: 8, nullable: true }),
    __metadata("design:type", Number)
], Location.prototype, "latitude", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'decimal', precision: 11, scale: 8, nullable: true }),
    __metadata("design:type", Number)
], Location.prototype, "longitude", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)(),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Location.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)(),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Location.prototype, "updatedAt", void 0);
exports.Location = Location = __decorate([
    (0, typeorm_1.Entity)('locations')
], Location);


/***/ }),
/* 134 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchLocationsDto = void 0;
const class_validator_1 = __webpack_require__(19);
const swagger_1 = __webpack_require__(3);
const location_entity_1 = __webpack_require__(133);
class SearchLocationsDto {
    constructor() {
        this.limit = 20;
    }
}
exports.SearchLocationsDto = SearchLocationsDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Search query for location name, code, or country',
        required: false,
        example: 'Nairobi',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MinLength)(1),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], SearchLocationsDto.prototype, "q", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Filter by location type',
        enum: location_entity_1.LocationType,
        required: false,
        example: location_entity_1.LocationType.AIRPORT,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(location_entity_1.LocationType),
    __metadata("design:type", typeof (_a = typeof location_entity_1.LocationType !== "undefined" && location_entity_1.LocationType) === "function" ? _a : Object)
], SearchLocationsDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Filter by country',
        required: false,
        example: 'Kenya',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MinLength)(1),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], SearchLocationsDto.prototype, "country", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Limit number of results',
        required: false,
        example: 20,
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], SearchLocationsDto.prototype, "limit", void 0);


/***/ }),
/* 135 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AircraftAvailabilityModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const aircraft_availability_controller_1 = __webpack_require__(136);
const aircraft_availability_service_1 = __webpack_require__(137);
const aircraft_entity_1 = __webpack_require__(35);
const location_entity_1 = __webpack_require__(133);
const charters_company_entity_1 = __webpack_require__(31);
const charter_deal_entity_1 = __webpack_require__(30);
const booking_entity_1 = __webpack_require__(29);
const aircraft_image_entity_1 = __webpack_require__(36);
const aircraft_calendar_entity_1 = __webpack_require__(138);
let AircraftAvailabilityModule = class AircraftAvailabilityModule {
};
exports.AircraftAvailabilityModule = AircraftAvailabilityModule;
exports.AircraftAvailabilityModule = AircraftAvailabilityModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([
                aircraft_entity_1.Aircraft,
                location_entity_1.Location,
                charters_company_entity_1.ChartersCompany,
                charter_deal_entity_1.CharterDeal,
                booking_entity_1.Booking,
                aircraft_image_entity_1.AircraftImage,
                aircraft_calendar_entity_1.AircraftCalendar,
            ]),
        ],
        controllers: [aircraft_availability_controller_1.AircraftAvailabilityController],
        providers: [aircraft_availability_service_1.AircraftAvailabilityService],
        exports: [aircraft_availability_service_1.AircraftAvailabilityService],
    })
], AircraftAvailabilityModule);


/***/ }),
/* 136 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AircraftAvailabilityController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const jwt_auth_guard_1 = __webpack_require__(16);
const aircraft_availability_service_1 = __webpack_require__(137);
const aircraft_availability_dto_1 = __webpack_require__(140);
const aircraft_calendar_entity_1 = __webpack_require__(138);
let AircraftAvailabilityController = class AircraftAvailabilityController {
    constructor(aircraftAvailabilityService) {
        this.aircraftAvailabilityService = aircraftAvailabilityService;
    }
    async searchAvailableAircraft(searchDto) {
        return this.aircraftAvailabilityService.searchAvailableAircraft(searchDto);
    }
    async getAircraftAvailability(aircraftId, startDate, endDate) {
        const start = new Date(startDate);
        const end = new Date(endDate);
        return this.aircraftAvailabilityService.getAircraftAvailability(aircraftId, start, end);
    }
    async createCalendarEvent(aircraftId, eventData) {
        const startTime = new Date(eventData.startTime);
        const endTime = new Date(eventData.endTime);
        return this.aircraftAvailabilityService.createCalendarEvent(aircraftId, eventData.eventType, startTime, endTime, eventData.description);
    }
};
exports.AircraftAvailabilityController = AircraftAvailabilityController;
__decorate([
    (0, common_1.Post)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search for available aircraft' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Available aircraft found',
        type: [aircraft_availability_dto_1.AvailableAircraftDto],
    }),
    (0, swagger_1.ApiBody)({ type: aircraft_availability_dto_1.AircraftAvailabilitySearchDto }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof aircraft_availability_dto_1.AircraftAvailabilitySearchDto !== "undefined" && aircraft_availability_dto_1.AircraftAvailabilitySearchDto) === "function" ? _b : Object]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], AircraftAvailabilityController.prototype, "searchAvailableAircraft", null);
__decorate([
    (0, common_1.Get)(':aircraftId/availability'),
    (0, swagger_1.ApiOperation)({ summary: 'Get aircraft availability for a date range' }),
    (0, swagger_1.ApiParam)({ name: 'aircraftId', description: 'Aircraft ID' }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', description: 'Start date (YYYY-MM-DD)' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', description: 'End date (YYYY-MM-DD)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Aircraft availability data',
    }),
    __param(0, (0, common_1.Param)('aircraftId')),
    __param(1, (0, common_1.Query)('startDate')),
    __param(2, (0, common_1.Query)('endDate')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, String, String]),
    __metadata("design:returntype", Promise)
], AircraftAvailabilityController.prototype, "getAircraftAvailability", null);
__decorate([
    (0, common_1.Post)(':aircraftId/calendar-event'),
    (0, swagger_1.ApiOperation)({ summary: 'Create calendar event for aircraft' }),
    (0, swagger_1.ApiParam)({ name: 'aircraftId', description: 'Aircraft ID' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                eventType: { type: 'string', enum: Object.values(aircraft_calendar_entity_1.CalendarEventType) },
                startTime: { type: 'string', format: 'date-time' },
                endTime: { type: 'string', format: 'date-time' },
                description: { type: 'string' },
            },
            required: ['eventType', 'startTime', 'endTime'],
        },
    }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Calendar event created successfully',
    }),
    __param(0, (0, common_1.Param)('aircraftId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Object]),
    __metadata("design:returntype", Promise)
], AircraftAvailabilityController.prototype, "createCalendarEvent", null);
exports.AircraftAvailabilityController = AircraftAvailabilityController = __decorate([
    (0, swagger_1.ApiTags)('Aircraft Availability'),
    (0, common_1.Controller)('aircraft-availability'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof aircraft_availability_service_1.AircraftAvailabilityService !== "undefined" && aircraft_availability_service_1.AircraftAvailabilityService) === "function" ? _a : Object])
], AircraftAvailabilityController);


/***/ }),
/* 137 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AircraftAvailabilityService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const aircraft_entity_1 = __webpack_require__(35);
const location_entity_1 = __webpack_require__(133);
const charters_company_entity_1 = __webpack_require__(31);
const charter_deal_entity_1 = __webpack_require__(30);
const booking_entity_1 = __webpack_require__(29);
const aircraft_image_entity_1 = __webpack_require__(36);
const aircraft_calendar_entity_1 = __webpack_require__(138);
let AircraftAvailabilityService = class AircraftAvailabilityService {
    constructor(aircraftRepository, locationRepository, companyRepository, charterDealRepository, bookingRepository, aircraftImageRepository, aircraftCalendarRepository) {
        this.aircraftRepository = aircraftRepository;
        this.locationRepository = locationRepository;
        this.companyRepository = companyRepository;
        this.charterDealRepository = charterDealRepository;
        this.bookingRepository = bookingRepository;
        this.aircraftImageRepository = aircraftImageRepository;
        this.aircraftCalendarRepository = aircraftCalendarRepository;
    }
    async searchAvailableAircraft(searchDto) {
        try {
            const { departureLocationId, arrivalLocationId, departureDate, returnDate, passengerCount, isRoundTrip } = searchDto;
            const departureDateObj = new Date(departureDate);
            const returnDateObj = returnDate ? new Date(returnDate) : undefined;
            const departureLocation = await this.locationRepository.findOne({ where: { id: departureLocationId } });
            const arrivalLocation = await this.locationRepository.findOne({ where: { id: arrivalLocationId } });
            if (!departureLocation || !arrivalLocation) {
                throw new common_1.BadRequestException('Invalid departure or arrival location');
            }
            const aircraft = await this.aircraftRepository
                .createQueryBuilder('aircraft')
                .leftJoinAndSelect('aircraft.company', 'company')
                .where('aircraft.capacity >= :passengerCount', { passengerCount })
                .andWhere('aircraft.isAvailable = :isAvailable', { isAvailable: true })
                .andWhere('aircraft.maintenanceStatus = :maintenanceStatus', { maintenanceStatus: 'operational' })
                .getMany();
            const availableAircraft = [];
            for (const aircraftItem of aircraft) {
                try {
                    const isAvailable = await this.isAircraftAvailableForDate(aircraftItem.id, departureDateObj, passengerCount);
                    if (!isAvailable)
                        continue;
                    if (isRoundTrip && returnDateObj) {
                        const isAvailableReturn = await this.isAircraftAvailableForDate(aircraftItem.id, returnDateObj, passengerCount);
                        if (!isAvailableReturn)
                            continue;
                    }
                    const flightDetails = await this.calculateFlightDetails(aircraftItem, departureLocation, arrivalLocation, departureDateObj);
                    if (flightDetails) {
                        const aircraftDto = {
                            aircraftId: aircraftItem.id || 0,
                            aircraftName: aircraftItem.name || 'Unknown Aircraft',
                            aircraftType: aircraftItem.type || 'fixedWing',
                            capacity: aircraftItem.capacity || 0,
                            companyId: aircraftItem.companyId || 0,
                            companyName: aircraftItem.company?.companyName || 'Unknown Company',
                            basePrice: flightDetails.basePrice || 0,
                            repositioningCost: flightDetails.repositioningCost || 0,
                            totalPrice: flightDetails.totalPrice || 0,
                            availableSeats: (aircraftItem.capacity || 0) - passengerCount,
                            departureTime: flightDetails.departureTime || '09:00:00',
                            arrivalTime: flightDetails.arrivalTime || '10:00:00',
                            flightDuration: flightDetails.duration || 60,
                            distance: flightDetails.distance || 0,
                            amenities: flightDetails.amenities || ['Comfortable Seating'],
                            images: flightDetails.images || ['https://via.placeholder.com/400x300/4A90E2/FFFFFF?text=Aircraft'],
                        };
                        availableAircraft.push(aircraftDto);
                    }
                }
                catch (error) {
                    console.error(`Error processing aircraft ${aircraftItem.id}:`, error);
                    continue;
                }
            }
            return availableAircraft.sort((a, b) => a.totalPrice - b.totalPrice);
        }
        catch (error) {
            console.error('Error in searchAvailableAircraft:', error);
            throw error;
        }
    }
    async isAircraftAvailableForDate(aircraftId, date, passengerCount) {
        const aircraft = await this.aircraftRepository.findOne({
            where: {
                id: aircraftId,
                isAvailable: true,
                maintenanceStatus: 'operational'
            }
        });
        if (!aircraft)
            return false;
        if (aircraft.capacity < passengerCount)
            return false;
        const conflicts = await this.aircraftCalendarRepository.find({
            where: {
                aircraftId,
                eventType: (0, typeorm_2.In)([aircraft_calendar_entity_1.CalendarEventType.BOOKED, aircraft_calendar_entity_1.CalendarEventType.MAINTENANCE, aircraft_calendar_entity_1.CalendarEventType.BLOCKED]),
                startDateTime: (0, typeorm_2.Between)(new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0), new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59)),
            },
        });
        return conflicts.length === 0;
    }
    async getAircraftAvailability(aircraftId, startDate, endDate) {
        const aircraft = await this.aircraftRepository.findOne({
            where: { id: aircraftId },
            relations: ['company'],
        });
        if (!aircraft) {
            throw new common_1.NotFoundException('Aircraft not found');
        }
        const events = await this.aircraftCalendarRepository.find({
            where: {
                aircraftId,
                startDateTime: (0, typeorm_2.Between)(startDate, endDate),
            },
            order: { startDateTime: 'ASC' },
        });
        const availabilityByDate = {};
        const currentDate = new Date(startDate);
        while (currentDate <= endDate) {
            const dateKey = currentDate.toISOString().split('T')[0];
            const dayEvents = events.filter(event => event.startDateTime.toISOString().split('T')[0] === dateKey);
            availabilityByDate[dateKey] = {
                date: new Date(currentDate),
                isAvailable: dayEvents.length === 0,
                events: dayEvents,
                status: dayEvents.length === 0 ? 'available' : 'unavailable',
            };
            currentDate.setDate(currentDate.getDate() + 1);
        }
        return {
            success: true,
            data: {
                aircraft,
                availability: availabilityByDate,
                summary: {
                    totalDays: Object.keys(availabilityByDate).length,
                    availableDays: Object.values(availabilityByDate).filter((day) => day.isAvailable).length,
                    unavailableDays: Object.values(availabilityByDate).filter((day) => !day.isAvailable).length,
                },
            },
        };
    }
    async createCalendarEvent(aircraftId, eventType, startTime, endTime, description) {
        const aircraft = await this.aircraftRepository.findOne({
            where: { id: aircraftId },
        });
        if (!aircraft) {
            throw new common_1.NotFoundException('Aircraft not found');
        }
        const conflicts = await this.aircraftCalendarRepository.find({
            where: {
                aircraftId,
                startDateTime: (0, typeorm_2.Between)(startTime, endTime),
                eventType: (0, typeorm_2.In)([aircraft_calendar_entity_1.CalendarEventType.BOOKED, aircraft_calendar_entity_1.CalendarEventType.MAINTENANCE, aircraft_calendar_entity_1.CalendarEventType.BLOCKED]),
            },
        });
        if (conflicts.length > 0) {
            throw new common_1.BadRequestException('Aircraft is not available for the specified time period');
        }
        const calendarEvent = this.aircraftCalendarRepository.create({
            aircraftId,
            eventType,
            startDateTime: startTime,
            endDateTime: endTime,
        });
        return await this.aircraftCalendarRepository.save(calendarEvent);
    }
    async calculateFlightDetails(aircraft, departureLocation, arrivalLocation, departureDate) {
        try {
            const distance = this.calculateDistance(departureLocation, arrivalLocation);
            const durationHours = distance / 800;
            const durationMinutes = Math.round(durationHours * 60);
            const pricePerHour = aircraft.pricePerHour || this.getDefaultPricePerHour(aircraft.type);
            const basePrice = durationHours * pricePerHour;
            const repositioningCost = await this.calculateRepositioningCost(aircraft.id, departureLocation.id, arrivalLocation.id, departureDate);
            const totalPrice = basePrice + (repositioningCost || 0);
            const departureTime = '09:00:00';
            const arrivalTime = this.addMinutesToTime(departureTime, durationMinutes);
            const amenities = this.getAircraftAmenities(aircraft.type);
            const images = await this.getAircraftImages(aircraft.id);
            return {
                basePrice,
                repositioningCost,
                totalPrice,
                departureTime,
                arrivalTime,
                duration: durationMinutes,
                distance,
                amenities,
                images,
            };
        }
        catch (error) {
            console.error('Error calculating flight details:', error);
            return {
                basePrice: 1000,
                repositioningCost: 0,
                totalPrice: 1000,
                departureTime: '09:00:00',
                arrivalTime: '10:00:00',
                duration: 60,
                distance: 800,
                amenities: ['Comfortable Seating'],
                images: ['https://via.placeholder.com/400x300/4A90E2/FFFFFF?text=Aircraft'],
            };
        }
    }
    calculateDistance(origin, destination) {
        if (!origin.latitude || !origin.longitude || !destination.latitude || !destination.longitude) {
            return 0;
        }
        const R = 6371;
        const lat1 = origin.latitude * (Math.PI / 180);
        const lat2 = destination.latitude * (Math.PI / 180);
        const deltaLat = (destination.latitude - origin.latitude) * (Math.PI / 180);
        const deltaLon = (destination.longitude - origin.longitude) * (Math.PI / 180);
        const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
            Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }
    getDefaultPricePerHour(aircraftType) {
        const pricing = {
            'helicopter': 1500,
            'fixedWing': 800,
            'jet': 2500,
            'glider': 500,
            'seaplane': 1200,
            'ultralight': 300,
            'balloon': 2000,
            'tiltrotor': 3000,
            'gyroplane': 1000,
            'airship': 3500,
        };
        return pricing[aircraftType] || 1000;
    }
    async calculateRepositioningCost(aircraftId, departureLocationId, arrivalLocationId, departureDate) {
        try {
            const departureLocation = await this.locationRepository.findOne({
                where: { id: departureLocationId }
            });
            const arrivalLocation = await this.locationRepository.findOne({
                where: { id: arrivalLocationId }
            });
            if (departureLocation && arrivalLocation) {
                const distance = this.calculateDistance(departureLocation, arrivalLocation);
                const aircraft = await this.aircraftRepository.findOne({
                    where: { id: aircraftId }
                });
                if (aircraft) {
                    const pricePerHour = aircraft.pricePerHour || this.getDefaultPricePerHour(aircraft.type);
                    const repositioningHours = distance / 800;
                    const repositioningCost = repositioningHours * pricePerHour * 0.3;
                    const basePrice = repositioningHours * pricePerHour;
                    return Math.min(repositioningCost, basePrice * 0.2);
                }
            }
            return 0;
        }
        catch (error) {
            console.error('Error calculating repositioning cost:', error);
            return 0;
        }
    }
    addMinutesToTime(time, minutes) {
        const [hours, mins, secs] = time.split(':').map(Number);
        const totalMinutes = hours * 60 + mins + minutes;
        const newHours = Math.floor(totalMinutes / 60) % 24;
        const newMins = totalMinutes % 60;
        return `${newHours.toString().padStart(2, '0')}:${newMins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    getAircraftAmenities(aircraftType) {
        const amenities = {
            'helicopter': ['Air Conditioning', 'Comfortable Seating', 'Large Windows'],
            'fixedWing': ['Air Conditioning', 'Comfortable Seating', 'Refreshments'],
            'jet': ['Luxury Seating', 'WiFi', 'Refreshments', 'Entertainment', 'Air Conditioning'],
            'glider': ['Comfortable Seating', 'Large Windows'],
            'seaplane': ['Air Conditioning', 'Comfortable Seating', 'Refreshments'],
            'ultralight': ['Comfortable Seating', 'Large Windows'],
            'balloon': ['Comfortable Seating', 'Large Windows', 'Refreshments'],
            'tiltrotor': ['Luxury Seating', 'WiFi', 'Refreshments', 'Entertainment', 'Air Conditioning'],
            'gyroplane': ['Comfortable Seating', 'Large Windows'],
            'airship': ['Luxury Seating', 'WiFi', 'Refreshments', 'Entertainment', 'Air Conditioning'],
        };
        return amenities[aircraftType] || ['Comfortable Seating'];
    }
    async getAircraftImages(aircraftId) {
        try {
            const images = await this.aircraftImageRepository.find({
                where: { aircraftId },
                order: { id: 'ASC' },
                take: 5,
            });
            const imageUrls = images.map(img => img.url).filter(url => url != null);
            if (imageUrls.length === 0) {
                return [
                    'https://via.placeholder.com/400x300/4A90E2/FFFFFF?text=Aircraft',
                    'https://via.placeholder.com/400x300/4A90E2/FFFFFF?text=Interior',
                ];
            }
            return imageUrls;
        }
        catch (error) {
            console.error('Error fetching aircraft images:', error);
            return [
                'https://via.placeholder.com/400x300/4A90E2/FFFFFF?text=Aircraft',
                'https://via.placeholder.com/400x300/4A90E2/FFFFFF?text=Interior',
            ];
        }
    }
};
exports.AircraftAvailabilityService = AircraftAvailabilityService;
exports.AircraftAvailabilityService = AircraftAvailabilityService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(aircraft_entity_1.Aircraft)),
    __param(1, (0, typeorm_1.InjectRepository)(location_entity_1.Location)),
    __param(2, (0, typeorm_1.InjectRepository)(charters_company_entity_1.ChartersCompany)),
    __param(3, (0, typeorm_1.InjectRepository)(charter_deal_entity_1.CharterDeal)),
    __param(4, (0, typeorm_1.InjectRepository)(booking_entity_1.Booking)),
    __param(5, (0, typeorm_1.InjectRepository)(aircraft_image_entity_1.AircraftImage)),
    __param(6, (0, typeorm_1.InjectRepository)(aircraft_calendar_entity_1.AircraftCalendar)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object, typeof (_d = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _d : Object, typeof (_e = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _e : Object, typeof (_f = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _f : Object, typeof (_g = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _g : Object])
], AircraftAvailabilityService);


/***/ }),
/* 138 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AircraftCalendar = exports.CalendarEventType = void 0;
const typeorm_1 = __webpack_require__(13);
const aircraft_entity_1 = __webpack_require__(35);
const company_entity_1 = __webpack_require__(139);
const booking_entity_1 = __webpack_require__(29);
var CalendarEventType;
(function (CalendarEventType) {
    CalendarEventType["AVAILABLE"] = "available";
    CalendarEventType["BOOKED"] = "booked";
    CalendarEventType["MAINTENANCE"] = "maintenance";
    CalendarEventType["BLOCKED"] = "blocked";
})(CalendarEventType || (exports.CalendarEventType = CalendarEventType = {}));
let AircraftCalendar = class AircraftCalendar {
};
exports.AircraftCalendar = AircraftCalendar;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], AircraftCalendar.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'aircraftId' }),
    __metadata("design:type", Number)
], AircraftCalendar.prototype, "aircraftId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'companyId' }),
    __metadata("design:type", Number)
], AircraftCalendar.prototype, "companyId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'startDateTime', type: 'datetime' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], AircraftCalendar.prototype, "startDateTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'endDateTime', type: 'datetime' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], AircraftCalendar.prototype, "endDateTime", void 0);
__decorate([
    (0, typeorm_1.Column)({
        name: 'eventType',
        type: 'enum',
        enum: CalendarEventType,
        default: CalendarEventType.AVAILABLE
    }),
    __metadata("design:type", String)
], AircraftCalendar.prototype, "eventType", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'bookingId', nullable: true }),
    __metadata("design:type", String)
], AircraftCalendar.prototype, "bookingId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'originAirport', nullable: true, length: 100 }),
    __metadata("design:type", String)
], AircraftCalendar.prototype, "originAirport", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'destinationAirport', nullable: true, length: 100 }),
    __metadata("design:type", String)
], AircraftCalendar.prototype, "destinationAirport", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'passengerCount', nullable: true }),
    __metadata("design:type", Number)
], AircraftCalendar.prototype, "passengerCount", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'totalPrice', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], AircraftCalendar.prototype, "totalPrice", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'pricePerHour', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], AircraftCalendar.prototype, "pricePerHour", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'repositioningCost', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], AircraftCalendar.prototype, "repositioningCost", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], AircraftCalendar.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], AircraftCalendar.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => aircraft_entity_1.Aircraft, aircraft => aircraft.id),
    (0, typeorm_1.JoinColumn)({ name: 'aircraftId' }),
    __metadata("design:type", typeof (_e = typeof aircraft_entity_1.Aircraft !== "undefined" && aircraft_entity_1.Aircraft) === "function" ? _e : Object)
], AircraftCalendar.prototype, "aircraft", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => company_entity_1.Company, company => company.id),
    (0, typeorm_1.JoinColumn)({ name: 'companyId' }),
    __metadata("design:type", typeof (_f = typeof company_entity_1.Company !== "undefined" && company_entity_1.Company) === "function" ? _f : Object)
], AircraftCalendar.prototype, "company", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => booking_entity_1.Booking, booking => booking.id),
    (0, typeorm_1.JoinColumn)({ name: 'bookingId' }),
    __metadata("design:type", typeof (_g = typeof booking_entity_1.Booking !== "undefined" && booking_entity_1.Booking) === "function" ? _g : Object)
], AircraftCalendar.prototype, "booking", void 0);
exports.AircraftCalendar = AircraftCalendar = __decorate([
    (0, typeorm_1.Entity)('aircraft_calendar')
], AircraftCalendar);


/***/ }),
/* 139 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Company = exports.CompanyStatus = void 0;
const typeorm_1 = __webpack_require__(13);
var CompanyStatus;
(function (CompanyStatus) {
    CompanyStatus["ACTIVE"] = "active";
    CompanyStatus["INACTIVE"] = "inactive";
})(CompanyStatus || (exports.CompanyStatus = CompanyStatus = {}));
let Company = class Company {
};
exports.Company = Company;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], Company.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255, unique: true }),
    __metadata("design:type", String)
], Company.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255, unique: true }),
    __metadata("design:type", String)
], Company.prototype, "email", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 20, nullable: true, unique: true }),
    __metadata("design:type", String)
], Company.prototype, "phone", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], Company.prototype, "address", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], Company.prototype, "country", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: CompanyStatus,
        default: CompanyStatus.ACTIVE
    }),
    __metadata("design:type", String)
], Company.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Company.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Company.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.OneToMany)('Booking', 'company'),
    __metadata("design:type", Array)
], Company.prototype, "bookings", void 0);
exports.Company = Company = __decorate([
    (0, typeorm_1.Entity)('companies')
], Company);


/***/ }),
/* 140 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AvailableAircraftDto = exports.AircraftAvailabilitySearchDto = void 0;
const swagger_1 = __webpack_require__(3);
const class_validator_1 = __webpack_require__(19);
class AircraftAvailabilitySearchDto {
}
exports.AircraftAvailabilitySearchDto = AircraftAvailabilitySearchDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Departure location ID' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsPositive)(),
    __metadata("design:type", Number)
], AircraftAvailabilitySearchDto.prototype, "departureLocationId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Arrival location ID' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsPositive)(),
    __metadata("design:type", Number)
], AircraftAvailabilitySearchDto.prototype, "arrivalLocationId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Departure date' }),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], AircraftAvailabilitySearchDto.prototype, "departureDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Return date (optional for round trips)', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], AircraftAvailabilitySearchDto.prototype, "returnDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of passengers' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    __metadata("design:type", Number)
], AircraftAvailabilitySearchDto.prototype, "passengerCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Is round trip', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AircraftAvailabilitySearchDto.prototype, "isRoundTrip", void 0);
class AvailableAircraftDto {
}
exports.AvailableAircraftDto = AvailableAircraftDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Aircraft ID' }),
    __metadata("design:type", Number)
], AvailableAircraftDto.prototype, "aircraftId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Aircraft name' }),
    __metadata("design:type", String)
], AvailableAircraftDto.prototype, "aircraftName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Aircraft type' }),
    __metadata("design:type", String)
], AvailableAircraftDto.prototype, "aircraftType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Aircraft capacity' }),
    __metadata("design:type", Number)
], AvailableAircraftDto.prototype, "capacity", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Company ID' }),
    __metadata("design:type", Number)
], AvailableAircraftDto.prototype, "companyId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Company name' }),
    __metadata("design:type", String)
], AvailableAircraftDto.prototype, "companyName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Base price' }),
    __metadata("design:type", Number)
], AvailableAircraftDto.prototype, "basePrice", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Repositioning cost', required: false }),
    __metadata("design:type", Number)
], AvailableAircraftDto.prototype, "repositioningCost", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total price' }),
    __metadata("design:type", Number)
], AvailableAircraftDto.prototype, "totalPrice", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Available seats' }),
    __metadata("design:type", Number)
], AvailableAircraftDto.prototype, "availableSeats", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Departure time' }),
    __metadata("design:type", String)
], AvailableAircraftDto.prototype, "departureTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Arrival time' }),
    __metadata("design:type", String)
], AvailableAircraftDto.prototype, "arrivalTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Flight duration in minutes' }),
    __metadata("design:type", Number)
], AvailableAircraftDto.prototype, "flightDuration", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Distance in km' }),
    __metadata("design:type", Number)
], AvailableAircraftDto.prototype, "distance", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Amenities', type: [String] }),
    __metadata("design:type", Array)
], AvailableAircraftDto.prototype, "amenities", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Aircraft images', type: [String] }),
    __metadata("design:type", Array)
], AvailableAircraftDto.prototype, "images", void 0);


/***/ }),
/* 141 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirectCharterModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const direct_charter_controller_1 = __webpack_require__(142);
const direct_charter_service_1 = __webpack_require__(143);
const aircraft_entity_1 = __webpack_require__(35);
const aircraft_calendar_entity_1 = __webpack_require__(138);
const booking_entity_1 = __webpack_require__(29);
const charters_company_entity_1 = __webpack_require__(31);
const passenger_entity_1 = __webpack_require__(41);
const payment_entity_1 = __webpack_require__(76);
const aircraft_type_image_placeholder_entity_1 = __webpack_require__(40);
const payments_module_1 = __webpack_require__(99);
const google_earth_engine_module_1 = __webpack_require__(63);
let DirectCharterModule = class DirectCharterModule {
};
exports.DirectCharterModule = DirectCharterModule;
exports.DirectCharterModule = DirectCharterModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([
                aircraft_entity_1.Aircraft,
                aircraft_calendar_entity_1.AircraftCalendar,
                booking_entity_1.Booking,
                charters_company_entity_1.ChartersCompany,
                passenger_entity_1.Passenger,
                payment_entity_1.Payment,
                aircraft_type_image_placeholder_entity_1.AircraftTypeImagePlaceholder,
            ]),
            payments_module_1.PaymentsModule,
            google_earth_engine_module_1.GoogleEarthEngineModule,
        ],
        controllers: [direct_charter_controller_1.DirectCharterController],
        providers: [direct_charter_service_1.DirectCharterService],
        exports: [direct_charter_service_1.DirectCharterService],
    })
], DirectCharterModule);


/***/ }),
/* 142 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirectCharterController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const jwt_auth_guard_1 = __webpack_require__(16);
const direct_charter_service_1 = __webpack_require__(143);
const search_direct_charter_dto_1 = __webpack_require__(144);
const book_direct_charter_dto_1 = __webpack_require__(145);
let DirectCharterController = class DirectCharterController {
    constructor(directCharterService) {
        this.directCharterService = directCharterService;
    }
    async searchAvailableAircraft(searchDto) {
        try {
            const results = await this.directCharterService.searchAvailableAircraft(searchDto);
            return {
                success: true,
                data: results,
                message: `Found ${results.length} available aircraft`,
            };
        }
        catch (error) {
            return {
                success: false,
                message: error.message || 'Failed to search for available aircraft',
                data: [],
            };
        }
    }
    async bookDirectCharter(bookDto, req) {
        try {
            const userId = req.user.id;
            const result = await this.directCharterService.bookDirectCharter(bookDto, userId);
            return {
                success: true,
                data: result,
                message: 'Direct charter booking confirmed successfully',
            };
        }
        catch (error) {
            return {
                success: false,
                message: error.message || 'Failed to book direct charter',
                data: null,
            };
        }
    }
    async getAircraftTypes() {
        try {
            const aircraftTypes = await this.directCharterService.getAircraftTypes();
            return {
                success: true,
                data: aircraftTypes,
                message: `Found ${aircraftTypes.length} aircraft types`,
            };
        }
        catch (error) {
            return {
                success: false,
                message: error.message || 'Failed to fetch aircraft types',
                data: [],
            };
        }
    }
    async getAircraftByType(typeId, userLocation) {
        try {
            const aircraft = await this.directCharterService.getAircraftByType(typeId, userLocation);
            return {
                success: true,
                data: aircraft,
                message: `Found ${aircraft.length} available aircraft`,
            };
        }
        catch (error) {
            return {
                success: false,
                message: error.message || 'Failed to fetch aircraft',
                data: [],
            };
        }
    }
    async healthCheck() {
        return {
            success: true,
            message: 'Direct charter service is running',
            timestamp: new Date().toISOString(),
        };
    }
    async getBookedDates(aircraftId, startDate, endDate) {
        try {
            const bookedDates = await this.directCharterService.getBookedDates(parseInt(aircraftId), startDate ? new Date(startDate) : undefined, endDate ? new Date(endDate) : undefined);
            return {
                success: true,
                data: bookedDates.map(date => date.toISOString()),
                message: `Found ${bookedDates.length} booked dates`,
            };
        }
        catch (error) {
            return {
                success: false,
                message: error.message || 'Failed to fetch booked dates',
                data: [],
            };
        }
    }
};
exports.DirectCharterController = DirectCharterController;
__decorate([
    (0, common_1.Post)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search for available aircraft for direct charter' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Returns available aircraft sorted by priority and price'
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid search parameters' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof search_direct_charter_dto_1.SearchDirectCharterDto !== "undefined" && search_direct_charter_dto_1.SearchDirectCharterDto) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], DirectCharterController.prototype, "searchAvailableAircraft", null);
__decorate([
    (0, common_1.Post)('book'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Book a direct charter flight' }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Booking confirmed successfully'
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Aircraft not available or invalid booking data' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof book_direct_charter_dto_1.BookDirectCharterDto !== "undefined" && book_direct_charter_dto_1.BookDirectCharterDto) === "function" ? _c : Object, Object]),
    __metadata("design:returntype", Promise)
], DirectCharterController.prototype, "bookDirectCharter", null);
__decorate([
    (0, common_1.Get)('aircraft-types'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all aircraft type placeholders' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Returns list of aircraft type placeholders with images'
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DirectCharterController.prototype, "getAircraftTypes", null);
__decorate([
    (0, common_1.Get)('aircraft'),
    (0, swagger_1.ApiOperation)({ summary: 'Get available aircraft by type' }),
    (0, swagger_1.ApiQuery)({ name: 'typeId', required: false, description: 'Aircraft type ID to filter by' }),
    (0, swagger_1.ApiQuery)({ name: 'userLocation', required: false, description: 'User location for flight duration calculation' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Returns available aircraft of specified type'
    }),
    __param(0, (0, common_1.Query)('typeId')),
    __param(1, (0, common_1.Query)('userLocation')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, String]),
    __metadata("design:returntype", Promise)
], DirectCharterController.prototype, "getAircraftByType", null);
__decorate([
    (0, common_1.Get)('health'),
    (0, swagger_1.ApiOperation)({ summary: 'Check direct charter service health' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Service is healthy' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DirectCharterController.prototype, "healthCheck", null);
__decorate([
    (0, common_1.Get)('aircraft/:aircraftId/booked-dates'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get booked dates for a specific aircraft' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Returns list of booked dates for the aircraft'
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Aircraft not found' }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Start date for filtering (ISO string)' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'End date for filtering (ISO string)' }),
    __param(0, (0, common_1.Param)('aircraftId')),
    __param(1, (0, common_1.Query)('startDate')),
    __param(2, (0, common_1.Query)('endDate')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], DirectCharterController.prototype, "getBookedDates", null);
exports.DirectCharterController = DirectCharterController = __decorate([
    (0, swagger_1.ApiTags)('Direct Charter'),
    (0, common_1.Controller)('direct-charter'),
    __metadata("design:paramtypes", [typeof (_a = typeof direct_charter_service_1.DirectCharterService !== "undefined" && direct_charter_service_1.DirectCharterService) === "function" ? _a : Object])
], DirectCharterController);


/***/ }),
/* 143 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirectCharterService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const aircraft_entity_1 = __webpack_require__(35);
const aircraft_calendar_entity_1 = __webpack_require__(138);
const booking_entity_1 = __webpack_require__(29);
const charters_company_entity_1 = __webpack_require__(31);
const passenger_entity_1 = __webpack_require__(41);
const user_entity_1 = __webpack_require__(14);
const payment_entity_1 = __webpack_require__(76);
const aircraft_type_image_placeholder_entity_1 = __webpack_require__(40);
const payment_provider_service_1 = __webpack_require__(83);
const payment_provider_interface_1 = __webpack_require__(84);
const google_earth_engine_service_1 = __webpack_require__(53);
let DirectCharterService = class DirectCharterService {
    constructor(aircraftRepository, aircraftCalendarRepository, bookingRepository, companyRepository, passengerRepository, paymentRepository, aircraftTypeImagePlaceholderRepository, dataSource, paymentProviderService, googleEarthEngineService) {
        this.aircraftRepository = aircraftRepository;
        this.aircraftCalendarRepository = aircraftCalendarRepository;
        this.bookingRepository = bookingRepository;
        this.companyRepository = companyRepository;
        this.passengerRepository = passengerRepository;
        this.paymentRepository = paymentRepository;
        this.aircraftTypeImagePlaceholderRepository = aircraftTypeImagePlaceholderRepository;
        this.dataSource = dataSource;
        this.paymentProviderService = paymentProviderService;
        this.googleEarthEngineService = googleEarthEngineService;
    }
    async searchAvailableAircraft(searchDto) {
        const { origin, destination, departureDateTime, returnDateTime, passengerCount, tripType, aircraftTypeImagePlaceholderId } = searchDto;
        const departureDate = new Date(departureDateTime);
        const returnDate = returnDateTime ? new Date(returnDateTime) : null;
        let query = this.aircraftRepository
            .createQueryBuilder('aircraft')
            .leftJoinAndSelect('aircraft.company', 'company')
            .leftJoinAndSelect('aircraft.images', 'images')
            .leftJoinAndSelect('aircraft.aircraftTypeImagePlaceholder', 'aircraftType')
            .where('aircraft.isAvailable = :isAvailable', { isAvailable: true })
            .andWhere('aircraft.maintenanceStatus = :maintenanceStatus', { maintenanceStatus: 'operational' })
            .andWhere('aircraft.capacity >= :passengerCount', { passengerCount });
        if (aircraftTypeImagePlaceholderId) {
            query = query.andWhere('aircraft.aircraftTypeImagePlaceholderId = :aircraftTypeId', {
                aircraftTypeId: aircraftTypeImagePlaceholderId
            });
        }
        const availableAircraft = await query.getMany();
        const results = [];
        for (const aircraft of availableAircraft) {
            const isAvailable = await this.checkAircraftAvailability(aircraft.id, departureDate, returnDate, tripType);
            if (isAvailable) {
                const pricing = await this.calculatePricing(aircraft, origin, destination, departureDate, returnDate, tripType);
                const priority = this.calculateLocationPriority(aircraft, origin);
                results.push({
                    id: aircraft.id,
                    name: aircraft.name,
                    model: aircraft.model,
                    capacity: aircraft.capacity,
                    pricePerHour: aircraft.pricePerHour,
                    baseAirport: aircraft.baseAirport,
                    baseCity: aircraft.baseCity,
                    companyName: aircraft.company?.companyName || 'Unknown',
                    imageUrl: aircraft.images?.[0]?.url || null,
                    ...pricing,
                    priority,
                });
            }
        }
        return results.sort((a, b) => {
            if (a.priority !== b.priority) {
                return a.priority - b.priority;
            }
            return a.totalPrice - b.totalPrice;
        });
    }
    async checkAircraftAvailability(aircraftId, departureDate, returnDate, tripType) {
        const startDate = departureDate;
        const endDate = returnDate || departureDate;
        const conflicts = await this.aircraftCalendarRepository
            .createQueryBuilder('calendar')
            .where('calendar.aircraftId = :aircraftId', { aircraftId })
            .andWhere('calendar.eventType IN (:...blockingEvents)', {
            blockingEvents: [aircraft_calendar_entity_1.CalendarEventType.BOOKED, aircraft_calendar_entity_1.CalendarEventType.MAINTENANCE, aircraft_calendar_entity_1.CalendarEventType.BLOCKED]
        })
            .andWhere('(calendar.startDateTime <= :endDate AND calendar.endDateTime >= :startDate)', { startDate, endDate })
            .getCount();
        return conflicts === 0;
    }
    async calculatePricing(aircraft, origin, destination, departureDate, returnDate, tripType) {
        const basePricePerHour = parseFloat(aircraft.pricePerHour.toString());
        const flightDurationHours = await this.computeDurationHours(origin, destination, aircraft);
        const repositioningCost = this.calculateRepositioningCost(aircraft, origin);
        let totalHours = flightDurationHours;
        let totalPrice = basePricePerHour * flightDurationHours;
        if (tripType === 'roundtrip' && returnDate) {
            const returnDurationHours = await this.computeDurationHours(destination, origin, aircraft);
            totalHours += returnDurationHours;
            totalPrice += basePricePerHour * returnDurationHours;
        }
        totalPrice += repositioningCost;
        return {
            totalPrice: Math.round(totalPrice * 100) / 100,
            pricePerHour: basePricePerHour,
            repositioningCost: Math.round(repositioningCost * 100) / 100,
            flightDurationHours: Math.round(flightDurationHours * 10) / 10,
            totalHours: Math.round(totalHours * 10) / 10,
        };
    }
    estimateFlightDuration(origin, destination) {
        return 2.5;
    }
    kmToNm(km) {
        return km / 1.852;
    }
    async computeDurationHours(origin, destination, aircraft) {
        try {
            const [originCoords, destCoords] = await Promise.all([
                this.getLocationCoordinates(origin),
                this.getLocationCoordinates(destination),
            ]);
            if (!originCoords || !destCoords) {
                return this.estimateFlightDuration(origin, destination);
            }
            const distanceKm = this.googleEarthEngineService.calculateFlightDistance(originCoords.lat, originCoords.lng, destCoords.lat, destCoords.lng);
            const distanceNm = this.kmToNm(distanceKm);
            const speedKnots = aircraft.cruiseSpeedKnots || 0;
            if (speedKnots > 0 && distanceNm > 0) {
                const hours = distanceNm / speedKnots;
                return Math.max(hours, 0.5);
            }
            return this.estimateFlightDuration(origin, destination);
        }
        catch (e) {
            return this.estimateFlightDuration(origin, destination);
        }
    }
    calculateRepositioningCost(aircraft, origin) {
        if (aircraft.baseCity?.toLowerCase() === origin.toLowerCase()) {
            return 0;
        }
        const basePricePerHour = parseFloat(aircraft.pricePerHour.toString());
        return basePricePerHour * 0.5;
    }
    calculateLocationPriority(aircraft, origin) {
        const aircraftCity = aircraft.baseCity?.toLowerCase();
        const originCity = origin.toLowerCase();
        if (aircraftCity === originCity) {
            return 1;
        }
        return 2;
    }
    async bookDirectCharter(bookDto, userId) {
        const { aircraftId, departureDateTime, returnDateTime, tripType } = bookDto;
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            const existingBooking = await queryRunner.manager.findOne(booking_entity_1.Booking, {
                where: {
                    aircraftId: aircraftId,
                    bookingStatus: (0, typeorm_2.In)([booking_entity_1.BookingStatus.PENDING, booking_entity_1.BookingStatus.CONFIRMED]),
                    departureDateTime: (0, typeorm_2.Between)(new Date(departureDateTime), returnDateTime ? new Date(returnDateTime) : new Date(departureDateTime)),
                },
                lock: { mode: 'pessimistic_write' },
            });
            if (existingBooking) {
                throw new common_1.BadRequestException('Aircraft slot is already booked for the selected time period');
            }
            const aircraft = await queryRunner.manager.findOne(aircraft_entity_1.Aircraft, {
                where: { id: aircraftId },
                relations: ['company'],
                lock: { mode: 'pessimistic_write' },
            });
            if (!aircraft) {
                throw new common_1.NotFoundException(`Aircraft with ID ${aircraftId} not found`);
            }
            const user = await queryRunner.manager.findOne(user_entity_1.User, {
                where: { id: userId },
                select: ['id', 'first_name', 'last_name', 'nationality', 'date_of_birth']
            });
            if (!user) {
                throw new common_1.NotFoundException(`User with ID ${userId} not found`);
            }
            const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
            const time = new Date().toTimeString().slice(0, 8).replace(/:/g, '');
            const random = Math.random().toString(36).substr(2, 3).toUpperCase();
            const bookingId = `BK-${timestamp}-${time}-${random}`;
            const referenceNumber = `AC${Math.random().toString(36).substr(2, 8).toUpperCase()}`;
            const [originCoords, destinationCoords] = await Promise.all([
                this.getLocationCoordinates(bookDto.origin),
                this.getLocationCoordinates(bookDto.destination)
            ]);
            let distanceNm = null;
            let estimatedFlightHours = null;
            let estimatedArrivalTime = null;
            try {
                if (originCoords && destinationCoords) {
                    const distanceKm = this.googleEarthEngineService.calculateFlightDistance(originCoords.lat, originCoords.lng, destinationCoords.lat, destinationCoords.lng);
                    distanceNm = Math.round(this.kmToNm(distanceKm) * 100) / 100;
                }
                const duration = await this.computeDurationHours(bookDto.origin, bookDto.destination, aircraft);
                estimatedFlightHours = Math.round(duration * 100) / 100;
                const dep = new Date(bookDto.departureDateTime);
                estimatedArrivalTime = new Date(dep.getTime() + (duration * 3600 * 1000));
            }
            catch (e) {
            }
            const now = new Date();
            const booking = this.bookingRepository.create({
                userId: userId,
                dealId: null,
                companyId: aircraft.company?.id || 1,
                aircraftId: bookDto.aircraftId,
                bookingType: booking_entity_1.BookingType.DIRECT,
                totalPrice: bookDto.totalPrice,
                bookingStatus: booking_entity_1.BookingStatus.PENDING,
                paymentStatus: booking_entity_1.PaymentStatus.PENDING,
                referenceNumber: referenceNumber,
                specialRequirements: bookDto.specialRequests,
                originName: bookDto.origin,
                destinationName: bookDto.destination,
                departureDateTime: new Date(bookDto.departureDateTime),
                estimatedFlightHours: estimatedFlightHours ?? null,
                estimatedArrivalTime: estimatedArrivalTime ?? null,
                originLatitude: originCoords?.lat || null,
                originLongitude: originCoords?.lng || null,
                destinationLatitude: destinationCoords?.lat || null,
                destinationLongitude: destinationCoords?.lng || null,
                distanceNm: distanceNm ?? null,
                totalAdults: bookDto.passengerCount,
                totalChildren: 0,
                onboardDining: false,
                createdAt: now,
                updatedAt: now,
            });
            const savedBookingArr = await queryRunner.manager.save(booking);
            const savedBooking = Array.isArray(savedBookingArr) ? savedBookingArr[0] : savedBookingArr;
            const passenger = this.passengerRepository.create({
                booking_id: savedBooking.id,
                first_name: user.first_name || 'Direct Charter',
                last_name: user.last_name || 'Passenger',
                age: user.date_of_birth ? this.calculateAge(user.date_of_birth) : 25,
                nationality: user.nationality || 'Kenyan',
                id_passport_number: 'N/A',
                is_user: true,
            });
            await queryRunner.manager.save(passenger);
            const calendarEntry = this.aircraftCalendarRepository.create({
                aircraftId: bookDto.aircraftId,
                companyId: aircraft.company?.id || 1,
                startDateTime: new Date(departureDateTime),
                endDateTime: returnDateTime ? new Date(returnDateTime) : new Date(departureDateTime),
                eventType: aircraft_calendar_entity_1.CalendarEventType.BOOKED,
                bookingId: savedBooking.id.toString(),
                originAirport: bookDto.origin,
                destinationAirport: bookDto.destination,
                passengerCount: bookDto.passengerCount,
                totalPrice: bookDto.totalPrice,
                pricePerHour: bookDto.pricePerHour,
                repositioningCost: bookDto.repositioningCost,
            });
            await queryRunner.manager.save(calendarEntry);
            let paymentIntent = null;
            if (bookDto.totalPrice > 0) {
                try {
                    paymentIntent = await this.paymentProviderService.createPaymentIntent({
                        amount: bookDto.totalPrice,
                        currency: 'USD',
                        bookingId: savedBooking.id.toString(),
                        userId: userId,
                        description: `Payment for direct charter booking ${referenceNumber}`,
                        metadata: {
                            bookingId: savedBooking.id.toString(),
                            referenceNumber: referenceNumber,
                            dealId: 0,
                            company_id: aircraft.company?.id || 1,
                            bookingType: 'direct_charter',
                            aircraftId: bookDto.aircraftId,
                        },
                    }, payment_provider_interface_1.PaymentProviderType.PAYSTACK);
                }
                catch (error) {
                    console.error('Failed to create payment intent for direct charter:', error);
                    throw new common_1.BadRequestException(`Payment setup failed: ${error.message}`);
                }
            }
            else {
                console.log(`Skipping payment intent creation for inquiry (totalPrice: ${bookDto.totalPrice})`);
            }
            await queryRunner.commitTransaction();
            return {
                booking: {
                    id: savedBooking.id,
                    referenceNumber: referenceNumber,
                    totalPrice: bookDto.totalPrice,
                    bookingStatus: 'pending',
                    paymentStatus: 'pending',
                    companyId: aircraft.company?.id || 1,
                    distanceNm: distanceNm,
                    estimatedFlightHours: estimatedFlightHours,
                    estimatedArrivalTime: estimatedArrivalTime?.toISOString() || null,
                },
                paymentIntent: paymentIntent ? {
                    id: paymentIntent.id,
                    clientSecret: paymentIntent.clientSecret,
                    status: paymentIntent.status,
                    requiresAction: paymentIntent.requiresAction,
                    nextAction: paymentIntent.nextAction,
                } : null,
                paymentInstructions: {
                    amount: bookDto.totalPrice,
                    currency: 'USD',
                    paymentMethods: ['card', 'apple_pay', 'google_pay'],
                    nextSteps: paymentIntent ? [
                        'Complete payment using the client secret',
                        'Confirm payment using /bookings/:id/pay',
                    ] : [
                        'Create payment intent using /payments/create-intent',
                        'Complete payment with Stripe',
                        'Process booking using /bookings/:id/pay',
                    ],
                    apiEndpoints: {
                        createIntent: `/payments/create-intent`,
                        confirmPayment: `/bookings/${savedBooking.id}/pay`,
                        paymentStatus: paymentIntent ? `/payments/status/${paymentIntent.id}` : null,
                    },
                },
                message: 'Direct charter booking created successfully. Please complete payment to confirm.',
            };
        }
        catch (error) {
            await queryRunner.rollbackTransaction();
            throw error;
        }
        finally {
            await queryRunner.release();
        }
    }
    async getAircraftTypes() {
        return await this.aircraftTypeImagePlaceholderRepository.find({
            order: { type: 'ASC' }
        });
    }
    async getAircraftByType(typeId, userLocation) {
        let query = this.aircraftRepository
            .createQueryBuilder('aircraft')
            .leftJoinAndSelect('aircraft.company', 'company')
            .leftJoinAndSelect('aircraft.images', 'images')
            .leftJoinAndSelect('aircraft.aircraftTypeImagePlaceholder', 'aircraftType')
            .where('aircraft.isAvailable = :isAvailable', { isAvailable: true })
            .andWhere('aircraft.maintenanceStatus = :maintenanceStatus', { maintenanceStatus: 'operational' })
            .andWhere('company.status = :companyStatus', { companyStatus: 'active' });
        if (typeId) {
            query = query.andWhere('aircraft.aircraftTypeImagePlaceholderId = :typeId', { typeId });
        }
        const aircraft = await query.getMany();
        return aircraft.map(aircraft => ({
            id: aircraft.id,
            name: aircraft.name,
            model: aircraft.model,
            capacity: aircraft.capacity,
            pricePerHour: aircraft.pricePerHour,
            baseAirport: aircraft.baseAirport,
            baseCity: aircraft.baseCity,
            companyId: aircraft.company?.id || null,
            companyName: aircraft.company?.companyName || 'Unknown',
            imageUrl: aircraft.images?.[0]?.url || aircraft.aircraftTypeImagePlaceholder?.placeholderImageUrl || null,
            aircraftType: aircraft.aircraftTypeImagePlaceholder?.type || 'unknown',
            flightDurationHours: this.estimateFlightDuration(aircraft.baseCity || 'Nairobi', userLocation || 'Nairobi'),
        }));
    }
    calculateAge(birthDate) {
        const today = new Date();
        let age = today.getFullYear() - birthDate.getFullYear();
        const monthDiff = today.getMonth() - birthDate.getMonth();
        if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
            age--;
        }
        return age;
    }
    async getLocationCoordinates(locationName) {
        try {
            const searchResults = await this.googleEarthEngineService.searchLocations({
                query: locationName,
                type: 'airport',
            });
            if (searchResults.length > 0) {
                return searchResults[0].location;
            }
            const broaderResults = await this.googleEarthEngineService.searchLocations({
                query: locationName,
            });
            if (broaderResults.length > 0) {
                return broaderResults[0].location;
            }
            return null;
        }
        catch (error) {
            console.error(`Error getting coordinates for ${locationName}:`, error);
            return null;
        }
    }
    async getBookedDates(aircraftId, startDate, endDate) {
        try {
            const queryBuilder = this.bookingRepository
                .createQueryBuilder('booking')
                .select('booking.departureDateTime')
                .where('booking.aircraftId = :aircraftId', { aircraftId })
                .andWhere('booking.bookingStatus IN (:...statuses)', {
                statuses: [booking_entity_1.BookingStatus.PENDING, booking_entity_1.BookingStatus.CONFIRMED],
            });
            if (startDate) {
                queryBuilder.andWhere('booking.departureDateTime >= :startDate', {
                    startDate,
                });
            }
            if (endDate) {
                queryBuilder.andWhere('booking.departureDateTime <= :endDate', {
                    endDate,
                });
            }
            const results = await queryBuilder.getMany();
            const bookedDates = new Set();
            results.forEach(booking => {
                const date = new Date(booking.departureDateTime);
                const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                bookedDates.add(dateString);
            });
            return Array.from(bookedDates).map(dateString => new Date(dateString));
        }
        catch (error) {
            console.error('Error fetching booked dates:', error);
            throw new Error('Failed to fetch booked dates');
        }
    }
};
exports.DirectCharterService = DirectCharterService;
exports.DirectCharterService = DirectCharterService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(aircraft_entity_1.Aircraft)),
    __param(1, (0, typeorm_1.InjectRepository)(aircraft_calendar_entity_1.AircraftCalendar)),
    __param(2, (0, typeorm_1.InjectRepository)(booking_entity_1.Booking)),
    __param(3, (0, typeorm_1.InjectRepository)(charters_company_entity_1.ChartersCompany)),
    __param(4, (0, typeorm_1.InjectRepository)(passenger_entity_1.Passenger)),
    __param(5, (0, typeorm_1.InjectRepository)(payment_entity_1.Payment)),
    __param(6, (0, typeorm_1.InjectRepository)(aircraft_type_image_placeholder_entity_1.AircraftTypeImagePlaceholder)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object, typeof (_d = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _d : Object, typeof (_e = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _e : Object, typeof (_f = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _f : Object, typeof (_g = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _g : Object, typeof (_h = typeof typeorm_2.DataSource !== "undefined" && typeorm_2.DataSource) === "function" ? _h : Object, typeof (_j = typeof payment_provider_service_1.PaymentProviderService !== "undefined" && payment_provider_service_1.PaymentProviderService) === "function" ? _j : Object, typeof (_k = typeof google_earth_engine_service_1.GoogleEarthEngineService !== "undefined" && google_earth_engine_service_1.GoogleEarthEngineService) === "function" ? _k : Object])
], DirectCharterService);
function andWhere(arg0, arg1) {
    throw new Error('Function not implemented.');
}


/***/ }),
/* 144 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchDirectCharterDto = void 0;
const class_validator_1 = __webpack_require__(19);
const swagger_1 = __webpack_require__(3);
class SearchDirectCharterDto {
    constructor() {
        this.tripType = 'oneway';
    }
}
exports.SearchDirectCharterDto = SearchDirectCharterDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Origin airport code or city' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], SearchDirectCharterDto.prototype, "origin", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Destination airport code or city' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], SearchDirectCharterDto.prototype, "destination", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Departure date and time', example: '2024-01-15T10:00:00Z' }),
    (0, class_validator_1.IsDateString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], SearchDirectCharterDto.prototype, "departureDateTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Return date and time (optional for round trip)', example: '2024-01-20T18:00:00Z', required: false }),
    (0, class_validator_1.IsDateString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], SearchDirectCharterDto.prototype, "returnDateTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of passengers', minimum: 1, maximum: 50 }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(50),
    __metadata("design:type", Number)
], SearchDirectCharterDto.prototype, "passengerCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Trip type', enum: ['oneway', 'roundtrip'], default: 'oneway' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchDirectCharterDto.prototype, "tripType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Aircraft type image placeholder ID for filtering', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    __metadata("design:type", Number)
], SearchDirectCharterDto.prototype, "aircraftTypeImagePlaceholderId", void 0);


/***/ }),
/* 145 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BookDirectCharterDto = void 0;
const class_validator_1 = __webpack_require__(19);
const swagger_1 = __webpack_require__(3);
class BookDirectCharterDto {
}
exports.BookDirectCharterDto = BookDirectCharterDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Aircraft ID' }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Number)
], BookDirectCharterDto.prototype, "aircraftId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Origin airport' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], BookDirectCharterDto.prototype, "origin", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Destination airport' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], BookDirectCharterDto.prototype, "destination", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Departure date and time' }),
    (0, class_validator_1.IsDateString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], BookDirectCharterDto.prototype, "departureDateTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Return date and time (for round trips)', required: false }),
    (0, class_validator_1.IsDateString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], BookDirectCharterDto.prototype, "returnDateTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of passengers' }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(50),
    __metadata("design:type", Number)
], BookDirectCharterDto.prototype, "passengerCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total price' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Number)
], BookDirectCharterDto.prototype, "totalPrice", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Price per hour' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Number)
], BookDirectCharterDto.prototype, "pricePerHour", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Repositioning cost', required: false }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], BookDirectCharterDto.prototype, "repositioningCost", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Trip type', enum: ['oneway', 'roundtrip'] }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BookDirectCharterDto.prototype, "tripType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Special requests', required: false }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], BookDirectCharterDto.prototype, "specialRequests", void 0);


/***/ }),
/* 146 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BookingInquiriesModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const booking_inquiries_controller_1 = __webpack_require__(147);
const booking_inquiries_service_1 = __webpack_require__(148);
const payments_module_1 = __webpack_require__(99);
const booking_inquiry_entity_1 = __webpack_require__(149);
const inquiry_stop_entity_1 = __webpack_require__(150);
const aircraft_entity_1 = __webpack_require__(35);
const user_entity_1 = __webpack_require__(14);
const booking_entity_1 = __webpack_require__(29);
const payment_entity_1 = __webpack_require__(76);
const aircraft_calendar_entity_1 = __webpack_require__(138);
let BookingInquiriesModule = class BookingInquiriesModule {
};
exports.BookingInquiriesModule = BookingInquiriesModule;
exports.BookingInquiriesModule = BookingInquiriesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([booking_inquiry_entity_1.BookingInquiry, inquiry_stop_entity_1.InquiryStop, aircraft_entity_1.Aircraft, user_entity_1.User, booking_entity_1.Booking, payment_entity_1.Payment, aircraft_calendar_entity_1.AircraftCalendar]),
            payments_module_1.PaymentsModule,
        ],
        controllers: [booking_inquiries_controller_1.BookingInquiriesController],
        providers: [booking_inquiries_service_1.BookingInquiriesService],
        exports: [booking_inquiries_service_1.BookingInquiriesService],
    })
], BookingInquiriesModule);


/***/ }),
/* 147 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BookingInquiriesController = void 0;
const common_1 = __webpack_require__(2);
const booking_inquiries_service_1 = __webpack_require__(148);
const create_booking_inquiry_dto_1 = __webpack_require__(151);
const update_booking_inquiry_dto_1 = __webpack_require__(152);
const jwt_auth_guard_1 = __webpack_require__(16);
const current_user_decorator_1 = __webpack_require__(104);
const user_entity_1 = __webpack_require__(14);
let BookingInquiriesController = class BookingInquiriesController {
    constructor(bookingInquiriesService) {
        this.bookingInquiriesService = bookingInquiriesService;
    }
    async create(createBookingInquiryDto, user) {
        return this.bookingInquiriesService.create(createBookingInquiryDto, user.id);
    }
    async findAll(user) {
        return this.bookingInquiriesService.findAll(user.id);
    }
    async findOne(id, user) {
        return this.bookingInquiriesService.findOne(id);
    }
    async findByReference(referenceNumber) {
        return this.bookingInquiriesService.findByReference(referenceNumber);
    }
    async confirmInquiry(id, user) {
        const result = await this.bookingInquiriesService.confirmInquiry(id, user.id);
        return {
            success: true,
            message: 'Inquiry confirmed successfully',
            data: result,
        };
    }
    async cancelInquiry(id, user) {
        return this.bookingInquiriesService.cancelInquiry(id, user.id);
    }
    async update(id, updateBookingInquiryDto) {
        return this.bookingInquiriesService.update(id, updateBookingInquiryDto);
    }
    async getAircraftAvailabilityForInquiry(aircraftId, startDate, endDate) {
        const start = new Date(startDate);
        const end = new Date(endDate);
        return this.bookingInquiriesService.getAircraftAvailabilityForInquiry(aircraftId, start, end);
    }
};
exports.BookingInquiriesController = BookingInquiriesController;
__decorate([
    (0, common_1.Post)(),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof create_booking_inquiry_dto_1.CreateBookingInquiryDto !== "undefined" && create_booking_inquiry_dto_1.CreateBookingInquiryDto) === "function" ? _b : Object, typeof (_c = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], BookingInquiriesController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], BookingInquiriesController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)(':id'),
    __param(0, (0, common_1.Param)('id', common_1.ParseIntPipe)),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, typeof (_e = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _e : Object]),
    __metadata("design:returntype", Promise)
], BookingInquiriesController.prototype, "findOne", null);
__decorate([
    (0, common_1.Get)('reference/:referenceNumber'),
    __param(0, (0, common_1.Param)('referenceNumber')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BookingInquiriesController.prototype, "findByReference", null);
__decorate([
    (0, common_1.Put)(':id/confirm'),
    __param(0, (0, common_1.Param)('id', common_1.ParseIntPipe)),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, typeof (_f = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], BookingInquiriesController.prototype, "confirmInquiry", null);
__decorate([
    (0, common_1.Put)(':id/cancel'),
    __param(0, (0, common_1.Param)('id', common_1.ParseIntPipe)),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, typeof (_g = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _g : Object]),
    __metadata("design:returntype", Promise)
], BookingInquiriesController.prototype, "cancelInquiry", null);
__decorate([
    (0, common_1.Put)(':id'),
    __param(0, (0, common_1.Param)('id', common_1.ParseIntPipe)),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, typeof (_h = typeof update_booking_inquiry_dto_1.UpdateBookingInquiryDto !== "undefined" && update_booking_inquiry_dto_1.UpdateBookingInquiryDto) === "function" ? _h : Object]),
    __metadata("design:returntype", Promise)
], BookingInquiriesController.prototype, "update", null);
__decorate([
    (0, common_1.Get)('aircraft/:aircraftId/availability'),
    __param(0, (0, common_1.Param)('aircraftId', common_1.ParseIntPipe)),
    __param(1, (0, common_1.Query)('startDate')),
    __param(2, (0, common_1.Query)('endDate')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, String, String]),
    __metadata("design:returntype", Promise)
], BookingInquiriesController.prototype, "getAircraftAvailabilityForInquiry", null);
exports.BookingInquiriesController = BookingInquiriesController = __decorate([
    (0, common_1.Controller)('booking-inquiries'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    __metadata("design:paramtypes", [typeof (_a = typeof booking_inquiries_service_1.BookingInquiriesService !== "undefined" && booking_inquiries_service_1.BookingInquiriesService) === "function" ? _a : Object])
], BookingInquiriesController);


/***/ }),
/* 148 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BookingInquiriesService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const booking_inquiry_entity_1 = __webpack_require__(149);
const inquiry_stop_entity_1 = __webpack_require__(150);
const aircraft_entity_1 = __webpack_require__(35);
const user_entity_1 = __webpack_require__(14);
const booking_entity_1 = __webpack_require__(29);
const payment_entity_1 = __webpack_require__(76);
const aircraft_calendar_entity_1 = __webpack_require__(138);
const payment_provider_service_1 = __webpack_require__(83);
let BookingInquiriesService = class BookingInquiriesService {
    constructor(bookingInquiryRepository, inquiryStopRepository, aircraftRepository, userRepository, bookingRepository, paymentRepository, aircraftCalendarRepository, dataSource, paymentProviderService) {
        this.bookingInquiryRepository = bookingInquiryRepository;
        this.inquiryStopRepository = inquiryStopRepository;
        this.aircraftRepository = aircraftRepository;
        this.userRepository = userRepository;
        this.bookingRepository = bookingRepository;
        this.paymentRepository = paymentRepository;
        this.aircraftCalendarRepository = aircraftCalendarRepository;
        this.dataSource = dataSource;
        this.paymentProviderService = paymentProviderService;
    }
    async create(createBookingInquiryDto, userId) {
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            const referenceNumber = this.generateReferenceNumber();
            const aircraft = await this.aircraftRepository.findOne({
                where: { id: createBookingInquiryDto.aircraftId }
            });
            if (!aircraft) {
                throw new common_1.NotFoundException('Aircraft not found');
            }
            const user = await this.userRepository.findOne({
                where: { id: userId }
            });
            if (!user) {
                throw new common_1.NotFoundException('User not found');
            }
            if (createBookingInquiryDto.preferredDepartureDate) {
                const isAvailable = await this.checkAircraftAvailabilityForInquiry(createBookingInquiryDto.aircraftId, new Date(createBookingInquiryDto.preferredDepartureDate), createBookingInquiryDto.preferredReturnDate ? new Date(createBookingInquiryDto.preferredReturnDate) : null);
                if (!isAvailable) {
                    throw new common_1.BadRequestException('Aircraft is not available for the requested dates. Please select different dates or contact support for alternative options.');
                }
            }
            const bookingInquiry = this.bookingInquiryRepository.create({
                userId,
                aircraftId: createBookingInquiryDto.aircraftId,
                company_id: aircraft.companyId,
                requestedSeats: createBookingInquiryDto.requestedSeats,
                specialRequirements: createBookingInquiryDto.specialRequirements,
                onboardDining: createBookingInquiryDto.onboardDining || false,
                groundTransportation: createBookingInquiryDto.groundTransportation || false,
                billingRegion: createBookingInquiryDto.billingRegion,
                userNotes: createBookingInquiryDto.userNotes,
                referenceNumber,
            });
            const savedInquiry = await queryRunner.manager.save(bookingInquiry);
            if (createBookingInquiryDto.stops && createBookingInquiryDto.stops.length > 0) {
                const stops = createBookingInquiryDto.stops.map(stopDto => this.inquiryStopRepository.create({
                    bookingInquiryId: savedInquiry.id,
                    stopName: stopDto.stopName,
                    longitude: stopDto.longitude,
                    latitude: stopDto.latitude,
                    price: stopDto.price,
                    datetime: stopDto.datetime ? new Date(stopDto.datetime) : null,
                    stopOrder: stopDto.stopOrder || 1,
                    locationCode: stopDto.locationCode,
                }));
                await queryRunner.manager.save(stops);
            }
            await queryRunner.commitTransaction();
            return await this.findOne(savedInquiry.id);
        }
        catch (error) {
            await queryRunner.rollbackTransaction();
            throw error;
        }
        finally {
            await queryRunner.release();
        }
    }
    async findAll(userId) {
        return await this.bookingInquiryRepository.find({
            where: { userId },
            relations: ['stops', 'aircraft', 'user'],
            order: { createdAt: 'DESC' },
        });
    }
    async findOne(id) {
        const inquiry = await this.bookingInquiryRepository.findOne({
            where: { id },
            relations: ['stops', 'aircraft', 'user'],
        });
        if (!inquiry) {
            throw new common_1.NotFoundException(`Booking inquiry with ID ${id} not found`);
        }
        return inquiry;
    }
    async findByReference(referenceNumber) {
        const inquiry = await this.bookingInquiryRepository.findOne({
            where: { referenceNumber },
            relations: ['stops', 'aircraft', 'user'],
        });
        if (!inquiry) {
            throw new common_1.NotFoundException(`Booking inquiry with reference ${referenceNumber} not found`);
        }
        return inquiry;
    }
    async update(id, updateBookingInquiryDto) {
        const inquiry = await this.findOne(id);
        if (updateBookingInquiryDto.inquiryStatus === booking_inquiry_entity_1.InquiryStatus.PRICED) {
            inquiry.inquiryStatus = booking_inquiry_entity_1.InquiryStatus.PRICED;
            inquiry.proposedPrice = updateBookingInquiryDto.proposedPrice;
            inquiry.proposedPriceType = updateBookingInquiryDto.proposedPriceType;
            inquiry.adminNotes = updateBookingInquiryDto.adminNotes;
            inquiry.pricedAt = new Date();
        }
        return await this.bookingInquiryRepository.save(inquiry);
    }
    async confirmInquiry(id, userId) {
        const inquiry = await this.findOne(id);
        if (inquiry.userId !== userId) {
            throw new common_1.BadRequestException('You can only confirm your own inquiries');
        }
        if (inquiry.inquiryStatus !== booking_inquiry_entity_1.InquiryStatus.PRICED) {
            throw new common_1.BadRequestException('Inquiry must be priced before confirmation');
        }
        if (!inquiry.proposedPrice) {
            throw new common_1.BadRequestException('Inquiry must have a proposed price');
        }
        inquiry.inquiryStatus = booking_inquiry_entity_1.InquiryStatus.CONFIRMED;
        inquiry.confirmedAt = new Date();
        await this.bookingInquiryRepository.save(inquiry);
        const booking = await this.createBookingFromInquiry(inquiry);
        let paymentIntent = null;
        if (this.paymentProviderService) {
            try {
                paymentIntent = await this.paymentProviderService.createPaymentIntent({
                    amount: inquiry.proposedPrice * 100,
                    currency: 'USD',
                    bookingId: booking.id.toString(),
                    userId: inquiry.userId,
                    description: `Payment for inquiry ${inquiry.referenceNumber}`,
                    metadata: {
                        inquiryId: inquiry.id,
                        inquiryReference: inquiry.referenceNumber,
                        aircraftId: inquiry.aircraftId,
                        requestedSeats: inquiry.requestedSeats,
                    },
                });
            }
            catch (error) {
                console.error('Failed to create payment intent:', error);
            }
        }
        return {
            inquiry,
            paymentIntent: paymentIntent ? {
                paymentIntentId: paymentIntent.id,
                clientSecret: paymentIntent.clientSecret,
                status: paymentIntent.status,
            } : null,
        };
    }
    async cancelInquiry(id, userId) {
        const inquiry = await this.findOne(id);
        if (inquiry.userId !== userId) {
            throw new common_1.BadRequestException('You can only cancel your own inquiries');
        }
        if (inquiry.inquiryStatus === booking_inquiry_entity_1.InquiryStatus.CONFIRMED) {
            throw new common_1.BadRequestException('Cannot cancel confirmed inquiries');
        }
        inquiry.inquiryStatus = booking_inquiry_entity_1.InquiryStatus.CANCELLED;
        inquiry.cancelledAt = new Date();
        return await this.bookingInquiryRepository.save(inquiry);
    }
    async createBookingFromInquiry(inquiry) {
        const bookingId = `BK-${new Date().toISOString().slice(0, 10).replace(/-/g, '')}-${Date.now().toString().slice(-6)}-${Math.random().toString(36).substr(2, 3).toUpperCase()}`;
        const booking = this.bookingRepository.create({
            userId: inquiry.userId,
            dealId: null,
            companyId: inquiry.company_id,
            bookingType: booking_entity_1.BookingType.DIRECT,
            totalPrice: inquiry.proposedPrice || 0,
            onboardDining: inquiry.onboardDining,
            referenceNumber: inquiry.referenceNumber,
            bookingStatus: booking_entity_1.BookingStatus.CONFIRMED,
            paymentStatus: booking_entity_1.PaymentStatus.PENDING,
            specialRequirements: inquiry.specialRequirements,
            totalAdults: inquiry.requestedSeats,
            totalChildren: 0,
        });
        return await this.bookingRepository.save(booking);
    }
    generateReferenceNumber() {
        const timestamp = Date.now().toString().slice(-8);
        const random = Math.random().toString(36).substr(2, 4).toUpperCase();
        return `AC${timestamp}${random}`;
    }
    async checkAircraftAvailabilityForInquiry(aircraftId, departureDate, returnDate) {
        const startDate = departureDate;
        const endDate = returnDate || departureDate;
        const conflicts = await this.aircraftCalendarRepository.find({
            where: {
                aircraftId,
                eventType: (0, typeorm_2.In)([aircraft_calendar_entity_1.CalendarEventType.BOOKED, aircraft_calendar_entity_1.CalendarEventType.MAINTENANCE, aircraft_calendar_entity_1.CalendarEventType.BLOCKED]),
                startDateTime: (0, typeorm_2.Between)(startDate, endDate),
            },
        });
        return conflicts.length === 0;
    }
    async getAircraftAvailabilityForInquiry(aircraftId, startDate, endDate) {
        const aircraft = await this.aircraftRepository.findOne({
            where: { id: aircraftId },
            relations: ['company'],
        });
        if (!aircraft) {
            throw new common_1.NotFoundException('Aircraft not found');
        }
        const events = await this.aircraftCalendarRepository.find({
            where: {
                aircraftId,
                startDateTime: (0, typeorm_2.Between)(startDate, endDate),
            },
            order: { startDateTime: 'ASC' },
        });
        const availabilityByDate = {};
        const currentDate = new Date(startDate);
        while (currentDate <= endDate) {
            const dateKey = currentDate.toISOString().split('T')[0];
            const dayEvents = events.filter(event => event.startDateTime.toISOString().split('T')[0] === dateKey);
            availabilityByDate[dateKey] = {
                date: new Date(currentDate),
                isAvailable: dayEvents.length === 0,
                events: dayEvents,
                status: dayEvents.length === 0 ? 'available' : 'unavailable',
                reason: dayEvents.length > 0 ? dayEvents[0].eventType : null,
            };
            currentDate.setDate(currentDate.getDate() + 1);
        }
        return {
            success: true,
            data: {
                aircraft,
                availability: availabilityByDate,
                summary: {
                    totalDays: Object.keys(availabilityByDate).length,
                    availableDays: Object.values(availabilityByDate).filter((day) => day.isAvailable).length,
                    unavailableDays: Object.values(availabilityByDate).filter((day) => !day.isAvailable).length,
                },
            },
        };
    }
};
exports.BookingInquiriesService = BookingInquiriesService;
exports.BookingInquiriesService = BookingInquiriesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(booking_inquiry_entity_1.BookingInquiry)),
    __param(1, (0, typeorm_1.InjectRepository)(inquiry_stop_entity_1.InquiryStop)),
    __param(2, (0, typeorm_1.InjectRepository)(aircraft_entity_1.Aircraft)),
    __param(3, (0, typeorm_1.InjectRepository)(user_entity_1.User)),
    __param(4, (0, typeorm_1.InjectRepository)(booking_entity_1.Booking)),
    __param(5, (0, typeorm_1.InjectRepository)(payment_entity_1.Payment)),
    __param(6, (0, typeorm_1.InjectRepository)(aircraft_calendar_entity_1.AircraftCalendar)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object, typeof (_d = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _d : Object, typeof (_e = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _e : Object, typeof (_f = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _f : Object, typeof (_g = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _g : Object, typeof (_h = typeof typeorm_2.DataSource !== "undefined" && typeorm_2.DataSource) === "function" ? _h : Object, typeof (_j = typeof payment_provider_service_1.PaymentProviderService !== "undefined" && payment_provider_service_1.PaymentProviderService) === "function" ? _j : Object])
], BookingInquiriesService);


/***/ }),
/* 149 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BookingInquiry = exports.ProposedPriceType = exports.InquiryStatus = void 0;
const typeorm_1 = __webpack_require__(13);
const user_entity_1 = __webpack_require__(14);
const aircraft_entity_1 = __webpack_require__(35);
const inquiry_stop_entity_1 = __webpack_require__(150);
var InquiryStatus;
(function (InquiryStatus) {
    InquiryStatus["PENDING"] = "pending";
    InquiryStatus["PRICED"] = "priced";
    InquiryStatus["CONFIRMED"] = "confirmed";
    InquiryStatus["CANCELLED"] = "cancelled";
})(InquiryStatus || (exports.InquiryStatus = InquiryStatus = {}));
var ProposedPriceType;
(function (ProposedPriceType) {
    ProposedPriceType["PER_SEAT"] = "per_seat";
    ProposedPriceType["PER_HOUR"] = "per_hour";
    ProposedPriceType["TOTAL"] = "total";
})(ProposedPriceType || (exports.ProposedPriceType = ProposedPriceType = {}));
let BookingInquiry = class BookingInquiry {
};
exports.BookingInquiry = BookingInquiry;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], BookingInquiry.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)('varchar', { length: 255 }),
    __metadata("design:type", String)
], BookingInquiry.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.Column)('int'),
    __metadata("design:type", Number)
], BookingInquiry.prototype, "aircraftId", void 0);
__decorate([
    (0, typeorm_1.Column)('int'),
    __metadata("design:type", Number)
], BookingInquiry.prototype, "company_id", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: InquiryStatus, default: InquiryStatus.PENDING }),
    __metadata("design:type", String)
], BookingInquiry.prototype, "inquiryStatus", void 0);
__decorate([
    (0, typeorm_1.Column)('int', { default: 1 }),
    __metadata("design:type", Number)
], BookingInquiry.prototype, "requestedSeats", void 0);
__decorate([
    (0, typeorm_1.Column)('text', { nullable: true }),
    __metadata("design:type", String)
], BookingInquiry.prototype, "specialRequirements", void 0);
__decorate([
    (0, typeorm_1.Column)('boolean', { default: false }),
    __metadata("design:type", Boolean)
], BookingInquiry.prototype, "onboardDining", void 0);
__decorate([
    (0, typeorm_1.Column)('boolean', { default: false }),
    __metadata("design:type", Boolean)
], BookingInquiry.prototype, "groundTransportation", void 0);
__decorate([
    (0, typeorm_1.Column)('varchar', { length: 100, nullable: true }),
    __metadata("design:type", String)
], BookingInquiry.prototype, "billingRegion", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], BookingInquiry.prototype, "proposedPrice", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: ProposedPriceType, nullable: true }),
    __metadata("design:type", String)
], BookingInquiry.prototype, "proposedPriceType", void 0);
__decorate([
    (0, typeorm_1.Column)('text', { nullable: true }),
    __metadata("design:type", String)
], BookingInquiry.prototype, "adminNotes", void 0);
__decorate([
    (0, typeorm_1.Column)('text', { nullable: true }),
    __metadata("design:type", String)
], BookingInquiry.prototype, "userNotes", void 0);
__decorate([
    (0, typeorm_1.Column)('varchar', { length: 50 }),
    __metadata("design:type", String)
], BookingInquiry.prototype, "referenceNumber", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ type: 'datetime', precision: 6 }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], BookingInquiry.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ type: 'datetime', precision: 6 }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], BookingInquiry.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.Column)('datetime', { precision: 6, nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], BookingInquiry.prototype, "pricedAt", void 0);
__decorate([
    (0, typeorm_1.Column)('datetime', { precision: 6, nullable: true }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], BookingInquiry.prototype, "confirmedAt", void 0);
__decorate([
    (0, typeorm_1.Column)('datetime', { precision: 6, nullable: true }),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], BookingInquiry.prototype, "cancelledAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_f = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _f : Object)
], BookingInquiry.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => aircraft_entity_1.Aircraft, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'aircraftId' }),
    __metadata("design:type", typeof (_g = typeof aircraft_entity_1.Aircraft !== "undefined" && aircraft_entity_1.Aircraft) === "function" ? _g : Object)
], BookingInquiry.prototype, "aircraft", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => inquiry_stop_entity_1.InquiryStop, (stop) => stop.bookingInquiry, { cascade: true }),
    __metadata("design:type", Array)
], BookingInquiry.prototype, "stops", void 0);
exports.BookingInquiry = BookingInquiry = __decorate([
    (0, typeorm_1.Entity)('booking_inquiries')
], BookingInquiry);


/***/ }),
/* 150 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InquiryStop = exports.LocationType = void 0;
const typeorm_1 = __webpack_require__(13);
const booking_inquiry_entity_1 = __webpack_require__(149);
var LocationType;
(function (LocationType) {
    LocationType["AIRPORT"] = "airport";
    LocationType["CITY"] = "city";
    LocationType["CUSTOM"] = "custom";
})(LocationType || (exports.LocationType = LocationType = {}));
let InquiryStop = class InquiryStop {
};
exports.InquiryStop = InquiryStop;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], InquiryStop.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)('int'),
    __metadata("design:type", Number)
], InquiryStop.prototype, "bookingInquiryId", void 0);
__decorate([
    (0, typeorm_1.Column)('varchar', { length: 255 }),
    __metadata("design:type", String)
], InquiryStop.prototype, "stopName", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 11, scale: 8 }),
    __metadata("design:type", Number)
], InquiryStop.prototype, "longitude", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 8 }),
    __metadata("design:type", Number)
], InquiryStop.prototype, "latitude", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], InquiryStop.prototype, "price", void 0);
__decorate([
    (0, typeorm_1.Column)('datetime', { nullable: true }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], InquiryStop.prototype, "datetime", void 0);
__decorate([
    (0, typeorm_1.Column)('int', { default: 1 }),
    __metadata("design:type", Number)
], InquiryStop.prototype, "stopOrder", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: LocationType, default: LocationType.CUSTOM }),
    __metadata("design:type", String)
], InquiryStop.prototype, "locationType", void 0);
__decorate([
    (0, typeorm_1.Column)('varchar', { length: 10, nullable: true }),
    __metadata("design:type", String)
], InquiryStop.prototype, "locationCode", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ type: 'datetime', precision: 6 }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], InquiryStop.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ type: 'datetime', precision: 6 }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], InquiryStop.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => booking_inquiry_entity_1.BookingInquiry, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'bookingInquiryId' }),
    __metadata("design:type", typeof (_d = typeof booking_inquiry_entity_1.BookingInquiry !== "undefined" && booking_inquiry_entity_1.BookingInquiry) === "function" ? _d : Object)
], InquiryStop.prototype, "bookingInquiry", void 0);
exports.InquiryStop = InquiryStop = __decorate([
    (0, typeorm_1.Entity)('inquiry_stops')
], InquiryStop);


/***/ }),
/* 151 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateBookingInquiryDto = exports.InquiryStopDto = exports.ProposedPriceType = void 0;
const class_validator_1 = __webpack_require__(19);
const class_transformer_1 = __webpack_require__(96);
var ProposedPriceType;
(function (ProposedPriceType) {
    ProposedPriceType["PER_SEAT"] = "per_seat";
    ProposedPriceType["PER_HOUR"] = "per_hour";
    ProposedPriceType["TOTAL"] = "total";
})(ProposedPriceType || (exports.ProposedPriceType = ProposedPriceType = {}));
class InquiryStopDto {
}
exports.InquiryStopDto = InquiryStopDto;
__decorate([
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], InquiryStopDto.prototype, "stopName", void 0);
__decorate([
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(-180),
    (0, class_validator_1.Max)(180),
    __metadata("design:type", Number)
], InquiryStopDto.prototype, "longitude", void 0);
__decorate([
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(-90),
    (0, class_validator_1.Max)(90),
    __metadata("design:type", Number)
], InquiryStopDto.prototype, "latitude", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], InquiryStopDto.prototype, "price", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], InquiryStopDto.prototype, "datetime", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], InquiryStopDto.prototype, "stopOrder", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], InquiryStopDto.prototype, "locationCode", void 0);
class CreateBookingInquiryDto {
}
exports.CreateBookingInquiryDto = CreateBookingInquiryDto;
__decorate([
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], CreateBookingInquiryDto.prototype, "aircraftId", void 0);
__decorate([
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    __metadata("design:type", Number)
], CreateBookingInquiryDto.prototype, "requestedSeats", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBookingInquiryDto.prototype, "specialRequirements", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], CreateBookingInquiryDto.prototype, "onboardDining", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], CreateBookingInquiryDto.prototype, "groundTransportation", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBookingInquiryDto.prototype, "billingRegion", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBookingInquiryDto.prototype, "userNotes", void 0);
__decorate([
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => InquiryStopDto),
    __metadata("design:type", Array)
], CreateBookingInquiryDto.prototype, "stops", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBookingInquiryDto.prototype, "preferredDepartureDate", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBookingInquiryDto.prototype, "preferredReturnDate", void 0);


/***/ }),
/* 152 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateBookingInquiryDto = exports.InquiryStatus = void 0;
const mapped_types_1 = __webpack_require__(153);
const class_validator_1 = __webpack_require__(19);
const create_booking_inquiry_dto_1 = __webpack_require__(151);
var InquiryStatus;
(function (InquiryStatus) {
    InquiryStatus["PENDING"] = "pending";
    InquiryStatus["PRICED"] = "priced";
    InquiryStatus["CONFIRMED"] = "confirmed";
    InquiryStatus["CANCELLED"] = "cancelled";
})(InquiryStatus || (exports.InquiryStatus = InquiryStatus = {}));
class UpdateBookingInquiryDto extends (0, mapped_types_1.PartialType)(create_booking_inquiry_dto_1.CreateBookingInquiryDto) {
}
exports.UpdateBookingInquiryDto = UpdateBookingInquiryDto;
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(InquiryStatus),
    __metadata("design:type", String)
], UpdateBookingInquiryDto.prototype, "inquiryStatus", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], UpdateBookingInquiryDto.prototype, "proposedPrice", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(create_booking_inquiry_dto_1.ProposedPriceType),
    __metadata("design:type", typeof (_a = typeof create_booking_inquiry_dto_1.ProposedPriceType !== "undefined" && create_booking_inquiry_dto_1.ProposedPriceType) === "function" ? _a : Object)
], UpdateBookingInquiryDto.prototype, "proposedPriceType", void 0);
__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateBookingInquiryDto.prototype, "adminNotes", void 0);


/***/ }),
/* 153 */
/***/ ((module) => {

module.exports = require("@nestjs/mapped-types");

/***/ }),
/* 154 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExperiencesModule = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const experiences_controller_1 = __webpack_require__(155);
const experiences_service_1 = __webpack_require__(156);
const experience_template_entity_1 = __webpack_require__(32);
const experience_image_entity_1 = __webpack_require__(33);
const experience_schedule_entity_1 = __webpack_require__(34);
let ExperiencesModule = class ExperiencesModule {
};
exports.ExperiencesModule = ExperiencesModule;
exports.ExperiencesModule = ExperiencesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([
                experience_template_entity_1.ExperienceTemplate,
                experience_image_entity_1.ExperienceImage,
                experience_schedule_entity_1.ExperienceSchedule,
            ]),
        ],
        controllers: [experiences_controller_1.ExperiencesController],
        providers: [experiences_service_1.ExperiencesService],
        exports: [experiences_service_1.ExperiencesService],
    })
], ExperiencesModule);


/***/ }),
/* 155 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExperiencesController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const experiences_service_1 = __webpack_require__(156);
const experience_response_dto_1 = __webpack_require__(157);
let ExperiencesController = class ExperiencesController {
    constructor(experiencesService) {
        this.experiencesService = experiencesService;
    }
    async getAllExperiences() {
        const categories = await this.experiencesService.getAllExperiences();
        return {
            success: true,
            message: 'Experiences retrieved successfully',
            data: {
                categories,
            },
        };
    }
    async getExperienceById(id) {
        const experience = await this.experiencesService.getExperienceById(id);
        return {
            success: true,
            message: 'Experience details retrieved successfully',
            data: experience,
        };
    }
    async getExperiencesByCategory(category) {
        const experiences = await this.experiencesService.getExperiencesByCategory(category);
        return {
            success: true,
            message: `Experiences in ${category} category retrieved successfully`,
            data: experiences,
        };
    }
    async getExperienceSchedules(id, date) {
        const schedules = await this.experiencesService.getExperienceSchedules(id, date);
        return {
            success: true,
            message: 'Experience schedules retrieved successfully',
            data: schedules,
        };
    }
};
exports.ExperiencesController = ExperiencesController;
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all experiences grouped by category' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Experiences retrieved successfully',
        type: experience_response_dto_1.ExperiencesResponseDto
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ExperiencesController.prototype, "getAllExperiences", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, swagger_1.ApiOperation)({ summary: 'Get experience details by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Experience ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Experience details retrieved successfully',
        type: experience_response_dto_1.ExperienceDetailResponseDto
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Experience not found' }),
    __param(0, (0, common_1.Param)('id', common_1.ParseIntPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], ExperiencesController.prototype, "getExperienceById", null);
__decorate([
    (0, common_1.Get)('category/:category'),
    (0, swagger_1.ApiOperation)({ summary: 'Get experiences by category' }),
    (0, swagger_1.ApiParam)({ name: 'category', description: 'Experience category' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Experiences by category retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'array',
                    items: { $ref: '#/components/schemas/ExperienceCardDto' }
                }
            }
        }
    }),
    __param(0, (0, common_1.Param)('category')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ExperiencesController.prototype, "getExperiencesByCategory", null);
__decorate([
    (0, common_1.Get)(':id/schedules'),
    (0, swagger_1.ApiOperation)({ summary: 'Get experience schedules by ID and date' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Experience ID' }),
    (0, swagger_1.ApiQuery)({ name: 'date', description: 'Date in YYYY-MM-DD format', required: false }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Experience schedules retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'number' },
                            startTime: { type: 'string', format: 'date-time' },
                            endTime: { type: 'string', format: 'date-time' },
                            price: { type: 'number' },
                            priceUnit: { type: 'string' },
                            durationMinutes: { type: 'number' },
                            seatsAvailable: { type: 'number' },
                            status: { type: 'string' },
                            time: { type: 'string' },
                            available: { type: 'boolean' }
                        }
                    }
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Experience not found' }),
    __param(0, (0, common_1.Param)('id', common_1.ParseIntPipe)),
    __param(1, (0, common_1.Query)('date')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, String]),
    __metadata("design:returntype", Promise)
], ExperiencesController.prototype, "getExperienceSchedules", null);
exports.ExperiencesController = ExperiencesController = __decorate([
    (0, swagger_1.ApiTags)('Experiences'),
    (0, common_1.Controller)('experiences'),
    __metadata("design:paramtypes", [typeof (_a = typeof experiences_service_1.ExperiencesService !== "undefined" && experiences_service_1.ExperiencesService) === "function" ? _a : Object])
], ExperiencesController);


/***/ }),
/* 156 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExperiencesService = void 0;
const common_1 = __webpack_require__(2);
const typeorm_1 = __webpack_require__(6);
const typeorm_2 = __webpack_require__(13);
const experience_template_entity_1 = __webpack_require__(32);
const experience_image_entity_1 = __webpack_require__(33);
const experience_schedule_entity_1 = __webpack_require__(34);
let ExperiencesService = class ExperiencesService {
    constructor(experienceTemplateRepository, experienceImageRepository, experienceScheduleRepository) {
        this.experienceTemplateRepository = experienceTemplateRepository;
        this.experienceImageRepository = experienceImageRepository;
        this.experienceScheduleRepository = experienceScheduleRepository;
    }
    async getAllExperiences() {
        const experiences = await this.experienceTemplateRepository
            .createQueryBuilder('et')
            .leftJoinAndSelect('et.images', 'ei')
            .leftJoinAndSelect('et.schedules', 'es')
            .leftJoinAndSelect('et.company', 'c')
            .where('et.isActive = :isActive', { isActive: true })
            .orderBy('et.createdAt', 'DESC')
            .getMany();
        const categoriesMap = new Map();
        experiences.forEach(experience => {
            const category = this.getCategoryFromExperience(experience);
            if (!categoriesMap.has(category)) {
                categoriesMap.set(category, []);
            }
            categoriesMap.get(category).push(experience);
        });
        const categories = [];
        categoriesMap.forEach((experiences, categoryTitle) => {
            const deals = experiences.map(exp => this.transformToCardDto(exp));
            categories.push({
                title: categoryTitle,
                deals,
            });
        });
        return categories;
    }
    async getExperienceById(id) {
        const experience = await this.experienceTemplateRepository
            .createQueryBuilder('et')
            .leftJoinAndSelect('et.images', 'ei')
            .leftJoinAndSelect('et.schedules', 'es')
            .leftJoinAndSelect('et.company', 'c')
            .where('et.id = :id', { id })
            .andWhere('et.isActive = :isActive', { isActive: true })
            .orderBy('ei.sortOrder', 'ASC')
            .getOne();
        if (!experience) {
            throw new common_1.NotFoundException(`Experience with ID ${id} not found`);
        }
        return this.transformToDetailDto(experience);
    }
    async getExperiencesByCategory(category) {
        const experiences = await this.experienceTemplateRepository
            .createQueryBuilder('et')
            .leftJoinAndSelect('et.images', 'ei')
            .leftJoinAndSelect('et.schedules', 'es')
            .leftJoinAndSelect('et.company', 'c')
            .where('et.isActive = :isActive', { isActive: true })
            .andWhere('et.city LIKE :category OR et.country LIKE :category', {
            category: `%${category}%`
        })
            .orderBy('et.createdAt', 'DESC')
            .getMany();
        return experiences.map(exp => this.transformToCardDto(exp));
    }
    async getExperienceSchedules(id, date) {
        const queryBuilder = this.experienceScheduleRepository
            .createQueryBuilder('es')
            .where('es.experienceId = :id', { id })
            .andWhere('es.status = :status', { status: 'scheduled' });
        if (date) {
            const targetDate = new Date(date);
            const nextDate = new Date(targetDate);
            nextDate.setDate(nextDate.getDate() + 1);
            queryBuilder
                .andWhere('es.startTime >= :startDate', { startDate: targetDate })
                .andWhere('es.startTime < :endDate', { endDate: nextDate });
        }
        const schedules = await queryBuilder
            .orderBy('es.startTime', 'ASC')
            .getMany();
        return schedules.map(schedule => ({
            id: schedule.id,
            startTime: schedule.startTime,
            endTime: schedule.endTime,
            price: schedule.total,
            priceUnit: schedule.priceUnit,
            durationMinutes: schedule.durationMinutes,
            seatsAvailable: schedule.seatsAvailable,
            status: schedule.status,
            time: schedule.startTime.toTimeString().substring(0, 5),
            available: schedule.seatsAvailable > 0
        }));
    }
    getCategoryFromExperience(experience) {
        const title = experience.title.toLowerCase();
        const city = experience.city.toLowerCase();
        if (title.includes('helicopter') || title.includes('aerial') || title.includes('skyline')) {
            return 'Aerial Sightseeing Tours';
        }
        else if (title.includes('ski') || title.includes('snow')) {
            return 'Heli Skiing';
        }
        else if (title.includes('fish') || title.includes('fishing')) {
            return 'Fishing';
        }
        else if (title.includes('wine') || title.includes('dine') || title.includes('restaurant')) {
            return 'Fly and Dine';
        }
        else if (title.includes('skydive') || title.includes('parachute')) {
            return 'Skydiving';
        }
        else if (title.includes('hike') || title.includes('trek') || title.includes('mountain')) {
            return 'Hiking';
        }
        else if (title.includes('surf') || title.includes('wave')) {
            return 'Surfing';
        }
        else if (title.includes('romantic') || title.includes('sunset') || title.includes('couple')) {
            return 'Romantic';
        }
        else if (title.includes('northern lights') || title.includes('aurora') || title.includes('seasonal')) {
            return 'Seasonal';
        }
        else {
            return 'Adventure Tours';
        }
    }
    transformToCardDto(experience) {
        const mainImage = experience.images?.find(img => img.imageSlot === 'image1') ||
            experience.images?.[0];
        const firstSchedule = experience.schedules?.[0];
        const rating = '4.8';
        return {
            id: experience.id,
            imageUrl: mainImage?.url || 'https://images.unsplash.com/photo-1540979388789-6cee28a1cdc9?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80',
            title: experience.title,
            location: `${experience.city}, ${experience.country}`,
            duration: firstSchedule ? `${firstSchedule.durationMinutes} minutes` : 'Varies',
            price: firstSchedule ? `$${firstSchedule.total}` : 'Contact for pricing',
            rating,
            seatsAvailable: firstSchedule?.seatsAvailable || 0,
        };
    }
    transformToDetailDto(experience) {
        return {
            id: experience.id,
            title: experience.title,
            description: experience.description,
            country: experience.country,
            city: experience.city,
            locationName: experience.locationName,
            termsConditions: experience.termsConditions || '',
            images: experience.images?.map(img => ({
                id: img.id,
                imageSlot: img.imageSlot,
                url: img.url,
                sortOrder: img.sortOrder,
            })) || [],
            schedules: experience.schedules?.map(schedule => ({
                id: schedule.id,
                startTime: schedule.startTime,
                endTime: schedule.endTime,
                price: schedule.total,
                priceUnit: schedule.priceUnit,
                durationMinutes: schedule.durationMinutes,
                seatsAvailable: schedule.seatsAvailable,
                status: schedule.status,
            })) || [],
            createdAt: experience.createdAt,
            updatedAt: experience.updatedAt,
        };
    }
};
exports.ExperiencesService = ExperiencesService;
exports.ExperiencesService = ExperiencesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(experience_template_entity_1.ExperienceTemplate)),
    __param(1, (0, typeorm_1.InjectRepository)(experience_image_entity_1.ExperienceImage)),
    __param(2, (0, typeorm_1.InjectRepository)(experience_schedule_entity_1.ExperienceSchedule)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object])
], ExperiencesService);


/***/ }),
/* 157 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExperienceDetailResponseDto = exports.ExperiencesResponseDto = exports.ExperienceCategoryDto = exports.ExperienceCardDto = exports.ExperienceDetailDto = exports.ExperienceImageDto = exports.ExperienceScheduleDto = void 0;
const swagger_1 = __webpack_require__(3);
const experience_schedule_entity_1 = __webpack_require__(34);
class ExperienceScheduleDto {
}
exports.ExperienceScheduleDto = ExperienceScheduleDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ExperienceScheduleDto.prototype, "id", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], ExperienceScheduleDto.prototype, "startTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ required: false }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], ExperienceScheduleDto.prototype, "endTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ExperienceScheduleDto.prototype, "price", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: experience_schedule_entity_1.PriceUnit }),
    __metadata("design:type", typeof (_c = typeof experience_schedule_entity_1.PriceUnit !== "undefined" && experience_schedule_entity_1.PriceUnit) === "function" ? _c : Object)
], ExperienceScheduleDto.prototype, "priceUnit", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ExperienceScheduleDto.prototype, "durationMinutes", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ExperienceScheduleDto.prototype, "seatsAvailable", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: experience_schedule_entity_1.ScheduleStatus }),
    __metadata("design:type", typeof (_d = typeof experience_schedule_entity_1.ScheduleStatus !== "undefined" && experience_schedule_entity_1.ScheduleStatus) === "function" ? _d : Object)
], ExperienceScheduleDto.prototype, "status", void 0);
class ExperienceImageDto {
}
exports.ExperienceImageDto = ExperienceImageDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ExperienceImageDto.prototype, "id", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceImageDto.prototype, "imageSlot", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceImageDto.prototype, "url", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ExperienceImageDto.prototype, "sortOrder", void 0);
class ExperienceDetailDto {
}
exports.ExperienceDetailDto = ExperienceDetailDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ExperienceDetailDto.prototype, "id", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceDetailDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceDetailDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceDetailDto.prototype, "country", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceDetailDto.prototype, "city", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ required: false }),
    __metadata("design:type", String)
], ExperienceDetailDto.prototype, "locationName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceDetailDto.prototype, "termsConditions", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: [ExperienceImageDto] }),
    __metadata("design:type", Array)
], ExperienceDetailDto.prototype, "images", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: [ExperienceScheduleDto] }),
    __metadata("design:type", Array)
], ExperienceDetailDto.prototype, "schedules", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], ExperienceDetailDto.prototype, "createdAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_f = typeof Date !== "undefined" && Date) === "function" ? _f : Object)
], ExperienceDetailDto.prototype, "updatedAt", void 0);
class ExperienceCardDto {
}
exports.ExperienceCardDto = ExperienceCardDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ExperienceCardDto.prototype, "id", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceCardDto.prototype, "imageUrl", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceCardDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceCardDto.prototype, "location", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceCardDto.prototype, "duration", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceCardDto.prototype, "price", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceCardDto.prototype, "rating", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ExperienceCardDto.prototype, "seatsAvailable", void 0);
class ExperienceCategoryDto {
}
exports.ExperienceCategoryDto = ExperienceCategoryDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceCategoryDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: [ExperienceCardDto] }),
    __metadata("design:type", Array)
], ExperienceCategoryDto.prototype, "deals", void 0);
class ExperiencesResponseDto {
}
exports.ExperiencesResponseDto = ExperiencesResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], ExperiencesResponseDto.prototype, "success", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperiencesResponseDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: [ExperienceCategoryDto] }),
    __metadata("design:type", Object)
], ExperiencesResponseDto.prototype, "data", void 0);
class ExperienceDetailResponseDto {
}
exports.ExperienceDetailResponseDto = ExperienceDetailResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], ExperienceDetailResponseDto.prototype, "success", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ExperienceDetailResponseDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: ExperienceDetailDto }),
    __metadata("design:type", ExperienceDetailDto)
], ExperienceDetailResponseDto.prototype, "data", void 0);


/***/ }),
/* 158 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmsModule = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(5);
const sms_controller_1 = __webpack_require__(159);
const sms_service_1 = __webpack_require__(160);
let SmsModule = class SmsModule {
};
exports.SmsModule = SmsModule;
exports.SmsModule = SmsModule = __decorate([
    (0, common_1.Module)({
        imports: [config_1.ConfigModule],
        controllers: [sms_controller_1.SmsController],
        providers: [sms_service_1.SmsService],
        exports: [sms_service_1.SmsService],
    })
], SmsModule);


/***/ }),
/* 159 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const sms_service_1 = __webpack_require__(160);
let SmsController = class SmsController {
    constructor(smsService) {
        this.smsService = smsService;
    }
    async sendVerificationCode(body) {
        const { phoneNumber } = body;
        if (!phoneNumber) {
            return {
                success: false,
                message: 'Phone number is required',
            };
        }
        return await this.smsService.sendVerificationCode(phoneNumber);
    }
    async verifyCode(body) {
        const { phoneNumber, code } = body;
        if (!phoneNumber || !code) {
            return {
                success: false,
                message: 'Phone number and code are required',
            };
        }
        return await this.smsService.verifyCode(phoneNumber, code);
    }
};
exports.SmsController = SmsController;
__decorate([
    (0, common_1.Post)('send-verification'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Send SMS verification code' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Verification code sent successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid phone number' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SmsController.prototype, "sendVerificationCode", null);
__decorate([
    (0, common_1.Post)('verify-code'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Verify SMS code' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Code verified successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid verification code' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SmsController.prototype, "verifyCode", null);
exports.SmsController = SmsController = __decorate([
    (0, swagger_1.ApiTags)('SMS Verification'),
    (0, common_1.Controller)('sms'),
    __metadata("design:paramtypes", [typeof (_a = typeof sms_service_1.SmsService !== "undefined" && sms_service_1.SmsService) === "function" ? _a : Object])
], SmsController);


/***/ }),
/* 160 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmsService = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(5);
const twilio = __webpack_require__(161);
let SmsService = class SmsService {
    constructor(configService) {
        this.configService = configService;
        const accountSid = this.configService.get('TWILIO_ACCOUNT_SID');
        const authToken = this.configService.get('TWILIO_AUTH_TOKEN');
        this.verifyServiceSid = this.configService.get('TWILIO_VERIFY_SERVICE_SID');
        if (!accountSid || !authToken || !this.verifyServiceSid) {
            throw new Error('Twilio credentials not configured. Please set TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, and TWILIO_VERIFY_SERVICE_SID');
        }
        this.client = twilio(accountSid, authToken);
    }
    async sendVerificationCode(phoneNumber) {
        try {
            console.log(`Sending verification code to: ${phoneNumber}`);
            console.log(`Using Verify Service SID: ${this.verifyServiceSid}`);
            const verification = await this.client.verify.v2
                .services(this.verifyServiceSid)
                .verifications
                .create({
                to: phoneNumber,
                channel: 'sms'
            });
            console.log(`Verification sent successfully. Status: ${verification.status}`);
            return {
                success: true,
                message: 'Verification code sent successfully',
            };
        }
        catch (error) {
            console.error('Twilio Verify error:', error);
            return {
                success: false,
                message: `Failed to send verification code: ${error.message}`,
            };
        }
    }
    async verifyCode(phoneNumber, code) {
        try {
            console.log(`Verifying code ${code} for phone: ${phoneNumber}`);
            const verificationCheck = await this.client.verify.v2
                .services(this.verifyServiceSid)
                .verificationChecks
                .create({
                to: phoneNumber,
                code: code
            });
            console.log(`Verification check result. Status: ${verificationCheck.status}`);
            if (verificationCheck.status === 'approved') {
                return {
                    success: true,
                    message: 'Code verified successfully',
                };
            }
            else {
                return {
                    success: false,
                    message: 'Invalid verification code',
                };
            }
        }
        catch (error) {
            console.error('Twilio Verify check error:', error);
            return {
                success: false,
                message: `Verification failed: ${error.message}`,
            };
        }
    }
};
exports.SmsService = SmsService;
exports.SmsService = SmsService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], SmsService);


/***/ }),
/* 161 */
/***/ ((module) => {

module.exports = require("twilio");

/***/ }),
/* 162 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HealthController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
let HealthController = class HealthController {
    health() {
        return {
            status: 'ok',
            timestamp: new Date().toISOString(),
            uptime: process.uptime(),
        };
    }
    healthCheck() {
        return {
            status: 'ok',
            timestamp: new Date().toISOString(),
            uptime: process.uptime(),
        };
    }
};
exports.HealthController = HealthController;
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Health check endpoint' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Server is healthy',
        schema: {
            type: 'object',
            properties: {
                status: { type: 'string', example: 'ok' },
                timestamp: { type: 'string', example: '2024-01-01T00:00:00.000Z' },
                uptime: { type: 'number', example: 123.456 },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], HealthController.prototype, "health", null);
__decorate([
    (0, common_1.Get)('health'),
    (0, swagger_1.ApiOperation)({ summary: 'Health check endpoint' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Server is healthy',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], HealthController.prototype, "healthCheck", null);
exports.HealthController = HealthController = __decorate([
    (0, swagger_1.ApiTags)('health'),
    (0, common_1.Controller)()
], HealthController);


/***/ }),
/* 163 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Aircraft = exports.AircraftStatus = void 0;
const typeorm_1 = __webpack_require__(13);
var AircraftStatus;
(function (AircraftStatus) {
    AircraftStatus["ACTIVE"] = "active";
    AircraftStatus["INACTIVE"] = "inactive";
})(AircraftStatus || (exports.AircraftStatus = AircraftStatus = {}));
let Aircraft = class Aircraft {
};
exports.Aircraft = Aircraft;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], Aircraft.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], Aircraft.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100 }),
    __metadata("design:type", String)
], Aircraft.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int' }),
    __metadata("design:type", Number)
], Aircraft.prototype, "capacity", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'companyId' }),
    __metadata("design:type", Number)
], Aircraft.prototype, "companyId", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: AircraftStatus,
        default: AircraftStatus.ACTIVE
    }),
    __metadata("design:type", String)
], Aircraft.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'createdAt' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Aircraft.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updatedAt' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Aircraft.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)('Company', 'aircraft'),
    (0, typeorm_1.JoinColumn)({ name: 'companyId' }),
    __metadata("design:type", Object)
], Aircraft.prototype, "company", void 0);
__decorate([
    (0, typeorm_1.OneToMany)('Booking', 'aircraft'),
    __metadata("design:type", Array)
], Aircraft.prototype, "bookings", void 0);
exports.Aircraft = Aircraft = __decorate([
    (0, typeorm_1.Entity)('aircraft')
], Aircraft);


/***/ }),
/* 164 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserFile = exports.UserFileType = void 0;
const typeorm_1 = __webpack_require__(13);
const user_entity_1 = __webpack_require__(14);
const booking_entity_1 = __webpack_require__(29);
var UserFileType;
(function (UserFileType) {
    UserFileType["RECEIPT"] = "receipt";
    UserFileType["TICKET"] = "ticket";
    UserFileType["INVOICE"] = "invoice";
    UserFileType["BOARDING_PASS"] = "boarding_pass";
    UserFileType["ITINERARY"] = "itinerary";
    UserFileType["OTHER"] = "other";
})(UserFileType || (exports.UserFileType = UserFileType = {}));
let UserFile = class UserFile {
};
exports.UserFile = UserFile;
__decorate([
    (0, typeorm_1.PrimaryColumn)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], UserFile.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'user_id', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], UserFile.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'booking_id', nullable: true }),
    __metadata("design:type", String)
], UserFile.prototype, "bookingId", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: UserFileType }),
    __metadata("design:type", String)
], UserFile.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], UserFile.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text' }),
    __metadata("design:type", String)
], UserFile.prototype, "url", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'public_id', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], UserFile.prototype, "publicId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'file_size', type: 'int', nullable: true }),
    __metadata("design:type", Number)
], UserFile.prototype, "fileSize", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'file_format', type: 'varchar', length: 10, nullable: true }),
    __metadata("design:type", String)
], UserFile.prototype, "fileFormat", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'is_favorite', type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], UserFile.prototype, "isFavorite", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], UserFile.prototype, "notes", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'created_at' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], UserFile.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updated_at' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], UserFile.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, user => user.id),
    (0, typeorm_1.JoinColumn)({ name: 'user_id' }),
    __metadata("design:type", typeof (_c = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _c : Object)
], UserFile.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => booking_entity_1.Booking, booking => booking.id, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'booking_id' }),
    __metadata("design:type", typeof (_d = typeof booking_entity_1.Booking !== "undefined" && booking_entity_1.Booking) === "function" ? _d : Object)
], UserFile.prototype, "booking", void 0);
exports.UserFile = UserFile = __decorate([
    (0, typeorm_1.Entity)('user_files')
], UserFile);


/***/ }),
/* 165 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserEvent = exports.UserEventType = void 0;
const typeorm_1 = __webpack_require__(13);
const user_entity_1 = __webpack_require__(14);
const booking_entity_1 = __webpack_require__(29);
var UserEventType;
(function (UserEventType) {
    UserEventType["FLIGHT"] = "flight";
    UserEventType["REMINDER"] = "reminder";
    UserEventType["PERSONAL"] = "personal";
})(UserEventType || (exports.UserEventType = UserEventType = {}));
let UserEvent = class UserEvent {
};
exports.UserEvent = UserEvent;
__decorate([
    (0, typeorm_1.PrimaryColumn)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], UserEvent.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'user_id', type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], UserEvent.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'booking_id', nullable: true }),
    __metadata("design:type", String)
], UserEvent.prototype, "bookingId", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: UserEventType }),
    __metadata("design:type", String)
], UserEvent.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], UserEvent.prototype, "title", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], UserEvent.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'event_date', type: 'timestamp' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], UserEvent.prototype, "eventDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'end_date', type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], UserEvent.prototype, "endDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'is_all_day', type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], UserEvent.prototype, "isAllDay", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], UserEvent.prototype, "location", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'reminder_minutes', type: 'int', default: 60 }),
    __metadata("design:type", Number)
], UserEvent.prototype, "reminderMinutes", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'reminder_sent', type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], UserEvent.prototype, "reminderSent", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'created_at' }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], UserEvent.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updated_at' }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], UserEvent.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, user => user.id),
    (0, typeorm_1.JoinColumn)({ name: 'user_id' }),
    __metadata("design:type", typeof (_e = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _e : Object)
], UserEvent.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => booking_entity_1.Booking, booking => booking.id, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'booking_id' }),
    __metadata("design:type", typeof (_f = typeof booking_entity_1.Booking !== "undefined" && booking_entity_1.Booking) === "function" ? _f : Object)
], UserEvent.prototype, "booking", void 0);
exports.UserEvent = UserEvent = __decorate([
    (0, typeorm_1.Entity)('user_events')
], UserEvent);


/***/ }),
/* 166 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g, _h;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AircraftAvailability = exports.AvailabilityType = void 0;
const typeorm_1 = __webpack_require__(13);
const aircraft_entity_1 = __webpack_require__(35);
const charters_company_entity_1 = __webpack_require__(31);
const location_entity_1 = __webpack_require__(133);
var AvailabilityType;
(function (AvailabilityType) {
    AvailabilityType["AVAILABLE"] = "available";
    AvailabilityType["BOOKED"] = "booked";
    AvailabilityType["MAINTENANCE"] = "maintenance";
    AvailabilityType["BLOCKED"] = "blocked";
})(AvailabilityType || (exports.AvailabilityType = AvailabilityType = {}));
let AircraftAvailability = class AircraftAvailability {
};
exports.AircraftAvailability = AircraftAvailability;
__decorate([
    (0, typeorm_1.PrimaryColumn)({ type: 'varchar', length: 255 }),
    __metadata("design:type", String)
], AircraftAvailability.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'aircraft_id', type: 'int' }),
    __metadata("design:type", Number)
], AircraftAvailability.prototype, "aircraftId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'company_id', type: 'int' }),
    __metadata("design:type", Number)
], AircraftAvailability.prototype, "companyId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'booking_id', nullable: true }),
    __metadata("design:type", String)
], AircraftAvailability.prototype, "bookingId", void 0);
__decorate([
    (0, typeorm_1.Column)({
        name: 'availability_type',
        type: 'enum',
        enum: AvailabilityType,
        default: AvailabilityType.AVAILABLE
    }),
    __metadata("design:type", String)
], AircraftAvailability.prototype, "availabilityType", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'start_datetime', type: 'datetime' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], AircraftAvailability.prototype, "startDatetime", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'end_datetime', type: 'datetime' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], AircraftAvailability.prototype, "endDatetime", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'departure_location_id', type: 'int', nullable: true }),
    __metadata("design:type", Number)
], AircraftAvailability.prototype, "departureLocationId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'arrival_location_id', type: 'int', nullable: true }),
    __metadata("design:type", Number)
], AircraftAvailability.prototype, "arrivalLocationId", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'repositioning_required', type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], AircraftAvailability.prototype, "repositioningRequired", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'repositioning_cost', type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], AircraftAvailability.prototype, "repositioningCost", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], AircraftAvailability.prototype, "notes", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'created_by', type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], AircraftAvailability.prototype, "createdBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'booking_reference', type: 'varchar', length: 100, nullable: true }),
    __metadata("design:type", String)
], AircraftAvailability.prototype, "bookingReference", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'is_recurring', type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], AircraftAvailability.prototype, "isRecurring", void 0);
__decorate([
    (0, typeorm_1.Column)({ name: 'recurrence_pattern', type: 'json', nullable: true }),
    __metadata("design:type", Object)
], AircraftAvailability.prototype, "recurrencePattern", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ name: 'created_at' }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], AircraftAvailability.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ name: 'updated_at' }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], AircraftAvailability.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => aircraft_entity_1.Aircraft, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'aircraft_id' }),
    __metadata("design:type", typeof (_e = typeof aircraft_entity_1.Aircraft !== "undefined" && aircraft_entity_1.Aircraft) === "function" ? _e : Object)
], AircraftAvailability.prototype, "aircraft", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => charters_company_entity_1.ChartersCompany, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'company_id' }),
    __metadata("design:type", typeof (_f = typeof charters_company_entity_1.ChartersCompany !== "undefined" && charters_company_entity_1.ChartersCompany) === "function" ? _f : Object)
], AircraftAvailability.prototype, "company", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => location_entity_1.Location, { onDelete: 'SET NULL' }),
    (0, typeorm_1.JoinColumn)({ name: 'departure_location_id' }),
    __metadata("design:type", typeof (_g = typeof location_entity_1.Location !== "undefined" && location_entity_1.Location) === "function" ? _g : Object)
], AircraftAvailability.prototype, "departureLocation", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => location_entity_1.Location, { onDelete: 'SET NULL' }),
    (0, typeorm_1.JoinColumn)({ name: 'arrival_location_id' }),
    __metadata("design:type", typeof (_h = typeof location_entity_1.Location !== "undefined" && location_entity_1.Location) === "function" ? _h : Object)
], AircraftAvailability.prototype, "arrivalLocation", void 0);
exports.AircraftAvailability = AircraftAvailability = __decorate([
    (0, typeorm_1.Entity)('aircraft_availability')
], AircraftAvailability);


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;

Object.defineProperty(exports, "__esModule", ({ value: true }));
const core_1 = __webpack_require__(1);
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(3);
const app_module_1 = __webpack_require__(4);
const config_1 = __webpack_require__(5);
async function bootstrap() {
    const app = await core_1.NestFactory.create(app_module_1.AppModule);
    const configService = app.get(config_1.ConfigService);
    app.enableCors({
        origin: true,
        credentials: true,
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
        allowedHeaders: ['Content-Type', 'Authorization', 'Accept', 'Origin', 'X-Requested-With'],
    });
    app.setGlobalPrefix('api');
    app.useGlobalPipes(new common_1.ValidationPipe({
        whitelist: true,
        forbidNonWhitelisted: true,
        transform: true,
        transformOptions: {
            enableImplicitConversion: true,
        },
    }));
    const config = new swagger_1.DocumentBuilder()
        .setTitle('Air Charters API')
        .setDescription('Air Charters Backend API Documentation')
        .setVersion('1.0')
        .addBearerAuth()
        .addTag('auth', 'Authentication endpoints')
        .build();
    const document = swagger_1.SwaggerModule.createDocument(app, config);
    swagger_1.SwaggerModule.setup('api/docs', app, document);
    const port = configService.get('PORT', 3000);
    await app.listen(port);
    console.log(`ðŸš€ Air Charters API is running on: http://localhost:${port}`);
    console.log(`ðŸ“š API Documentation: http://localhost:${port}/api/docs`);
    console.log(`ðŸ” Auth endpoints: http://localhost:${port}/api/auth`);
}
bootstrap();

})();

/******/ })()
;